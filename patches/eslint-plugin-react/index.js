/* esm.sh - esbuild bundle(gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba) denonext development */
import __Process$ from "node:process";
var __global$ = globalThis || (typeof window !== "undefined" ? window : self);
import * as __0$ from "node:path";
import * as __1$ from "node:fs";
import * as __2$ from "node:path";
import * as __3$ from "node:assert";
import * as __4$ from "node:fs";
import * as __5$ from "node:path";
import * as __6$ from "node:fs";
import * as __7$ from "node:path";
import * as __8$ from "node:path";
import * as __9$ from "node:os";
import * as __a$ from "node:path";
var require=n=>{const e=m=>typeof m.default<"u"?m.default:m,c=m=>Object.assign({__esModule:true},m);switch(n){case"path":return e(__0$);case"fs":return e(__1$);case"assert":return e(__3$);case"os":return e(__9$);default:throw new Error("module \""+n+"\" not found");}};
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/isArguments.js"(exports, module) {
    "use strict";
    var toStr = Object.prototype.toString;
    module.exports = function isArguments(value) {
      var str = toStr.call(value);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/implementation.js
var require_implementation = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/implementation.js"(exports, module) {
    "use strict";
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k in window) {
          try {
            if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
              try {
                equalsConstructorPrototype(window[k]);
              } catch (e) {
                return true;
              }
            }
          } catch (e) {
            return true;
          }
        }
        return false;
      }();
      equalsConstructorPrototypeIfNotBuggy = function(o) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o);
        }
        try {
          return equalsConstructorPrototype(o);
        } catch (e) {
          return false;
        }
      };
      keysShim = function keys(object) {
        var isObject = object !== null && typeof object === "object";
        var isFunction = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString = isObject && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject && !isFunction && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object.length > 0 && !has.call(object, 0)) {
          for (var i = 0; i < object.length; ++i) {
            theKeys.push(String(i));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j = 0; j < object.length; ++j) {
            theKeys.push(String(j));
          }
        } else {
          for (var name in object) {
            if (!(skipProto && name === "prototype") && has.call(object, name)) {
              theKeys.push(String(name));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k = 0; k < dontEnums.length; ++k) {
            if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
              theKeys.push(dontEnums[k]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module.exports = keysShim;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/index.js"(exports, module) {
    "use strict";
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o) {
      return origKeys(o);
    } : require_implementation();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object) {
            if (isArgs(object)) {
              return originalKeys(slice.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module.exports = keysShim;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js"(exports, module) {
    "use strict";
    module.exports = Error;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js"(exports, module) {
    "use strict";
    module.exports = EvalError;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js
var require_range = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js"(exports, module) {
    "use strict";
    module.exports = RangeError;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js"(exports, module) {
    "use strict";
    module.exports = ReferenceError;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js"(exports, module) {
    "use strict";
    module.exports = SyntaxError;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js
var require_type = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js"(exports, module) {
    "use strict";
    module.exports = TypeError;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js"(exports, module) {
    "use strict";
    module.exports = URIError;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/has-symbols@1.0.3/node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/has-symbols@1.0.3/node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/has-symbols@1.0.3/node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/has-symbols@1.0.3/node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/has-proto@1.0.3/node_modules/has-proto/index.js
var require_has_proto = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/has-proto@1.0.3/node_modules/has-proto/index.js"(exports, module) {
    "use strict";
    var test = {
      __proto__: null,
      foo: {}
    };
    var $Object = Object;
    module.exports = function hasProto() {
      return { __proto__: test }.foo === test.foo && !(test instanceof $Object);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js
var require_implementation2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation2();
    module.exports = Function.prototype.bind || implementation;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js
var require_hasown = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js"(exports, module) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module.exports = bind.call(call, $hasOwn);
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/get-intrinsic@1.2.4/node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/get-intrinsic@1.2.4/node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    var undefined2;
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var hasProto = require_has_proto()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
      return x.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-define-property@1.0.0/node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-define-property@1.0.0/node_modules/es-define-property/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true) || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module.exports = $defineProperty;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/gopd@1.0.1/node_modules/gopd/index.js
var require_gopd = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/gopd@1.0.1/node_modules/gopd/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/define-data-property@1.1.4/node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/define-data-property@1.1.4/node_modules/define-data-property/index.js"(exports, module) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var gopd = require_gopd();
    module.exports = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/has-property-descriptors@1.0.2/node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/has-property-descriptors@1.0.2/node_modules/has-property-descriptors/index.js"(exports, module) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module.exports = hasPropertyDescriptors;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/define-properties@1.2.1/node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/define-properties@1.2.1/node_modules/define-properties/index.js"(exports, module) {
    "use strict";
    var keys = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var defineDataProperty = require_define_data_property();
    var isFunction = function(fn) {
      return typeof fn === "function" && toStr.call(fn) === "[object Function]";
    };
    var supportsDescriptors = require_has_property_descriptors()();
    var defineProperty = function(object, name, value, predicate) {
      if (name in object) {
        if (predicate === true) {
          if (object[name] === value) {
            return;
          }
        } else if (!isFunction(predicate) || !predicate()) {
          return;
        }
      }
      if (supportsDescriptors) {
        defineDataProperty(object, name, value, true);
      } else {
        defineDataProperty(object, name, value);
      }
    };
    var defineProperties = function(object, map) {
      var predicates = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map);
      if (hasSymbols) {
        props = concat.call(props, Object.getOwnPropertySymbols(map));
      }
      for (var i = 0; i < props.length; i += 1) {
        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module.exports = defineProperties;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/set-function-length@1.2.2/node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/set-function-length@1.2.2/node_modules/set-function-length/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var define = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = require_type();
    var $floor = GetIntrinsic("%Math.floor%");
    module.exports = function setFunctionLength(fn, length) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length,
            true,
            true
          );
        } else {
          define(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length
          );
        }
      }
      return fn;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/call-bind@1.0.7/node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/call-bind@1.0.7/node_modules/call-bind/index.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var setFunctionLength = require_set_function_length();
    var $TypeError = require_type();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $defineProperty = require_es_define_property();
    var $max = GetIntrinsic("%Math.max%");
    module.exports = function callBind(originalFunction) {
      if (typeof originalFunction !== "function") {
        throw new $TypeError("a function is required");
      }
      var func = $reflectApply(bind, $call, arguments);
      return setFunctionLength(
        func,
        1 + $max(0, originalFunction.length - (arguments.length - 1)),
        true
      );
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});

// (disabled):../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object-inspect@1.13.1/node_modules/object-inspect/util.inspect
var require_util = __commonJS({
  "(disabled):../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object-inspect@1.13.1/node_modules/object-inspect/util.inspect"() {
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object-inspect@1.13.1/node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object-inspect@1.13.1/node_modules/object-inspect/index.js"(exports, module) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    module.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (obj === __global$) {
        return "{ [object globalThis] }";
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    function isArray(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    function isMap(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e) {
      }
      return false;
    }
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    function isWeakRef(x) {
      if (!weakRefDeref || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isSet(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e) {
      }
      return false;
    }
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    function isElement(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/call-bind@1.0.7/node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/call-bind@1.0.7/node_modules/call-bind/callBound.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/IsArray.js
var require_IsArray = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/IsArray.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $Array = GetIntrinsic("%Array%");
    var toStr = !$Array.isArray && require_callBound()("Object.prototype.toString");
    module.exports = $Array.isArray || function IsArray(argument) {
      return toStr(argument) === "[object Array]";
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IsArray.js
var require_IsArray2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IsArray.js"(exports, module) {
    "use strict";
    module.exports = require_IsArray();
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/Call.js
var require_Call = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/Call.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var $TypeError = require_type();
    var IsArray = require_IsArray2();
    var $apply = GetIntrinsic("%Reflect.apply%", true) || callBound("Function.prototype.apply");
    module.exports = function Call(F, V) {
      var argumentsList = arguments.length > 2 ? arguments[2] : [];
      if (!IsArray(argumentsList)) {
        throw new $TypeError("Assertion failed: optional `argumentsList`, if provided, must be a List");
      }
      return $apply(F, V, argumentsList);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IsPropertyKey.js
var require_IsPropertyKey = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IsPropertyKey.js"(exports, module) {
    "use strict";
    module.exports = function IsPropertyKey(argument) {
      return typeof argument === "string" || typeof argument === "symbol";
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/5/Type.js
var require_Type = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/5/Type.js"(exports, module) {
    "use strict";
    module.exports = function Type(x) {
      if (x === null) {
        return "Null";
      }
      if (typeof x === "undefined") {
        return "Undefined";
      }
      if (typeof x === "function" || typeof x === "object") {
        return "Object";
      }
      if (typeof x === "number") {
        return "Number";
      }
      if (typeof x === "boolean") {
        return "Boolean";
      }
      if (typeof x === "string") {
        return "String";
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/Type.js
var require_Type2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/Type.js"(exports, module) {
    "use strict";
    var ES5Type = require_Type();
    module.exports = function Type(x) {
      if (typeof x === "symbol") {
        return "Symbol";
      }
      if (typeof x === "bigint") {
        return "BigInt";
      }
      return ES5Type(x);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/Get.js
var require_Get = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/Get.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var inspect = require_object_inspect();
    var IsPropertyKey = require_IsPropertyKey();
    var Type = require_Type2();
    module.exports = function Get(O, P) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true, got " + inspect(P));
      }
      return O[P];
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/isLeadingSurrogate.js
var require_isLeadingSurrogate = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/isLeadingSurrogate.js"(exports, module) {
    "use strict";
    module.exports = function isLeadingSurrogate(charCode) {
      return typeof charCode === "number" && charCode >= 55296 && charCode <= 56319;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/isTrailingSurrogate.js
var require_isTrailingSurrogate = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/isTrailingSurrogate.js"(exports, module) {
    "use strict";
    module.exports = function isTrailingSurrogate(charCode) {
      return typeof charCode === "number" && charCode >= 56320 && charCode <= 57343;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/UTF16SurrogatePairToCodePoint.js
var require_UTF16SurrogatePairToCodePoint = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/UTF16SurrogatePairToCodePoint.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = require_type();
    var $fromCharCode = GetIntrinsic("%String.fromCharCode%");
    var isLeadingSurrogate = require_isLeadingSurrogate();
    var isTrailingSurrogate = require_isTrailingSurrogate();
    module.exports = function UTF16SurrogatePairToCodePoint(lead, trail) {
      if (!isLeadingSurrogate(lead) || !isTrailingSurrogate(trail)) {
        throw new $TypeError("Assertion failed: `lead` must be a leading surrogate char code, and `trail` must be a trailing surrogate char code");
      }
      return $fromCharCode(lead) + $fromCharCode(trail);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/CodePointAt.js
var require_CodePointAt = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/CodePointAt.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var callBound = require_callBound();
    var isLeadingSurrogate = require_isLeadingSurrogate();
    var isTrailingSurrogate = require_isTrailingSurrogate();
    var UTF16SurrogatePairToCodePoint = require_UTF16SurrogatePairToCodePoint();
    var $charAt = callBound("String.prototype.charAt");
    var $charCodeAt = callBound("String.prototype.charCodeAt");
    module.exports = function CodePointAt(string, position) {
      if (typeof string !== "string") {
        throw new $TypeError("Assertion failed: `string` must be a String");
      }
      var size = string.length;
      if (position < 0 || position >= size) {
        throw new $TypeError("Assertion failed: `position` must be >= 0, and < the length of `string`");
      }
      var first = $charCodeAt(string, position);
      var cp = $charAt(string, position);
      var firstIsLeading = isLeadingSurrogate(first);
      var firstIsTrailing = isTrailingSurrogate(first);
      if (!firstIsLeading && !firstIsTrailing) {
        return {
          "[[CodePoint]]": cp,
          "[[CodeUnitCount]]": 1,
          "[[IsUnpairedSurrogate]]": false
        };
      }
      if (firstIsTrailing || position + 1 === size) {
        return {
          "[[CodePoint]]": cp,
          "[[CodeUnitCount]]": 1,
          "[[IsUnpairedSurrogate]]": true
        };
      }
      var second = $charCodeAt(string, position + 1);
      if (!isTrailingSurrogate(second)) {
        return {
          "[[CodePoint]]": cp,
          "[[CodeUnitCount]]": 1,
          "[[IsUnpairedSurrogate]]": true
        };
      }
      return {
        "[[CodePoint]]": UTF16SurrogatePairToCodePoint(first, second),
        "[[CodeUnitCount]]": 2,
        "[[IsUnpairedSurrogate]]": false
      };
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/isNaN.js
var require_isNaN = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/isNaN.js"(exports, module) {
    "use strict";
    module.exports = Number.isNaN || function isNaN2(a) {
      return a !== a;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/isFinite.js
var require_isFinite = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/isFinite.js"(exports, module) {
    "use strict";
    var $isNaN = require_isNaN();
    module.exports = function(x) {
      return (typeof x === "number" || typeof x === "bigint") && !$isNaN(x) && x !== Infinity && x !== -Infinity;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/isInteger.js
var require_isInteger = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/isInteger.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $abs = GetIntrinsic("%Math.abs%");
    var $floor = GetIntrinsic("%Math.floor%");
    var $isNaN = require_isNaN();
    var $isFinite = require_isFinite();
    module.exports = function isInteger(argument) {
      if (typeof argument !== "number" || $isNaN(argument) || !$isFinite(argument)) {
        return false;
      }
      var absValue = $abs(argument);
      return $floor(absValue) === absValue;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/maxSafeInteger.js
var require_maxSafeInteger = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/maxSafeInteger.js"(exports, module) {
    "use strict";
    module.exports = Number.MAX_SAFE_INTEGER || 9007199254740991;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/AdvanceStringIndex.js
var require_AdvanceStringIndex = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/AdvanceStringIndex.js"(exports, module) {
    "use strict";
    var CodePointAt = require_CodePointAt();
    var isInteger = require_isInteger();
    var MAX_SAFE_INTEGER = require_maxSafeInteger();
    var $TypeError = require_type();
    module.exports = function AdvanceStringIndex(S, index, unicode) {
      if (typeof S !== "string") {
        throw new $TypeError("Assertion failed: `S` must be a String");
      }
      if (!isInteger(index) || index < 0 || index > MAX_SAFE_INTEGER) {
        throw new $TypeError("Assertion failed: `length` must be an integer >= 0 and <= 2**53");
      }
      if (typeof unicode !== "boolean") {
        throw new $TypeError("Assertion failed: `unicode` must be a Boolean");
      }
      if (!unicode) {
        return index + 1;
      }
      var length = S.length;
      if (index + 1 >= length) {
        return index + 1;
      }
      var cp = CodePointAt(S, index);
      return index + cp["[[CodeUnitCount]]"];
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/CreateIterResultObject.js
var require_CreateIterResultObject = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/CreateIterResultObject.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    module.exports = function CreateIterResultObject(value, done) {
      if (typeof done !== "boolean") {
        throw new $TypeError("Assertion failed: Type(done) is not Boolean");
      }
      return {
        value,
        done
      };
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/ToBoolean.js
var require_ToBoolean = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/ToBoolean.js"(exports, module) {
    "use strict";
    module.exports = function ToBoolean(value) {
      return !!value;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IteratorComplete.js
var require_IteratorComplete = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IteratorComplete.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var Get = require_Get();
    var ToBoolean = require_ToBoolean();
    var Type = require_Type2();
    module.exports = function IteratorComplete(iterResult) {
      if (Type(iterResult) !== "Object") {
        throw new $TypeError("Assertion failed: Type(iterResult) is not Object");
      }
      return ToBoolean(Get(iterResult, "done"));
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IteratorValue.js
var require_IteratorValue = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IteratorValue.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var Get = require_Get();
    var Type = require_Type2();
    module.exports = function IteratorValue(iterResult) {
      if (Type(iterResult) !== "Object") {
        throw new $TypeError("Assertion failed: Type(iterResult) is not Object");
      }
      return Get(iterResult, "value");
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/PromiseResolve.js
var require_PromiseResolve = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/PromiseResolve.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $SyntaxError = require_syntax();
    var $resolve = GetIntrinsic("%Promise.resolve%", true);
    var $PromiseResolve = $resolve && callBind($resolve);
    module.exports = function PromiseResolve(C, x) {
      if (!$PromiseResolve) {
        throw new $SyntaxError("This environment does not support Promises.");
      }
      return $PromiseResolve(C, x);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/AsyncFromSyncIteratorContinuation.js
var require_AsyncFromSyncIteratorContinuation = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/AsyncFromSyncIteratorContinuation.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $Promise = GetIntrinsic("%Promise%", true);
    var callBound = require_callBound();
    var CreateIterResultObject = require_CreateIterResultObject();
    var IteratorComplete = require_IteratorComplete();
    var IteratorValue = require_IteratorValue();
    var PromiseResolve = require_PromiseResolve();
    var Type = require_Type2();
    var $then = callBound("Promise.prototype.then", true);
    module.exports = function AsyncFromSyncIteratorContinuation(result) {
      if (Type(result) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (arguments.length > 1) {
        throw new $SyntaxError("although AsyncFromSyncIteratorContinuation should take a second argument, it is not used in this implementation");
      }
      if (!$Promise) {
        throw new $SyntaxError("This environment does not support Promises.");
      }
      return new $Promise(function(resolve) {
        var done = IteratorComplete(result);
        var value = IteratorValue(result);
        var valueWrapper = PromiseResolve($Promise, value);
        var onFulfilled = function(value2) {
          return CreateIterResultObject(value2, done);
        };
        resolve($then(valueWrapper, onFulfilled));
      });
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/GetV.js
var require_GetV = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/GetV.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var inspect = require_object_inspect();
    var IsPropertyKey = require_IsPropertyKey();
    module.exports = function GetV(V, P) {
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true, got " + inspect(P));
      }
      return V[P];
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-callable@1.2.7/node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-callable@1.2.7/node_modules/is-callable/index.js"(exports, module) {
    "use strict";
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_) {
        if (_ !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      all = document.all;
      if (toStr.call(all) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e) {
            }
          }
          return false;
        };
      }
    }
    var all;
    module.exports = reflectApply ? function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e) {
        if (e !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IsCallable.js
var require_IsCallable = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IsCallable.js"(exports, module) {
    "use strict";
    module.exports = require_is_callable();
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/GetMethod.js
var require_GetMethod = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/GetMethod.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var GetV = require_GetV();
    var IsCallable = require_IsCallable();
    var IsPropertyKey = require_IsPropertyKey();
    var inspect = require_object_inspect();
    module.exports = function GetMethod(O, P) {
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var func = GetV(O, P);
      if (func == null) {
        return void 0;
      }
      if (!IsCallable(func)) {
        throw new $TypeError(inspect(P) + " is not a function: " + inspect(func));
      }
      return func;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/records/iterator-record.js
var require_iterator_record = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/records/iterator-record.js"(exports, module) {
    "use strict";
    var hasOwn = require_hasown();
    module.exports = function isIteratorRecord(value) {
      return !!value && typeof value === "object" && hasOwn(value, "[[Iterator]]") && hasOwn(value, "[[NextMethod]]") && typeof value["[[NextMethod]]"] === "function" && hasOwn(value, "[[Done]]") && typeof value["[[Done]]"] === "boolean";
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IteratorNext.js
var require_IteratorNext = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IteratorNext.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var Call = require_Call();
    var Type = require_Type2();
    var isIteratorRecord = require_iterator_record();
    module.exports = function IteratorNext(iteratorRecord) {
      if (!isIteratorRecord(iteratorRecord)) {
        throw new $TypeError("Assertion failed: `iteratorRecord` must be an Iterator Record");
      }
      var result;
      if (arguments.length < 2) {
        result = Call(iteratorRecord["[[NextMethod]]"], iteratorRecord["[[Iterator]]"]);
      } else {
        result = Call(iteratorRecord["[[NextMethod]]"], iteratorRecord["[[Iterator]]"], [arguments[1]]);
      }
      if (Type(result) !== "Object") {
        throw new $TypeError("iterator next must return an object");
      }
      return result;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/forEach.js
var require_forEach = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/forEach.js"(exports, module) {
    "use strict";
    module.exports = function forEach(array, callback) {
      for (var i = 0; i < array.length; i += 1) {
        callback(array[i], i, array);
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/side-channel@1.0.6/node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/side-channel@1.0.6/node_modules/side-channel/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect = require_object_inspect();
    var $TypeError = require_type();
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key) {
      var prev = list;
      var curr;
      for (; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = /** @type {NonNullable<typeof list.next>} */
          list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = /** @type {import('.').ListNode<typeof value>} */
        {
          // eslint-disable-line no-param-reassign, no-extra-parens
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      return !!listGetNode(objects, key);
    };
    module.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        }
      };
      return channel;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/internal-slot@1.0.7/node_modules/internal-slot/index.js
var require_internal_slot = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/internal-slot@1.0.7/node_modules/internal-slot/index.js"(exports, module) {
    "use strict";
    var hasOwn = require_hasown();
    var channel = require_side_channel()();
    var $TypeError = require_type();
    var SLOT = {
      assert: function(O, slot) {
        if (!O || typeof O !== "object" && typeof O !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        channel.assert(O);
        if (!SLOT.has(O, slot)) {
          throw new $TypeError("`" + slot + "` is not present on `O`");
        }
      },
      get: function(O, slot) {
        if (!O || typeof O !== "object" && typeof O !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        var slots = channel.get(O);
        return slots && slots["$" + slot];
      },
      has: function(O, slot) {
        if (!O || typeof O !== "object" && typeof O !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        var slots = channel.get(O);
        return !!slots && hasOwn(slots, "$" + slot);
      },
      set: function(O, slot, V) {
        if (!O || typeof O !== "object" && typeof O !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        var slots = channel.get(O);
        if (!slots) {
          slots = {};
          channel.set(O, slots);
        }
        slots["$" + slot] = V;
      }
    };
    if (Object.freeze) {
      Object.freeze(SLOT);
    }
    module.exports = SLOT;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/OrdinaryObjectCreate.js
var require_OrdinaryObjectCreate = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/OrdinaryObjectCreate.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $ObjectCreate = GetIntrinsic("%Object.create%", true);
    var $TypeError = require_type();
    var $SyntaxError = require_syntax();
    var IsArray = require_IsArray2();
    var Type = require_Type2();
    var forEach = require_forEach();
    var SLOT = require_internal_slot();
    var hasProto = require_has_proto()();
    module.exports = function OrdinaryObjectCreate(proto) {
      if (proto !== null && Type(proto) !== "Object") {
        throw new $TypeError("Assertion failed: `proto` must be null or an object");
      }
      var additionalInternalSlotsList = arguments.length < 2 ? [] : arguments[1];
      if (!IsArray(additionalInternalSlotsList)) {
        throw new $TypeError("Assertion failed: `additionalInternalSlotsList` must be an Array");
      }
      var O;
      if ($ObjectCreate) {
        O = $ObjectCreate(proto);
      } else if (hasProto) {
        O = { __proto__: proto };
      } else {
        if (proto === null) {
          throw new $SyntaxError("native Object.create support is required to create null objects");
        }
        var T = function T2() {
        };
        T.prototype = proto;
        O = new T();
      }
      if (additionalInternalSlotsList.length > 0) {
        forEach(additionalInternalSlotsList, function(slot) {
          SLOT.set(O, slot, void 0);
        });
      }
      return O;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/CreateAsyncFromSyncIterator.js
var require_CreateAsyncFromSyncIterator = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/CreateAsyncFromSyncIterator.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $Promise = GetIntrinsic("%Promise%", true);
    var AsyncFromSyncIteratorContinuation = require_AsyncFromSyncIteratorContinuation();
    var Call = require_Call();
    var CreateIterResultObject = require_CreateIterResultObject();
    var Get = require_Get();
    var GetMethod = require_GetMethod();
    var IteratorNext = require_IteratorNext();
    var OrdinaryObjectCreate = require_OrdinaryObjectCreate();
    var Type = require_Type2();
    var SLOT = require_internal_slot();
    var isIteratorRecord = require_iterator_record();
    var $AsyncFromSyncIteratorPrototype = GetIntrinsic("%AsyncFromSyncIteratorPrototype%", true) || {
      next: function next(value) {
        if (!$Promise) {
          throw new $SyntaxError("This environment does not support Promises.");
        }
        var O = this;
        SLOT.assert(O, "[[SyncIteratorRecord]]");
        var argsLength = arguments.length;
        return new $Promise(function(resolve) {
          var syncIteratorRecord = SLOT.get(O, "[[SyncIteratorRecord]]");
          var result;
          if (argsLength > 0) {
            result = IteratorNext(syncIteratorRecord, value);
          } else {
            result = IteratorNext(syncIteratorRecord);
          }
          resolve(AsyncFromSyncIteratorContinuation(result));
        });
      },
      "return": function() {
        if (!$Promise) {
          throw new $SyntaxError("This environment does not support Promises.");
        }
        var O = this;
        SLOT.assert(O, "[[SyncIteratorRecord]]");
        var valueIsPresent = arguments.length > 0;
        var value = valueIsPresent ? arguments[0] : void 0;
        return new $Promise(function(resolve, reject) {
          var syncIterator = SLOT.get(O, "[[SyncIteratorRecord]]")["[[Iterator]]"];
          var iteratorReturn = GetMethod(syncIterator, "return");
          if (typeof iteratorReturn === "undefined") {
            var iterResult = CreateIterResultObject(value, true);
            Call(resolve, void 0, [iterResult]);
            return;
          }
          var result;
          if (valueIsPresent) {
            result = Call(iteratorReturn, syncIterator, [value]);
          } else {
            result = Call(iteratorReturn, syncIterator);
          }
          if (Type(result) !== "Object") {
            Call(reject, void 0, [new $TypeError("Iterator `return` method returned a non-object value.")]);
            return;
          }
          resolve(AsyncFromSyncIteratorContinuation(result));
        });
      },
      "throw": function() {
        if (!$Promise) {
          throw new $SyntaxError("This environment does not support Promises.");
        }
        var O = this;
        SLOT.assert(O, "[[SyncIteratorRecord]]");
        var valueIsPresent = arguments.length > 0;
        var value = valueIsPresent ? arguments[0] : void 0;
        return new $Promise(function(resolve, reject) {
          var syncIterator = SLOT.get(O, "[[SyncIteratorRecord]]")["[[Iterator]]"];
          var throwMethod = GetMethod(syncIterator, "throw");
          if (typeof throwMethod === "undefined") {
            Call(reject, void 0, [value]);
            return;
          }
          var result;
          if (valueIsPresent) {
            result = Call(throwMethod, syncIterator, [value]);
          } else {
            result = Call(throwMethod, syncIterator);
          }
          if (Type(result) !== "Object") {
            Call(reject, void 0, [new $TypeError("Iterator `throw` method returned a non-object value.")]);
            return;
          }
          resolve(AsyncFromSyncIteratorContinuation(
            result
            /* , promiseCapability */
          ));
        });
      }
    };
    module.exports = function CreateAsyncFromSyncIterator(syncIteratorRecord) {
      if (!isIteratorRecord(syncIteratorRecord)) {
        throw new $TypeError("Assertion failed: `syncIteratorRecord` must be an Iterator Record");
      }
      var asyncIterator = OrdinaryObjectCreate($AsyncFromSyncIteratorPrototype);
      SLOT.set(asyncIterator, "[[SyncIteratorRecord]]", syncIteratorRecord);
      var nextMethod = Get(asyncIterator, "next");
      return {
        // steps 3-4
        "[[Iterator]]": asyncIterator,
        "[[NextMethod]]": nextMethod,
        "[[Done]]": false
      };
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/GetIteratorFromMethod.js
var require_GetIteratorFromMethod = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/GetIteratorFromMethod.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var Call = require_Call();
    var Get = require_Get();
    var IsCallable = require_IsCallable();
    var Type = require_Type2();
    module.exports = function GetIteratorFromMethod(obj, method) {
      if (!IsCallable(method)) {
        throw new $TypeError("method must be a function");
      }
      var iterator = Call(method, obj);
      if (Type(iterator) !== "Object") {
        throw new $TypeError("iterator must return an object");
      }
      var nextMethod = Get(iterator, "next");
      return {
        // steps 4-5
        "[[Iterator]]": iterator,
        "[[NextMethod]]": nextMethod,
        "[[Done]]": false
      };
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js"(exports, module) {
    "use strict";
    var hasSymbols = require_shams();
    module.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-string@1.0.7/node_modules/is-string/index.js
var require_is_string = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-string@1.0.7/node_modules/is-string/index.js"(exports, module) {
    "use strict";
    var strValue = String.prototype.valueOf;
    var tryStringObject = function tryStringObject2(value) {
      try {
        strValue.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var strClass = "[object String]";
    var hasToStringTag = require_shams2()();
    module.exports = function isString(value) {
      if (typeof value === "string") {
        return true;
      }
      if (typeof value !== "object") {
        return false;
      }
      return hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/getIteratorMethod.js
var require_getIteratorMethod = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/getIteratorMethod.js"(exports, module) {
    "use strict";
    var hasSymbols = require_has_symbols()();
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var isString = require_is_string();
    var $iterator = GetIntrinsic("%Symbol.iterator%", true);
    var $stringSlice = callBound("String.prototype.slice");
    var $String = GetIntrinsic("%String%");
    module.exports = function getIteratorMethod(ES, iterable) {
      var usingIterator;
      if (hasSymbols) {
        usingIterator = ES.GetMethod(iterable, $iterator);
      } else if (ES.IsArray(iterable)) {
        usingIterator = function() {
          var i = -1;
          var arr = this;
          return {
            next: function() {
              i += 1;
              return {
                done: i >= arr.length,
                value: arr[i]
              };
            }
          };
        };
      } else if (isString(iterable)) {
        usingIterator = function() {
          var i = 0;
          return {
            next: function() {
              var nextIndex = ES.AdvanceStringIndex($String(iterable), i, true);
              var value = $stringSlice(iterable, i, nextIndex);
              i = nextIndex;
              return {
                done: nextIndex > iterable.length,
                value
              };
            }
          };
        };
      }
      return usingIterator;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/GetIterator.js
var require_GetIterator = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/GetIterator.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = require_type();
    var $asyncIterator = GetIntrinsic("%Symbol.asyncIterator%", true);
    var inspect = require_object_inspect();
    var hasSymbols = require_has_symbols()();
    var AdvanceStringIndex = require_AdvanceStringIndex();
    var CreateAsyncFromSyncIterator = require_CreateAsyncFromSyncIterator();
    var GetIteratorFromMethod = require_GetIteratorFromMethod();
    var GetMethod = require_GetMethod();
    var IsArray = require_IsArray2();
    var getIteratorMethod = require_getIteratorMethod();
    module.exports = function GetIterator(obj, kind) {
      if (kind !== "SYNC" && kind !== "ASYNC") {
        throw new $TypeError("Assertion failed: `kind` must be one of 'sync' or 'async', got " + inspect(kind));
      }
      var method;
      if (kind === "ASYNC") {
        if (hasSymbols && $asyncIterator) {
          method = GetMethod(obj, $asyncIterator);
        }
      }
      if (typeof method === "undefined") {
        var syncMethod = getIteratorMethod(
          {
            AdvanceStringIndex,
            GetMethod,
            IsArray
          },
          obj
        );
        if (kind === "ASYNC") {
          if (typeof syncMethod === "undefined") {
            throw new $TypeError("iterator method is `undefined`");
          }
          var syncIteratorRecord = GetIteratorFromMethod(obj, syncMethod);
          return CreateAsyncFromSyncIterator(syncIteratorRecord);
        }
        method = syncMethod;
      }
      if (typeof method === "undefined") {
        throw new $TypeError("iterator method is `undefined`");
      }
      return GetIteratorFromMethod(obj, method);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/CompletionRecord.js
var require_CompletionRecord = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/CompletionRecord.js"(exports, module) {
    "use strict";
    var $SyntaxError = require_syntax();
    var SLOT = require_internal_slot();
    var CompletionRecord = function CompletionRecord2(type, value) {
      if (!(this instanceof CompletionRecord2)) {
        return new CompletionRecord2(type, value);
      }
      if (type !== "normal" && type !== "break" && type !== "continue" && type !== "return" && type !== "throw") {
        throw new $SyntaxError('Assertion failed: `type` must be one of "normal", "break", "continue", "return", or "throw"');
      }
      SLOT.set(this, "[[Type]]", type);
      SLOT.set(this, "[[Value]]", value);
    };
    CompletionRecord.prototype.type = function Type() {
      return SLOT.get(this, "[[Type]]");
    };
    CompletionRecord.prototype.value = function Value() {
      return SLOT.get(this, "[[Value]]");
    };
    CompletionRecord.prototype["?"] = function ReturnIfAbrupt() {
      var type = SLOT.get(this, "[[Type]]");
      var value = SLOT.get(this, "[[Value]]");
      if (type === "normal") {
        return value;
      }
      if (type === "throw") {
        throw value;
      }
      throw new $SyntaxError('Completion Record is not of type "normal" or "throw": other types not supported');
    };
    CompletionRecord.prototype["!"] = function assert() {
      var type = SLOT.get(this, "[[Type]]");
      if (type !== "normal") {
        throw new $SyntaxError('Assertion failed: Completion Record is not of type "normal"');
      }
      return SLOT.get(this, "[[Value]]");
    };
    module.exports = CompletionRecord;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IteratorClose.js
var require_IteratorClose = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IteratorClose.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var Call = require_Call();
    var CompletionRecord = require_CompletionRecord();
    var GetMethod = require_GetMethod();
    var IsCallable = require_IsCallable();
    var Type = require_Type2();
    var isIteratorRecord = require_iterator_record();
    module.exports = function IteratorClose(iteratorRecord, completion) {
      if (!isIteratorRecord(iteratorRecord)) {
        throw new $TypeError("Assertion failed: `iteratorRecord` must be an Iterator Record");
      }
      if (Type(iteratorRecord["[[Iterator]]"]) !== "Object") {
        throw new $TypeError("Assertion failed: iteratorRecord.[[Iterator]] must be an Object");
      }
      if (!IsCallable(completion) && !(completion instanceof CompletionRecord)) {
        throw new $TypeError("Assertion failed: completion is not a thunk representing a Completion Record, nor a Completion Record instance");
      }
      var completionThunk = completion instanceof CompletionRecord ? function() {
        return completion["?"]();
      } : completion;
      var iterator = iteratorRecord["[[Iterator]]"];
      var iteratorReturn;
      try {
        iteratorReturn = GetMethod(iterator, "return");
      } catch (e) {
        completionThunk();
        completionThunk = null;
        throw e;
      }
      if (typeof iteratorReturn === "undefined") {
        return completionThunk();
      }
      var innerResult;
      try {
        innerResult = Call(iteratorReturn, iterator, []);
      } catch (e) {
        completionThunk();
        completionThunk = null;
        throw e;
      }
      var completionRecord = completionThunk();
      completionThunk = null;
      if (Type(innerResult) !== "Object") {
        throw new $TypeError("iterator .return must return an object");
      }
      return completionRecord;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IteratorStep.js
var require_IteratorStep = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IteratorStep.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var IteratorComplete = require_IteratorComplete();
    var IteratorNext = require_IteratorNext();
    var isIteratorRecord = require_iterator_record();
    module.exports = function IteratorStep(iteratorRecord) {
      if (!isIteratorRecord(iteratorRecord)) {
        throw new $TypeError("Assertion failed: `iteratorRecord` must be an Iterator Record");
      }
      var result = IteratorNext(iteratorRecord);
      var done = IteratorComplete(result);
      return done === true ? false : result;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/ThrowCompletion.js
var require_ThrowCompletion = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/ThrowCompletion.js"(exports, module) {
    "use strict";
    var CompletionRecord = require_CompletionRecord();
    module.exports = function ThrowCompletion(argument) {
      return new CompletionRecord("throw", argument);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/AddEntriesFromIterable.js
var require_AddEntriesFromIterable = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/AddEntriesFromIterable.js"(exports, module) {
    "use strict";
    var inspect = require_object_inspect();
    var $TypeError = require_type();
    var Call = require_Call();
    var Get = require_Get();
    var GetIterator = require_GetIterator();
    var IsCallable = require_IsCallable();
    var IteratorClose = require_IteratorClose();
    var IteratorStep = require_IteratorStep();
    var IteratorValue = require_IteratorValue();
    var ThrowCompletion = require_ThrowCompletion();
    var Type = require_Type2();
    module.exports = function AddEntriesFromIterable(target, iterable, adder) {
      if (!IsCallable(adder)) {
        throw new $TypeError("Assertion failed: `adder` is not callable");
      }
      if (iterable == null) {
        throw new $TypeError("Assertion failed: `iterable` is present, and not nullish");
      }
      var iteratorRecord = GetIterator(iterable, "SYNC");
      while (true) {
        var next = IteratorStep(iteratorRecord);
        if (!next) {
          return target;
        }
        var nextItem = IteratorValue(next);
        if (Type(nextItem) !== "Object") {
          var error = ThrowCompletion(new $TypeError("iterator next must return an Object, got " + inspect(nextItem)));
          return IteratorClose(iteratorRecord, error);
        }
        try {
          var k = Get(nextItem, "0");
          var v = Get(nextItem, "1");
          Call(adder, target, [k, v]);
        } catch (e) {
          return IteratorClose(iteratorRecord, ThrowCompletion(e));
        }
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/records/property-descriptor.js
var require_property_descriptor = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/records/property-descriptor.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var hasOwn = require_hasown();
    var allowed = {
      __proto__: null,
      "[[Configurable]]": true,
      "[[Enumerable]]": true,
      "[[Get]]": true,
      "[[Set]]": true,
      "[[Value]]": true,
      "[[Writable]]": true
    };
    module.exports = function isPropertyDescriptor(Desc) {
      if (!Desc || typeof Desc !== "object") {
        return false;
      }
      for (var key in Desc) {
        if (hasOwn(Desc, key) && !allowed[key]) {
          return false;
        }
      }
      var isData = hasOwn(Desc, "[[Value]]") || hasOwn(Desc, "[[Writable]]");
      var IsAccessor = hasOwn(Desc, "[[Get]]") || hasOwn(Desc, "[[Set]]");
      if (isData && IsAccessor) {
        throw new $TypeError("Property Descriptors may not be both accessor and data descriptors");
      }
      return true;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IsAccessorDescriptor.js
var require_IsAccessorDescriptor = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IsAccessorDescriptor.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var hasOwn = require_hasown();
    var isPropertyDescriptor = require_property_descriptor();
    module.exports = function IsAccessorDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return false;
      }
      if (!isPropertyDescriptor(Desc)) {
        throw new $TypeError("Assertion failed: `Desc` must be a Property Descriptor");
      }
      if (!hasOwn(Desc, "[[Get]]") && !hasOwn(Desc, "[[Set]]")) {
        return false;
      }
      return true;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/isPrimitive.js
var require_isPrimitive = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/isPrimitive.js"(exports, module) {
    "use strict";
    module.exports = function isPrimitive(value) {
      return value === null || typeof value !== "function" && typeof value !== "object";
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IsExtensible.js
var require_IsExtensible = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IsExtensible.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $preventExtensions = GetIntrinsic("%Object.preventExtensions%", true);
    var $isExtensible = GetIntrinsic("%Object.isExtensible%", true);
    var isPrimitive = require_isPrimitive();
    module.exports = $preventExtensions ? function IsExtensible(obj) {
      return !isPrimitive(obj) && $isExtensible(obj);
    } : function IsExtensible(obj) {
      return !isPrimitive(obj);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/ToPropertyDescriptor.js
var require_ToPropertyDescriptor = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/ToPropertyDescriptor.js"(exports, module) {
    "use strict";
    var hasOwn = require_hasown();
    var $TypeError = require_type();
    var Type = require_Type2();
    var ToBoolean = require_ToBoolean();
    var IsCallable = require_IsCallable();
    module.exports = function ToPropertyDescriptor(Obj) {
      if (Type(Obj) !== "Object") {
        throw new $TypeError("ToPropertyDescriptor requires an object");
      }
      var desc = {};
      if (hasOwn(Obj, "enumerable")) {
        desc["[[Enumerable]]"] = ToBoolean(Obj.enumerable);
      }
      if (hasOwn(Obj, "configurable")) {
        desc["[[Configurable]]"] = ToBoolean(Obj.configurable);
      }
      if (hasOwn(Obj, "value")) {
        desc["[[Value]]"] = Obj.value;
      }
      if (hasOwn(Obj, "writable")) {
        desc["[[Writable]]"] = ToBoolean(Obj.writable);
      }
      if (hasOwn(Obj, "get")) {
        var getter = Obj.get;
        if (typeof getter !== "undefined" && !IsCallable(getter)) {
          throw new $TypeError("getter must be a function");
        }
        desc["[[Get]]"] = getter;
      }
      if (hasOwn(Obj, "set")) {
        var setter = Obj.set;
        if (typeof setter !== "undefined" && !IsCallable(setter)) {
          throw new $TypeError("setter must be a function");
        }
        desc["[[Set]]"] = setter;
      }
      if ((hasOwn(desc, "[[Get]]") || hasOwn(desc, "[[Set]]")) && (hasOwn(desc, "[[Value]]") || hasOwn(desc, "[[Writable]]"))) {
        throw new $TypeError("Invalid property descriptor. Cannot both specify accessors and a value or writable attribute");
      }
      return desc;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/SameValue.js
var require_SameValue = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/SameValue.js"(exports, module) {
    "use strict";
    var $isNaN = require_isNaN();
    module.exports = function SameValue(x, y) {
      if (x === y) {
        if (x === 0) {
          return 1 / x === 1 / y;
        }
        return true;
      }
      return $isNaN(x) && $isNaN(y);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/DefineOwnProperty.js
var require_DefineOwnProperty = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/DefineOwnProperty.js"(exports, module) {
    "use strict";
    var hasPropertyDescriptors = require_has_property_descriptors();
    var $defineProperty = require_es_define_property();
    var hasArrayLengthDefineBug = hasPropertyDescriptors.hasArrayLengthDefineBug();
    var isArray = hasArrayLengthDefineBug && require_IsArray();
    var callBound = require_callBound();
    var $isEnumerable = callBound("Object.prototype.propertyIsEnumerable");
    module.exports = function DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, desc) {
      if (!$defineProperty) {
        if (!IsDataDescriptor(desc)) {
          return false;
        }
        if (!desc["[[Configurable]]"] || !desc["[[Writable]]"]) {
          return false;
        }
        if (P in O && $isEnumerable(O, P) !== !!desc["[[Enumerable]]"]) {
          return false;
        }
        var V = desc["[[Value]]"];
        O[P] = V;
        return SameValue(O[P], V);
      }
      if (hasArrayLengthDefineBug && P === "length" && "[[Value]]" in desc && isArray(O) && O.length !== desc["[[Value]]"]) {
        O.length = desc["[[Value]]"];
        return O.length === desc["[[Value]]"];
      }
      $defineProperty(O, P, FromPropertyDescriptor(desc));
      return true;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/isFullyPopulatedPropertyDescriptor.js
var require_isFullyPopulatedPropertyDescriptor = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/isFullyPopulatedPropertyDescriptor.js"(exports, module) {
    "use strict";
    var isPropertyDescriptor = require_property_descriptor();
    module.exports = function isFullyPopulatedPropertyDescriptor(ES, Desc) {
      return isPropertyDescriptor(Desc) && typeof Desc === "object" && "[[Enumerable]]" in Desc && "[[Configurable]]" in Desc && (ES.IsAccessorDescriptor(Desc) || ES.IsDataDescriptor(Desc));
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/fromPropertyDescriptor.js
var require_fromPropertyDescriptor = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/fromPropertyDescriptor.js"(exports, module) {
    "use strict";
    module.exports = function fromPropertyDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return Desc;
      }
      var obj = {};
      if ("[[Value]]" in Desc) {
        obj.value = Desc["[[Value]]"];
      }
      if ("[[Writable]]" in Desc) {
        obj.writable = !!Desc["[[Writable]]"];
      }
      if ("[[Get]]" in Desc) {
        obj.get = Desc["[[Get]]"];
      }
      if ("[[Set]]" in Desc) {
        obj.set = Desc["[[Set]]"];
      }
      if ("[[Enumerable]]" in Desc) {
        obj.enumerable = !!Desc["[[Enumerable]]"];
      }
      if ("[[Configurable]]" in Desc) {
        obj.configurable = !!Desc["[[Configurable]]"];
      }
      return obj;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/FromPropertyDescriptor.js
var require_FromPropertyDescriptor = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/FromPropertyDescriptor.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var isPropertyDescriptor = require_property_descriptor();
    var fromPropertyDescriptor = require_fromPropertyDescriptor();
    module.exports = function FromPropertyDescriptor(Desc) {
      if (typeof Desc !== "undefined" && !isPropertyDescriptor(Desc)) {
        throw new $TypeError("Assertion failed: `Desc` must be a Property Descriptor");
      }
      return fromPropertyDescriptor(Desc);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IsDataDescriptor.js
var require_IsDataDescriptor = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IsDataDescriptor.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var hasOwn = require_hasown();
    var isPropertyDescriptor = require_property_descriptor();
    module.exports = function IsDataDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return false;
      }
      if (!isPropertyDescriptor(Desc)) {
        throw new $TypeError("Assertion failed: `Desc` must be a Property Descriptor");
      }
      if (!hasOwn(Desc, "[[Value]]") && !hasOwn(Desc, "[[Writable]]")) {
        return false;
      }
      return true;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IsGenericDescriptor.js
var require_IsGenericDescriptor = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IsGenericDescriptor.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var IsAccessorDescriptor = require_IsAccessorDescriptor();
    var IsDataDescriptor = require_IsDataDescriptor();
    var isPropertyDescriptor = require_property_descriptor();
    module.exports = function IsGenericDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return false;
      }
      if (!isPropertyDescriptor(Desc)) {
        throw new $TypeError("Assertion failed: `Desc` must be a Property Descriptor");
      }
      if (!IsAccessorDescriptor(Desc) && !IsDataDescriptor(Desc)) {
        return true;
      }
      return false;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/ValidateAndApplyPropertyDescriptor.js
var require_ValidateAndApplyPropertyDescriptor = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/ValidateAndApplyPropertyDescriptor.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var DefineOwnProperty = require_DefineOwnProperty();
    var isFullyPopulatedPropertyDescriptor = require_isFullyPopulatedPropertyDescriptor();
    var isPropertyDescriptor = require_property_descriptor();
    var FromPropertyDescriptor = require_FromPropertyDescriptor();
    var IsAccessorDescriptor = require_IsAccessorDescriptor();
    var IsDataDescriptor = require_IsDataDescriptor();
    var IsGenericDescriptor = require_IsGenericDescriptor();
    var IsPropertyKey = require_IsPropertyKey();
    var SameValue = require_SameValue();
    var Type = require_Type2();
    module.exports = function ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current) {
      var oType = Type(O);
      if (oType !== "Undefined" && oType !== "Object") {
        throw new $TypeError("Assertion failed: O must be undefined or an Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: P must be a Property Key");
      }
      if (typeof extensible !== "boolean") {
        throw new $TypeError("Assertion failed: extensible must be a Boolean");
      }
      if (!isPropertyDescriptor(Desc)) {
        throw new $TypeError("Assertion failed: Desc must be a Property Descriptor");
      }
      if (typeof current !== "undefined" && !isPropertyDescriptor(current)) {
        throw new $TypeError("Assertion failed: current must be a Property Descriptor, or undefined");
      }
      if (typeof current === "undefined") {
        if (!extensible) {
          return false;
        }
        if (oType === "Undefined") {
          return true;
        }
        if (IsAccessorDescriptor(Desc)) {
          return DefineOwnProperty(
            IsDataDescriptor,
            SameValue,
            FromPropertyDescriptor,
            O,
            P,
            Desc
          );
        }
        return DefineOwnProperty(
          IsDataDescriptor,
          SameValue,
          FromPropertyDescriptor,
          O,
          P,
          {
            "[[Configurable]]": !!Desc["[[Configurable]]"],
            "[[Enumerable]]": !!Desc["[[Enumerable]]"],
            "[[Value]]": Desc["[[Value]]"],
            "[[Writable]]": !!Desc["[[Writable]]"]
          }
        );
      }
      if (!isFullyPopulatedPropertyDescriptor(
        {
          IsAccessorDescriptor,
          IsDataDescriptor
        },
        current
      )) {
        throw new $TypeError("`current`, when present, must be a fully populated and valid Property Descriptor");
      }
      if (!current["[[Configurable]]"]) {
        if ("[[Configurable]]" in Desc && Desc["[[Configurable]]"]) {
          return false;
        }
        if ("[[Enumerable]]" in Desc && !SameValue(Desc["[[Enumerable]]"], current["[[Enumerable]]"])) {
          return false;
        }
        if (!IsGenericDescriptor(Desc) && !SameValue(IsAccessorDescriptor(Desc), IsAccessorDescriptor(current))) {
          return false;
        }
        if (IsAccessorDescriptor(current)) {
          if ("[[Get]]" in Desc && !SameValue(Desc["[[Get]]"], current["[[Get]]"])) {
            return false;
          }
          if ("[[Set]]" in Desc && !SameValue(Desc["[[Set]]"], current["[[Set]]"])) {
            return false;
          }
        } else if (!current["[[Writable]]"]) {
          if ("[[Writable]]" in Desc && Desc["[[Writable]]"]) {
            return false;
          }
          if ("[[Value]]" in Desc && !SameValue(Desc["[[Value]]"], current["[[Value]]"])) {
            return false;
          }
        }
      }
      if (oType !== "Undefined") {
        var configurable;
        var enumerable;
        if (IsDataDescriptor(current) && IsAccessorDescriptor(Desc)) {
          configurable = ("[[Configurable]]" in Desc ? Desc : current)["[[Configurable]]"];
          enumerable = ("[[Enumerable]]" in Desc ? Desc : current)["[[Enumerable]]"];
          return DefineOwnProperty(
            IsDataDescriptor,
            SameValue,
            FromPropertyDescriptor,
            O,
            P,
            {
              "[[Configurable]]": !!configurable,
              "[[Enumerable]]": !!enumerable,
              "[[Get]]": ("[[Get]]" in Desc ? Desc : current)["[[Get]]"],
              "[[Set]]": ("[[Set]]" in Desc ? Desc : current)["[[Set]]"]
            }
          );
        } else if (IsAccessorDescriptor(current) && IsDataDescriptor(Desc)) {
          configurable = ("[[Configurable]]" in Desc ? Desc : current)["[[Configurable]]"];
          enumerable = ("[[Enumerable]]" in Desc ? Desc : current)["[[Enumerable]]"];
          return DefineOwnProperty(
            IsDataDescriptor,
            SameValue,
            FromPropertyDescriptor,
            O,
            P,
            {
              "[[Configurable]]": !!configurable,
              "[[Enumerable]]": !!enumerable,
              "[[Value]]": ("[[Value]]" in Desc ? Desc : current)["[[Value]]"],
              "[[Writable]]": !!("[[Writable]]" in Desc ? Desc : current)["[[Writable]]"]
            }
          );
        }
        return DefineOwnProperty(
          IsDataDescriptor,
          SameValue,
          FromPropertyDescriptor,
          O,
          P,
          Desc
        );
      }
      return true;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/OrdinaryDefineOwnProperty.js
var require_OrdinaryDefineOwnProperty = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/OrdinaryDefineOwnProperty.js"(exports, module) {
    "use strict";
    var $gOPD = require_gopd();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var isPropertyDescriptor = require_property_descriptor();
    var IsAccessorDescriptor = require_IsAccessorDescriptor();
    var IsExtensible = require_IsExtensible();
    var IsPropertyKey = require_IsPropertyKey();
    var ToPropertyDescriptor = require_ToPropertyDescriptor();
    var SameValue = require_SameValue();
    var Type = require_Type2();
    var ValidateAndApplyPropertyDescriptor = require_ValidateAndApplyPropertyDescriptor();
    module.exports = function OrdinaryDefineOwnProperty(O, P, Desc) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: O must be an Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: P must be a Property Key");
      }
      if (!isPropertyDescriptor(Desc)) {
        throw new $TypeError("Assertion failed: Desc must be a Property Descriptor");
      }
      if (!$gOPD) {
        if (IsAccessorDescriptor(Desc)) {
          throw new $SyntaxError("This environment does not support accessor property descriptors.");
        }
        var creatingNormalDataProperty = !(P in O) && Desc["[[Writable]]"] && Desc["[[Enumerable]]"] && Desc["[[Configurable]]"] && "[[Value]]" in Desc;
        var settingExistingDataProperty = P in O && (!("[[Configurable]]" in Desc) || Desc["[[Configurable]]"]) && (!("[[Enumerable]]" in Desc) || Desc["[[Enumerable]]"]) && (!("[[Writable]]" in Desc) || Desc["[[Writable]]"]) && "[[Value]]" in Desc;
        if (creatingNormalDataProperty || settingExistingDataProperty) {
          O[P] = Desc["[[Value]]"];
          return SameValue(O[P], Desc["[[Value]]"]);
        }
        throw new $SyntaxError("This environment does not support defining non-writable, non-enumerable, or non-configurable properties");
      }
      var desc = $gOPD(O, P);
      var current = desc && ToPropertyDescriptor(desc);
      var extensible = IsExtensible(O);
      return ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/CreateDataProperty.js
var require_CreateDataProperty = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/CreateDataProperty.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var IsPropertyKey = require_IsPropertyKey();
    var OrdinaryDefineOwnProperty = require_OrdinaryDefineOwnProperty();
    var Type = require_Type2();
    module.exports = function CreateDataProperty(O, P, V) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var newDesc = {
        "[[Configurable]]": true,
        "[[Enumerable]]": true,
        "[[Value]]": V,
        "[[Writable]]": true
      };
      return OrdinaryDefineOwnProperty(O, P, newDesc);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/CreateDataPropertyOrThrow.js
var require_CreateDataPropertyOrThrow = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/CreateDataPropertyOrThrow.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var CreateDataProperty = require_CreateDataProperty();
    var IsPropertyKey = require_IsPropertyKey();
    var Type = require_Type2();
    module.exports = function CreateDataPropertyOrThrow(O, P, V) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var success = CreateDataProperty(O, P, V);
      if (!success) {
        throw new $TypeError("unable to create data property");
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-object-atoms@1.0.0/node_modules/es-object-atoms/RequireObjectCoercible.js
var require_RequireObjectCoercible = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-object-atoms@1.0.0/node_modules/es-object-atoms/RequireObjectCoercible.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    module.exports = function RequireObjectCoercible(value) {
      if (value == null) {
        throw new $TypeError(arguments.length > 0 && arguments[1] || "Cannot call method on " + value);
      }
      return value;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-to-primitive@1.2.1/node_modules/es-to-primitive/helpers/isPrimitive.js
var require_isPrimitive2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-to-primitive@1.2.1/node_modules/es-to-primitive/helpers/isPrimitive.js"(exports, module) {
    "use strict";
    module.exports = function isPrimitive(value) {
      return value === null || typeof value !== "function" && typeof value !== "object";
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-date-object@1.0.5/node_modules/is-date-object/index.js
var require_is_date_object = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-date-object@1.0.5/node_modules/is-date-object/index.js"(exports, module) {
    "use strict";
    var getDay = Date.prototype.getDay;
    var tryDateObject = function tryDateGetDayCall(value) {
      try {
        getDay.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var dateClass = "[object Date]";
    var hasToStringTag = require_shams2()();
    module.exports = function isDateObject(value) {
      if (typeof value !== "object" || value === null) {
        return false;
      }
      return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-symbol@1.0.4/node_modules/is-symbol/index.js
var require_is_symbol = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-symbol@1.0.4/node_modules/is-symbol/index.js"(exports, module) {
    "use strict";
    var toStr = Object.prototype.toString;
    var hasSymbols = require_has_symbols()();
    if (hasSymbols) {
      symToStr = Symbol.prototype.toString;
      symStringRegex = /^Symbol\(.*\)$/;
      isSymbolObject = function isRealSymbolObject(value) {
        if (typeof value.valueOf() !== "symbol") {
          return false;
        }
        return symStringRegex.test(symToStr.call(value));
      };
      module.exports = function isSymbol(value) {
        if (typeof value === "symbol") {
          return true;
        }
        if (toStr.call(value) !== "[object Symbol]") {
          return false;
        }
        try {
          return isSymbolObject(value);
        } catch (e) {
          return false;
        }
      };
    } else {
      module.exports = function isSymbol(value) {
        return false;
      };
    }
    var symToStr;
    var symStringRegex;
    var isSymbolObject;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-to-primitive@1.2.1/node_modules/es-to-primitive/es2015.js
var require_es2015 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-to-primitive@1.2.1/node_modules/es-to-primitive/es2015.js"(exports, module) {
    "use strict";
    var hasSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "symbol";
    var isPrimitive = require_isPrimitive2();
    var isCallable = require_is_callable();
    var isDate = require_is_date_object();
    var isSymbol = require_is_symbol();
    var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
      if (typeof O === "undefined" || O === null) {
        throw new TypeError("Cannot call method on " + O);
      }
      if (typeof hint !== "string" || hint !== "number" && hint !== "string") {
        throw new TypeError('hint must be "string" or "number"');
      }
      var methodNames = hint === "string" ? ["toString", "valueOf"] : ["valueOf", "toString"];
      var method, result, i;
      for (i = 0; i < methodNames.length; ++i) {
        method = O[methodNames[i]];
        if (isCallable(method)) {
          result = method.call(O);
          if (isPrimitive(result)) {
            return result;
          }
        }
      }
      throw new TypeError("No default value");
    };
    var GetMethod = function GetMethod2(O, P) {
      var func = O[P];
      if (func !== null && typeof func !== "undefined") {
        if (!isCallable(func)) {
          throw new TypeError(func + " returned for property " + P + " of object " + O + " is not a function");
        }
        return func;
      }
      return void 0;
    };
    module.exports = function ToPrimitive(input) {
      if (isPrimitive(input)) {
        return input;
      }
      var hint = "default";
      if (arguments.length > 1) {
        if (arguments[1] === String) {
          hint = "string";
        } else if (arguments[1] === Number) {
          hint = "number";
        }
      }
      var exoticToPrim;
      if (hasSymbols) {
        if (Symbol.toPrimitive) {
          exoticToPrim = GetMethod(input, Symbol.toPrimitive);
        } else if (isSymbol(input)) {
          exoticToPrim = Symbol.prototype.valueOf;
        }
      }
      if (typeof exoticToPrim !== "undefined") {
        var result = exoticToPrim.call(input, hint);
        if (isPrimitive(result)) {
          return result;
        }
        throw new TypeError("unable to convert exotic object to primitive");
      }
      if (hint === "default" && (isDate(input) || isSymbol(input))) {
        hint = "string";
      }
      return ordinaryToPrimitive(input, hint === "default" ? "number" : hint);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/ToPrimitive.js
var require_ToPrimitive = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/ToPrimitive.js"(exports, module) {
    "use strict";
    var toPrimitive = require_es2015();
    module.exports = function ToPrimitive(input) {
      if (arguments.length > 1) {
        return toPrimitive(input, arguments[1]);
      }
      return toPrimitive(input);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/ToString.js
var require_ToString = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/ToString.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $String = GetIntrinsic("%String%");
    var $TypeError = require_type();
    module.exports = function ToString(argument) {
      if (typeof argument === "symbol") {
        throw new $TypeError("Cannot convert a Symbol value to a string");
      }
      return $String(argument);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/ToPropertyKey.js
var require_ToPropertyKey = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/ToPropertyKey.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $String = GetIntrinsic("%String%");
    var ToPrimitive = require_ToPrimitive();
    var ToString = require_ToString();
    module.exports = function ToPropertyKey(argument) {
      var key = ToPrimitive(argument, $String);
      return typeof key === "symbol" ? key : ToString(key);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.fromentries@2.0.8/node_modules/object.fromentries/implementation.js
var require_implementation3 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.fromentries@2.0.8/node_modules/object.fromentries/implementation.js"(exports, module) {
    "use strict";
    var AddEntriesFromIterable = require_AddEntriesFromIterable();
    var CreateDataPropertyOrThrow = require_CreateDataPropertyOrThrow();
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var ToPropertyKey = require_ToPropertyKey();
    var adder = function addDataProperty(key, value) {
      var O = this;
      var propertyKey = ToPropertyKey(key);
      CreateDataPropertyOrThrow(O, propertyKey, value);
    };
    module.exports = function fromEntries(iterable) {
      RequireObjectCoercible(iterable);
      return AddEntriesFromIterable({}, iterable, adder);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.fromentries@2.0.8/node_modules/object.fromentries/polyfill.js
var require_polyfill = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.fromentries@2.0.8/node_modules/object.fromentries/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation3();
    module.exports = function getPolyfill() {
      return typeof Object.fromEntries === "function" ? Object.fromEntries : implementation;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.fromentries@2.0.8/node_modules/object.fromentries/shim.js
var require_shim = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.fromentries@2.0.8/node_modules/object.fromentries/shim.js"(exports, module) {
    "use strict";
    var getPolyfill = require_polyfill();
    var define = require_define_properties();
    module.exports = function shimEntries() {
      var polyfill = getPolyfill();
      define(Object, { fromEntries: polyfill }, {
        fromEntries: function testEntries() {
          return Object.fromEntries !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.fromentries@2.0.8/node_modules/object.fromentries/index.js
var require_object = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.fromentries@2.0.8/node_modules/object.fromentries/index.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation3();
    var getPolyfill = require_polyfill();
    var shim = require_shim();
    var polyfill = callBind(getPolyfill(), Object);
    define(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = polyfill;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.entries@1.1.8/node_modules/object.entries/implementation.js
var require_implementation4 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.entries@1.1.8/node_modules/object.entries/implementation.js"(exports, module) {
    "use strict";
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var callBound = require_callBound();
    var $isEnumerable = callBound("Object.prototype.propertyIsEnumerable");
    var $push = callBound("Array.prototype.push");
    module.exports = function entries(O) {
      var obj = RequireObjectCoercible(O);
      var entrys = [];
      for (var key in obj) {
        if ($isEnumerable(obj, key)) {
          $push(entrys, [key, obj[key]]);
        }
      }
      return entrys;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.entries@1.1.8/node_modules/object.entries/polyfill.js
var require_polyfill2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.entries@1.1.8/node_modules/object.entries/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation4();
    module.exports = function getPolyfill() {
      return typeof Object.entries === "function" ? Object.entries : implementation;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.entries@1.1.8/node_modules/object.entries/shim.js
var require_shim2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.entries@1.1.8/node_modules/object.entries/shim.js"(exports, module) {
    "use strict";
    var getPolyfill = require_polyfill2();
    var define = require_define_properties();
    module.exports = function shimEntries() {
      var polyfill = getPolyfill();
      define(Object, { entries: polyfill }, {
        entries: function testEntries() {
          return Object.entries !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.entries@1.1.8/node_modules/object.entries/index.js
var require_object2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.entries@1.1.8/node_modules/object.entries/index.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation4();
    var getPolyfill = require_polyfill2();
    var shim = require_shim2();
    var polyfill = callBind(getPolyfill(), Object);
    define(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = polyfill;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/ArrayCreate.js
var require_ArrayCreate = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/ArrayCreate.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $ArrayPrototype = GetIntrinsic("%Array.prototype%");
    var $RangeError = require_range();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var isInteger = require_isInteger();
    var MAX_ARRAY_LENGTH = Math.pow(2, 32) - 1;
    var hasProto = require_has_proto()();
    var $setProto = GetIntrinsic("%Object.setPrototypeOf%", true) || (hasProto ? function(O, proto) {
      O.__proto__ = proto;
      return O;
    } : null);
    module.exports = function ArrayCreate(length) {
      if (!isInteger(length) || length < 0) {
        throw new $TypeError("Assertion failed: `length` must be an integer Number >= 0");
      }
      if (length > MAX_ARRAY_LENGTH) {
        throw new $RangeError("length is greater than (2**32 - 1)");
      }
      var proto = arguments.length > 1 ? arguments[1] : $ArrayPrototype;
      var A = [];
      if (proto !== $ArrayPrototype) {
        if (!$setProto) {
          throw new $SyntaxError("ArrayCreate: a `proto` argument that is not `Array.prototype` is not supported in an environment that does not support setting the [[Prototype]]");
        }
        $setProto(A, proto);
      }
      if (length !== 0) {
        A.length = length;
      }
      return A;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/IsPropertyKey.js
var require_IsPropertyKey2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/IsPropertyKey.js"(exports, module) {
    "use strict";
    module.exports = function IsPropertyKey(argument) {
      return typeof argument === "string" || typeof argument === "symbol";
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/Type.js
var require_Type3 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/Type.js"(exports, module) {
    "use strict";
    var ES5Type = require_Type();
    module.exports = function Type(x) {
      if (typeof x === "symbol") {
        return "Symbol";
      }
      if (typeof x === "bigint") {
        return "BigInt";
      }
      return ES5Type(x);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/Get.js
var require_Get2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/Get.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var inspect = require_object_inspect();
    var IsPropertyKey = require_IsPropertyKey2();
    var Type = require_Type3();
    module.exports = function Get(O, P) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true, got " + inspect(P));
      }
      return O[P];
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/IsArray.js
var require_IsArray3 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/IsArray.js"(exports, module) {
    "use strict";
    module.exports = require_IsArray();
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/GetIntrinsic.js
var require_GetIntrinsic = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/GetIntrinsic.js"(exports, module) {
    "use strict";
    module.exports = require_get_intrinsic();
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/FromPropertyDescriptor.js
var require_FromPropertyDescriptor2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/FromPropertyDescriptor.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var isPropertyDescriptor = require_property_descriptor();
    var fromPropertyDescriptor = require_fromPropertyDescriptor();
    module.exports = function FromPropertyDescriptor(Desc) {
      if (typeof Desc !== "undefined" && !isPropertyDescriptor(Desc)) {
        throw new $TypeError("Assertion failed: `Desc` must be a Property Descriptor");
      }
      return fromPropertyDescriptor(Desc);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/IsDataDescriptor.js
var require_IsDataDescriptor2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/IsDataDescriptor.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var hasOwn = require_hasown();
    var isPropertyDescriptor = require_property_descriptor();
    module.exports = function IsDataDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return false;
      }
      if (!isPropertyDescriptor(Desc)) {
        throw new $TypeError("Assertion failed: `Desc` must be a Property Descriptor");
      }
      if (!hasOwn(Desc, "[[Value]]") && !hasOwn(Desc, "[[Writable]]")) {
        return false;
      }
      return true;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/SameValue.js
var require_SameValue2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/SameValue.js"(exports, module) {
    "use strict";
    var $isNaN = require_isNaN();
    module.exports = function SameValue(x, y) {
      if (x === y) {
        if (x === 0) {
          return 1 / x === 1 / y;
        }
        return true;
      }
      return $isNaN(x) && $isNaN(y);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/ToBoolean.js
var require_ToBoolean2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/ToBoolean.js"(exports, module) {
    "use strict";
    module.exports = function ToBoolean(value) {
      return !!value;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/IsCallable.js
var require_IsCallable2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/IsCallable.js"(exports, module) {
    "use strict";
    module.exports = require_is_callable();
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/ToPropertyDescriptor.js
var require_ToPropertyDescriptor2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/ToPropertyDescriptor.js"(exports, module) {
    "use strict";
    var hasOwn = require_hasown();
    var $TypeError = require_type();
    var Type = require_Type3();
    var ToBoolean = require_ToBoolean2();
    var IsCallable = require_IsCallable2();
    module.exports = function ToPropertyDescriptor(Obj) {
      if (Type(Obj) !== "Object") {
        throw new $TypeError("ToPropertyDescriptor requires an object");
      }
      var desc = {};
      if (hasOwn(Obj, "enumerable")) {
        desc["[[Enumerable]]"] = ToBoolean(Obj.enumerable);
      }
      if (hasOwn(Obj, "configurable")) {
        desc["[[Configurable]]"] = ToBoolean(Obj.configurable);
      }
      if (hasOwn(Obj, "value")) {
        desc["[[Value]]"] = Obj.value;
      }
      if (hasOwn(Obj, "writable")) {
        desc["[[Writable]]"] = ToBoolean(Obj.writable);
      }
      if (hasOwn(Obj, "get")) {
        var getter = Obj.get;
        if (typeof getter !== "undefined" && !IsCallable(getter)) {
          throw new $TypeError("getter must be a function");
        }
        desc["[[Get]]"] = getter;
      }
      if (hasOwn(Obj, "set")) {
        var setter = Obj.set;
        if (typeof setter !== "undefined" && !IsCallable(setter)) {
          throw new $TypeError("setter must be a function");
        }
        desc["[[Set]]"] = setter;
      }
      if ((hasOwn(desc, "[[Get]]") || hasOwn(desc, "[[Set]]")) && (hasOwn(desc, "[[Value]]") || hasOwn(desc, "[[Writable]]"))) {
        throw new $TypeError("Invalid property descriptor. Cannot both specify accessors and a value or writable attribute");
      }
      return desc;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/DefinePropertyOrThrow.js
var require_DefinePropertyOrThrow = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/DefinePropertyOrThrow.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var isPropertyDescriptor = require_property_descriptor();
    var DefineOwnProperty = require_DefineOwnProperty();
    var FromPropertyDescriptor = require_FromPropertyDescriptor2();
    var IsDataDescriptor = require_IsDataDescriptor2();
    var IsPropertyKey = require_IsPropertyKey2();
    var SameValue = require_SameValue2();
    var ToPropertyDescriptor = require_ToPropertyDescriptor2();
    var Type = require_Type3();
    module.exports = function DefinePropertyOrThrow(O, P, desc) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var Desc = isPropertyDescriptor(desc) ? desc : ToPropertyDescriptor(desc);
      if (!isPropertyDescriptor(Desc)) {
        throw new $TypeError("Assertion failed: Desc is not a valid Property Descriptor");
      }
      return DefineOwnProperty(
        IsDataDescriptor,
        SameValue,
        FromPropertyDescriptor,
        O,
        P,
        Desc
      );
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/IsConstructor.js
var require_IsConstructor = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/IsConstructor.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic();
    var $construct = GetIntrinsic("%Reflect.construct%", true);
    var DefinePropertyOrThrow = require_DefinePropertyOrThrow();
    try {
      DefinePropertyOrThrow({}, "", { "[[Get]]": function() {
      } });
    } catch (e) {
      DefinePropertyOrThrow = null;
    }
    if (DefinePropertyOrThrow && $construct) {
      isConstructorMarker = {};
      badArrayLike = {};
      DefinePropertyOrThrow(badArrayLike, "length", {
        "[[Get]]": function() {
          throw isConstructorMarker;
        },
        "[[Enumerable]]": true
      });
      module.exports = function IsConstructor(argument) {
        try {
          $construct(argument, badArrayLike);
        } catch (err) {
          return err === isConstructorMarker;
        }
      };
    } else {
      module.exports = function IsConstructor(argument) {
        return typeof argument === "function" && !!argument.prototype;
      };
    }
    var isConstructorMarker;
    var badArrayLike;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/ArraySpeciesCreate.js
var require_ArraySpeciesCreate = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/ArraySpeciesCreate.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $species = GetIntrinsic("%Symbol.species%", true);
    var $TypeError = require_type();
    var ArrayCreate = require_ArrayCreate();
    var Get = require_Get2();
    var IsArray = require_IsArray3();
    var IsConstructor = require_IsConstructor();
    var Type = require_Type3();
    var isInteger = require_isInteger();
    module.exports = function ArraySpeciesCreate(originalArray, length) {
      if (!isInteger(length) || length < 0) {
        throw new $TypeError("Assertion failed: length must be an integer >= 0");
      }
      var isArray = IsArray(originalArray);
      if (!isArray) {
        return ArrayCreate(length);
      }
      var C = Get(originalArray, "constructor");
      if ($species && Type(C) === "Object") {
        C = Get(C, $species);
        if (C === null) {
          C = void 0;
        }
      }
      if (typeof C === "undefined") {
        return ArrayCreate(length);
      }
      if (!IsConstructor(C)) {
        throw new $TypeError("C must be a constructor");
      }
      return new C(length);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/Call.js
var require_Call2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/Call.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var $TypeError = require_type();
    var IsArray = require_IsArray3();
    var $apply = GetIntrinsic("%Reflect.apply%", true) || callBound("Function.prototype.apply");
    module.exports = function Call(F, V) {
      var argumentsList = arguments.length > 2 ? arguments[2] : [];
      if (!IsArray(argumentsList)) {
        throw new $TypeError("Assertion failed: optional `argumentsList`, if provided, must be a List");
      }
      return $apply(F, V, argumentsList);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/IsAccessorDescriptor.js
var require_IsAccessorDescriptor2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/IsAccessorDescriptor.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var hasOwn = require_hasown();
    var isPropertyDescriptor = require_property_descriptor();
    module.exports = function IsAccessorDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return false;
      }
      if (!isPropertyDescriptor(Desc)) {
        throw new $TypeError("Assertion failed: `Desc` must be a Property Descriptor");
      }
      if (!hasOwn(Desc, "[[Get]]") && !hasOwn(Desc, "[[Set]]")) {
        return false;
      }
      return true;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/IsExtensible.js
var require_IsExtensible2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/IsExtensible.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $preventExtensions = GetIntrinsic("%Object.preventExtensions%", true);
    var $isExtensible = GetIntrinsic("%Object.isExtensible%", true);
    var isPrimitive = require_isPrimitive();
    module.exports = $preventExtensions ? function IsExtensible(obj) {
      return !isPrimitive(obj) && $isExtensible(obj);
    } : function IsExtensible(obj) {
      return !isPrimitive(obj);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/IsGenericDescriptor.js
var require_IsGenericDescriptor2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/IsGenericDescriptor.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var IsAccessorDescriptor = require_IsAccessorDescriptor2();
    var IsDataDescriptor = require_IsDataDescriptor2();
    var isPropertyDescriptor = require_property_descriptor();
    module.exports = function IsGenericDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return false;
      }
      if (!isPropertyDescriptor(Desc)) {
        throw new $TypeError("Assertion failed: `Desc` must be a Property Descriptor");
      }
      if (!IsAccessorDescriptor(Desc) && !IsDataDescriptor(Desc)) {
        return true;
      }
      return false;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/ValidateAndApplyPropertyDescriptor.js
var require_ValidateAndApplyPropertyDescriptor2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/ValidateAndApplyPropertyDescriptor.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var DefineOwnProperty = require_DefineOwnProperty();
    var isFullyPopulatedPropertyDescriptor = require_isFullyPopulatedPropertyDescriptor();
    var isPropertyDescriptor = require_property_descriptor();
    var FromPropertyDescriptor = require_FromPropertyDescriptor2();
    var IsAccessorDescriptor = require_IsAccessorDescriptor2();
    var IsDataDescriptor = require_IsDataDescriptor2();
    var IsGenericDescriptor = require_IsGenericDescriptor2();
    var IsPropertyKey = require_IsPropertyKey2();
    var SameValue = require_SameValue2();
    var Type = require_Type3();
    module.exports = function ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current) {
      var oType = Type(O);
      if (oType !== "Undefined" && oType !== "Object") {
        throw new $TypeError("Assertion failed: O must be undefined or an Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: P must be a Property Key");
      }
      if (typeof extensible !== "boolean") {
        throw new $TypeError("Assertion failed: extensible must be a Boolean");
      }
      if (!isPropertyDescriptor(Desc)) {
        throw new $TypeError("Assertion failed: Desc must be a Property Descriptor");
      }
      if (typeof current !== "undefined" && !isPropertyDescriptor(current)) {
        throw new $TypeError("Assertion failed: current must be a Property Descriptor, or undefined");
      }
      if (typeof current === "undefined") {
        if (!extensible) {
          return false;
        }
        if (oType === "Undefined") {
          return true;
        }
        if (IsAccessorDescriptor(Desc)) {
          return DefineOwnProperty(
            IsDataDescriptor,
            SameValue,
            FromPropertyDescriptor,
            O,
            P,
            Desc
          );
        }
        return DefineOwnProperty(
          IsDataDescriptor,
          SameValue,
          FromPropertyDescriptor,
          O,
          P,
          {
            "[[Configurable]]": !!Desc["[[Configurable]]"],
            "[[Enumerable]]": !!Desc["[[Enumerable]]"],
            "[[Value]]": Desc["[[Value]]"],
            "[[Writable]]": !!Desc["[[Writable]]"]
          }
        );
      }
      if (!isFullyPopulatedPropertyDescriptor(
        {
          IsAccessorDescriptor,
          IsDataDescriptor
        },
        current
      )) {
        throw new $TypeError("`current`, when present, must be a fully populated and valid Property Descriptor");
      }
      if (!current["[[Configurable]]"]) {
        if ("[[Configurable]]" in Desc && Desc["[[Configurable]]"]) {
          return false;
        }
        if ("[[Enumerable]]" in Desc && !SameValue(Desc["[[Enumerable]]"], current["[[Enumerable]]"])) {
          return false;
        }
        if (!IsGenericDescriptor(Desc) && !SameValue(IsAccessorDescriptor(Desc), IsAccessorDescriptor(current))) {
          return false;
        }
        if (IsAccessorDescriptor(current)) {
          if ("[[Get]]" in Desc && !SameValue(Desc["[[Get]]"], current["[[Get]]"])) {
            return false;
          }
          if ("[[Set]]" in Desc && !SameValue(Desc["[[Set]]"], current["[[Set]]"])) {
            return false;
          }
        } else if (!current["[[Writable]]"]) {
          if ("[[Writable]]" in Desc && Desc["[[Writable]]"]) {
            return false;
          }
          if ("[[Value]]" in Desc && !SameValue(Desc["[[Value]]"], current["[[Value]]"])) {
            return false;
          }
        }
      }
      if (oType !== "Undefined") {
        var configurable;
        var enumerable;
        if (IsDataDescriptor(current) && IsAccessorDescriptor(Desc)) {
          configurable = ("[[Configurable]]" in Desc ? Desc : current)["[[Configurable]]"];
          enumerable = ("[[Enumerable]]" in Desc ? Desc : current)["[[Enumerable]]"];
          return DefineOwnProperty(
            IsDataDescriptor,
            SameValue,
            FromPropertyDescriptor,
            O,
            P,
            {
              "[[Configurable]]": !!configurable,
              "[[Enumerable]]": !!enumerable,
              "[[Get]]": ("[[Get]]" in Desc ? Desc : current)["[[Get]]"],
              "[[Set]]": ("[[Set]]" in Desc ? Desc : current)["[[Set]]"]
            }
          );
        } else if (IsAccessorDescriptor(current) && IsDataDescriptor(Desc)) {
          configurable = ("[[Configurable]]" in Desc ? Desc : current)["[[Configurable]]"];
          enumerable = ("[[Enumerable]]" in Desc ? Desc : current)["[[Enumerable]]"];
          return DefineOwnProperty(
            IsDataDescriptor,
            SameValue,
            FromPropertyDescriptor,
            O,
            P,
            {
              "[[Configurable]]": !!configurable,
              "[[Enumerable]]": !!enumerable,
              "[[Value]]": ("[[Value]]" in Desc ? Desc : current)["[[Value]]"],
              "[[Writable]]": !!("[[Writable]]" in Desc ? Desc : current)["[[Writable]]"]
            }
          );
        }
        return DefineOwnProperty(
          IsDataDescriptor,
          SameValue,
          FromPropertyDescriptor,
          O,
          P,
          Desc
        );
      }
      return true;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/OrdinaryDefineOwnProperty.js
var require_OrdinaryDefineOwnProperty2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/OrdinaryDefineOwnProperty.js"(exports, module) {
    "use strict";
    var $gOPD = require_gopd();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var isPropertyDescriptor = require_property_descriptor();
    var IsAccessorDescriptor = require_IsAccessorDescriptor2();
    var IsExtensible = require_IsExtensible2();
    var IsPropertyKey = require_IsPropertyKey2();
    var ToPropertyDescriptor = require_ToPropertyDescriptor2();
    var SameValue = require_SameValue2();
    var Type = require_Type3();
    var ValidateAndApplyPropertyDescriptor = require_ValidateAndApplyPropertyDescriptor2();
    module.exports = function OrdinaryDefineOwnProperty(O, P, Desc) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: O must be an Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: P must be a Property Key");
      }
      if (!isPropertyDescriptor(Desc)) {
        throw new $TypeError("Assertion failed: Desc must be a Property Descriptor");
      }
      if (!$gOPD) {
        if (IsAccessorDescriptor(Desc)) {
          throw new $SyntaxError("This environment does not support accessor property descriptors.");
        }
        var creatingNormalDataProperty = !(P in O) && Desc["[[Writable]]"] && Desc["[[Enumerable]]"] && Desc["[[Configurable]]"] && "[[Value]]" in Desc;
        var settingExistingDataProperty = P in O && (!("[[Configurable]]" in Desc) || Desc["[[Configurable]]"]) && (!("[[Enumerable]]" in Desc) || Desc["[[Enumerable]]"]) && (!("[[Writable]]" in Desc) || Desc["[[Writable]]"]) && "[[Value]]" in Desc;
        if (creatingNormalDataProperty || settingExistingDataProperty) {
          O[P] = Desc["[[Value]]"];
          return SameValue(O[P], Desc["[[Value]]"]);
        }
        throw new $SyntaxError("This environment does not support defining non-writable, non-enumerable, or non-configurable properties");
      }
      var desc = $gOPD(O, P);
      var current = desc && ToPropertyDescriptor(desc);
      var extensible = IsExtensible(O);
      return ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/CreateDataProperty.js
var require_CreateDataProperty2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/CreateDataProperty.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var IsPropertyKey = require_IsPropertyKey2();
    var OrdinaryDefineOwnProperty = require_OrdinaryDefineOwnProperty2();
    var Type = require_Type3();
    module.exports = function CreateDataProperty(O, P, V) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var newDesc = {
        "[[Configurable]]": true,
        "[[Enumerable]]": true,
        "[[Value]]": V,
        "[[Writable]]": true
      };
      return OrdinaryDefineOwnProperty(O, P, newDesc);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/CreateDataPropertyOrThrow.js
var require_CreateDataPropertyOrThrow2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/CreateDataPropertyOrThrow.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var CreateDataProperty = require_CreateDataProperty2();
    var IsPropertyKey = require_IsPropertyKey2();
    var Type = require_Type3();
    module.exports = function CreateDataPropertyOrThrow(O, P, V) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var success = CreateDataProperty(O, P, V);
      if (!success) {
        throw new $TypeError("unable to create data property");
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/HasProperty.js
var require_HasProperty = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/HasProperty.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var IsPropertyKey = require_IsPropertyKey2();
    var Type = require_Type3();
    module.exports = function HasProperty(O, P) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: `O` must be an Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: `P` must be a Property Key");
      }
      return P in O;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/ToPrimitive.js
var require_ToPrimitive2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/ToPrimitive.js"(exports, module) {
    "use strict";
    var toPrimitive = require_es2015();
    module.exports = function ToPrimitive(input) {
      if (arguments.length > 1) {
        return toPrimitive(input, arguments[1]);
      }
      return toPrimitive(input);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-regex@1.1.4/node_modules/is-regex/index.js
var require_is_regex = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-regex@1.1.4/node_modules/is-regex/index.js"(exports, module) {
    "use strict";
    var callBound = require_callBound();
    var hasToStringTag = require_shams2()();
    var has;
    var $exec;
    var isRegexMarker;
    var badStringifier;
    if (hasToStringTag) {
      has = callBound("Object.prototype.hasOwnProperty");
      $exec = callBound("RegExp.prototype.exec");
      isRegexMarker = {};
      throwRegexMarker = function() {
        throw isRegexMarker;
      };
      badStringifier = {
        toString: throwRegexMarker,
        valueOf: throwRegexMarker
      };
      if (typeof Symbol.toPrimitive === "symbol") {
        badStringifier[Symbol.toPrimitive] = throwRegexMarker;
      }
    }
    var throwRegexMarker;
    var $toString = callBound("Object.prototype.toString");
    var gOPD = Object.getOwnPropertyDescriptor;
    var regexClass = "[object RegExp]";
    module.exports = hasToStringTag ? function isRegex(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      var descriptor = gOPD(value, "lastIndex");
      var hasLastIndexDataProperty = descriptor && has(descriptor, "value");
      if (!hasLastIndexDataProperty) {
        return false;
      }
      try {
        $exec(value, badStringifier);
      } catch (e) {
        return e === isRegexMarker;
      }
    } : function isRegex(value) {
      if (!value || typeof value !== "object" && typeof value !== "function") {
        return false;
      }
      return $toString(value) === regexClass;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/safe-regex-test@1.0.3/node_modules/safe-regex-test/index.js
var require_safe_regex_test = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/safe-regex-test@1.0.3/node_modules/safe-regex-test/index.js"(exports, module) {
    "use strict";
    var callBound = require_callBound();
    var isRegex = require_is_regex();
    var $exec = callBound("RegExp.prototype.exec");
    var $TypeError = require_type();
    module.exports = function regexTester(regex) {
      if (!isRegex(regex)) {
        throw new $TypeError("`regex` must be a RegExp");
      }
      return function test(s) {
        return $exec(regex, s) !== null;
      };
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/string.prototype.trim@1.2.9/node_modules/string.prototype.trim/implementation.js
var require_implementation5 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/string.prototype.trim@1.2.9/node_modules/string.prototype.trim/implementation.js"(exports, module) {
    "use strict";
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var ToString = require_ToString();
    var callBound = require_callBound();
    var $replace = callBound("String.prototype.replace");
    var mvsIsWS = /^\s$/.test("\u180E");
    var leftWhitespace = mvsIsWS ? /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+/ : /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+/;
    var rightWhitespace = mvsIsWS ? /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+$/ : /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+$/;
    module.exports = function trim() {
      var S = ToString(RequireObjectCoercible(this));
      return $replace($replace(S, leftWhitespace, ""), rightWhitespace, "");
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/string.prototype.trim@1.2.9/node_modules/string.prototype.trim/polyfill.js
var require_polyfill3 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/string.prototype.trim@1.2.9/node_modules/string.prototype.trim/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation5();
    var zeroWidthSpace = "\u200B";
    var mongolianVowelSeparator = "\u180E";
    module.exports = function getPolyfill() {
      if (String.prototype.trim && zeroWidthSpace.trim() === zeroWidthSpace && mongolianVowelSeparator.trim() === mongolianVowelSeparator && ("_" + mongolianVowelSeparator).trim() === "_" + mongolianVowelSeparator && (mongolianVowelSeparator + "_").trim() === mongolianVowelSeparator + "_") {
        return String.prototype.trim;
      }
      return implementation;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/string.prototype.trim@1.2.9/node_modules/string.prototype.trim/shim.js
var require_shim3 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/string.prototype.trim@1.2.9/node_modules/string.prototype.trim/shim.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var getPolyfill = require_polyfill3();
    module.exports = function shimStringTrim() {
      var polyfill = getPolyfill();
      define(String.prototype, { trim: polyfill }, {
        trim: function testTrim() {
          return String.prototype.trim !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/string.prototype.trim@1.2.9/node_modules/string.prototype.trim/index.js
var require_string_prototype = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/string.prototype.trim@1.2.9/node_modules/string.prototype.trim/index.js"(exports, module) {
    "use strict";
    var callBind = require_call_bind();
    var define = require_define_properties();
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var implementation = require_implementation5();
    var getPolyfill = require_polyfill3();
    var shim = require_shim3();
    var bound = callBind(getPolyfill());
    var boundMethod = function trim(receiver) {
      RequireObjectCoercible(receiver);
      return bound(receiver);
    };
    define(boundMethod, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = boundMethod;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/StringToNumber.js
var require_StringToNumber = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/StringToNumber.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $Number = GetIntrinsic("%Number%");
    var $RegExp = GetIntrinsic("%RegExp%");
    var $TypeError = require_type();
    var $parseInteger = GetIntrinsic("%parseInt%");
    var callBound = require_callBound();
    var regexTester = require_safe_regex_test();
    var $strSlice = callBound("String.prototype.slice");
    var isBinary = regexTester(/^0b[01]+$/i);
    var isOctal = regexTester(/^0o[0-7]+$/i);
    var isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);
    var nonWS = ["\x85", "\u200B", "\uFFFE"].join("");
    var nonWSregex = new $RegExp("[" + nonWS + "]", "g");
    var hasNonWS = regexTester(nonWSregex);
    var $trim = require_string_prototype();
    module.exports = function StringToNumber(argument) {
      if (typeof argument !== "string") {
        throw new $TypeError("Assertion failed: `argument` is not a String");
      }
      if (isBinary(argument)) {
        return $Number($parseInteger($strSlice(argument, 2), 2));
      }
      if (isOctal(argument)) {
        return $Number($parseInteger($strSlice(argument, 2), 8));
      }
      if (hasNonWS(argument) || isInvalidHexLiteral(argument)) {
        return NaN;
      }
      var trimmed = $trim(argument);
      if (trimmed !== argument) {
        return StringToNumber(trimmed);
      }
      return $Number(argument);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/ToNumber.js
var require_ToNumber = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/ToNumber.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = require_type();
    var $Number = GetIntrinsic("%Number%");
    var isPrimitive = require_isPrimitive();
    var ToPrimitive = require_ToPrimitive2();
    var StringToNumber = require_StringToNumber();
    module.exports = function ToNumber(argument) {
      var value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
      if (typeof value === "symbol") {
        throw new $TypeError("Cannot convert a Symbol value to a number");
      }
      if (typeof value === "bigint") {
        throw new $TypeError("Conversion from 'BigInt' to 'number' is not allowed.");
      }
      if (typeof value === "string") {
        return StringToNumber(value);
      }
      return $Number(value);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/floor.js
var require_floor = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/floor.js"(exports, module) {
    "use strict";
    var $floor = Math.floor;
    module.exports = function floor(x) {
      if (typeof x === "bigint") {
        return x;
      }
      return $floor(x);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/truncate.js
var require_truncate = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/truncate.js"(exports, module) {
    "use strict";
    var floor = require_floor();
    var $TypeError = require_type();
    module.exports = function truncate(x) {
      if (typeof x !== "number" && typeof x !== "bigint") {
        throw new $TypeError("argument must be a Number or a BigInt");
      }
      var result = x < 0 ? -floor(-x) : floor(x);
      return result === 0 ? 0 : result;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/ToIntegerOrInfinity.js
var require_ToIntegerOrInfinity = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/ToIntegerOrInfinity.js"(exports, module) {
    "use strict";
    var ToNumber = require_ToNumber();
    var truncate = require_truncate();
    var $isNaN = require_isNaN();
    var $isFinite = require_isFinite();
    module.exports = function ToIntegerOrInfinity(value) {
      var number = ToNumber(value);
      if ($isNaN(number) || number === 0) {
        return 0;
      }
      if (!$isFinite(number)) {
        return number;
      }
      return truncate(number);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/ToLength.js
var require_ToLength = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/ToLength.js"(exports, module) {
    "use strict";
    var MAX_SAFE_INTEGER = require_maxSafeInteger();
    var ToIntegerOrInfinity = require_ToIntegerOrInfinity();
    module.exports = function ToLength(argument) {
      var len = ToIntegerOrInfinity(argument);
      if (len <= 0) {
        return 0;
      }
      if (len > MAX_SAFE_INTEGER) {
        return MAX_SAFE_INTEGER;
      }
      return len;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/LengthOfArrayLike.js
var require_LengthOfArrayLike = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/LengthOfArrayLike.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var Get = require_Get2();
    var ToLength = require_ToLength();
    var Type = require_Type3();
    module.exports = function LengthOfArrayLike(obj) {
      if (Type(obj) !== "Object") {
        throw new $TypeError("Assertion failed: `obj` must be an Object");
      }
      return ToLength(Get(obj, "length"));
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/ToString.js
var require_ToString2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/ToString.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $String = GetIntrinsic("%String%");
    var $TypeError = require_type();
    module.exports = function ToString(argument) {
      if (typeof argument === "symbol") {
        throw new $TypeError("Cannot convert a Symbol value to a string");
      }
      return $String(argument);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/FlattenIntoArray.js
var require_FlattenIntoArray = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/FlattenIntoArray.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var MAX_SAFE_INTEGER = require_maxSafeInteger();
    var Call = require_Call2();
    var CreateDataPropertyOrThrow = require_CreateDataPropertyOrThrow2();
    var Get = require_Get2();
    var HasProperty = require_HasProperty();
    var IsArray = require_IsArray3();
    var LengthOfArrayLike = require_LengthOfArrayLike();
    var ToString = require_ToString2();
    module.exports = function FlattenIntoArray(target, source, sourceLen, start, depth) {
      var mapperFunction;
      if (arguments.length > 5) {
        mapperFunction = arguments[5];
      }
      var targetIndex = start;
      var sourceIndex = 0;
      while (sourceIndex < sourceLen) {
        var P = ToString(sourceIndex);
        var exists = HasProperty(source, P);
        if (exists === true) {
          var element = Get(source, P);
          if (typeof mapperFunction !== "undefined") {
            if (arguments.length <= 6) {
              throw new $TypeError("Assertion failed: thisArg is required when mapperFunction is provided");
            }
            element = Call(mapperFunction, arguments[6], [element, sourceIndex, source]);
          }
          var shouldFlatten = false;
          if (depth > 0) {
            shouldFlatten = IsArray(element);
          }
          if (shouldFlatten) {
            var elementLen = LengthOfArrayLike(element);
            targetIndex = FlattenIntoArray(target, element, elementLen, targetIndex, depth - 1);
          } else {
            if (targetIndex >= MAX_SAFE_INTEGER) {
              throw new $TypeError("index too large");
            }
            CreateDataPropertyOrThrow(target, ToString(targetIndex), element);
            targetIndex += 1;
          }
        }
        sourceIndex += 1;
      }
      return targetIndex;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-object-atoms@1.0.0/node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-object-atoms@1.0.0/node_modules/es-object-atoms/index.js"(exports, module) {
    "use strict";
    module.exports = Object;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-object-atoms@1.0.0/node_modules/es-object-atoms/ToObject.js
var require_ToObject = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-object-atoms@1.0.0/node_modules/es-object-atoms/ToObject.js"(exports, module) {
    "use strict";
    var $Object = require_es_object_atoms();
    var RequireObjectCoercible = require_RequireObjectCoercible();
    module.exports = function ToObject(value) {
      RequireObjectCoercible(value);
      return $Object(value);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/ToObject.js
var require_ToObject2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/ToObject.js"(exports, module) {
    "use strict";
    module.exports = require_ToObject();
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.flatmap@1.3.2/node_modules/array.prototype.flatmap/implementation.js
var require_implementation6 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.flatmap@1.3.2/node_modules/array.prototype.flatmap/implementation.js"(exports, module) {
    "use strict";
    var ArraySpeciesCreate = require_ArraySpeciesCreate();
    var FlattenIntoArray = require_FlattenIntoArray();
    var Get = require_Get2();
    var IsCallable = require_IsCallable2();
    var ToLength = require_ToLength();
    var ToObject = require_ToObject2();
    module.exports = function flatMap(mapperFunction) {
      var O = ToObject(this);
      var sourceLen = ToLength(Get(O, "length"));
      if (!IsCallable(mapperFunction)) {
        throw new TypeError("mapperFunction must be a function");
      }
      var T;
      if (arguments.length > 1) {
        T = arguments[1];
      }
      var A = ArraySpeciesCreate(O, 0);
      FlattenIntoArray(A, O, sourceLen, 0, 1, mapperFunction, T);
      return A;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.flatmap@1.3.2/node_modules/array.prototype.flatmap/polyfill.js
var require_polyfill4 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.flatmap@1.3.2/node_modules/array.prototype.flatmap/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation6();
    module.exports = function getPolyfill() {
      return Array.prototype.flatMap || implementation;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-shim-unscopables@1.0.2/node_modules/es-shim-unscopables/index.js
var require_es_shim_unscopables = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-shim-unscopables@1.0.2/node_modules/es-shim-unscopables/index.js"(exports, module) {
    "use strict";
    var hasOwn = require_hasown();
    var hasUnscopables = typeof Symbol === "function" && typeof Symbol.unscopables === "symbol";
    var map = hasUnscopables && Array.prototype[Symbol.unscopables];
    var $TypeError = TypeError;
    module.exports = function shimUnscopables(method) {
      if (typeof method !== "string" || !method) {
        throw new $TypeError("method must be a non-empty string");
      }
      if (!hasOwn(Array.prototype, method)) {
        throw new $TypeError("method must be on Array.prototype");
      }
      if (hasUnscopables) {
        map[method] = true;
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.flatmap@1.3.2/node_modules/array.prototype.flatmap/shim.js
var require_shim4 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.flatmap@1.3.2/node_modules/array.prototype.flatmap/shim.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var shimUnscopables = require_es_shim_unscopables();
    var getPolyfill = require_polyfill4();
    module.exports = function shimFlatMap() {
      var polyfill = getPolyfill();
      define(
        Array.prototype,
        { flatMap: polyfill },
        { flatMap: function() {
          return Array.prototype.flatMap !== polyfill;
        } }
      );
      shimUnscopables("flatMap");
      return polyfill;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.flatmap@1.3.2/node_modules/array.prototype.flatmap/index.js
var require_array_prototype = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.flatmap@1.3.2/node_modules/array.prototype.flatmap/index.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation6();
    var getPolyfill = require_polyfill4();
    var polyfill = getPolyfill();
    var shim = require_shim4();
    var boundFlatMap = callBind(polyfill);
    define(boundFlatMap, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = boundFlatMap;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.values@1.2.0/node_modules/object.values/implementation.js
var require_implementation7 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.values@1.2.0/node_modules/object.values/implementation.js"(exports, module) {
    "use strict";
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var callBound = require_callBound();
    var $isEnumerable = callBound("Object.prototype.propertyIsEnumerable");
    var $push = callBound("Array.prototype.push");
    module.exports = function values(O) {
      var obj = RequireObjectCoercible(O);
      var vals = [];
      for (var key in obj) {
        if ($isEnumerable(obj, key)) {
          $push(vals, obj[key]);
        }
      }
      return vals;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.values@1.2.0/node_modules/object.values/polyfill.js
var require_polyfill5 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.values@1.2.0/node_modules/object.values/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation7();
    module.exports = function getPolyfill() {
      return typeof Object.values === "function" ? Object.values : implementation;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.values@1.2.0/node_modules/object.values/shim.js
var require_shim5 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.values@1.2.0/node_modules/object.values/shim.js"(exports, module) {
    "use strict";
    var getPolyfill = require_polyfill5();
    var define = require_define_properties();
    module.exports = function shimValues() {
      var polyfill = getPolyfill();
      define(Object, { values: polyfill }, {
        values: function testValues() {
          return Object.values !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.values@1.2.0/node_modules/object.values/index.js
var require_object3 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.values@1.2.0/node_modules/object.values/index.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation7();
    var getPolyfill = require_polyfill5();
    var shim = require_shim5();
    var polyfill = callBind(getPolyfill(), Object);
    define(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = polyfill;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/StringToNumber.js
var require_StringToNumber2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/StringToNumber.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $Number = GetIntrinsic("%Number%");
    var $RegExp = GetIntrinsic("%RegExp%");
    var $TypeError = require_type();
    var $parseInteger = GetIntrinsic("%parseInt%");
    var callBound = require_callBound();
    var regexTester = require_safe_regex_test();
    var $strSlice = callBound("String.prototype.slice");
    var isBinary = regexTester(/^0b[01]+$/i);
    var isOctal = regexTester(/^0o[0-7]+$/i);
    var isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);
    var nonWS = ["\x85", "\u200B", "\uFFFE"].join("");
    var nonWSregex = new $RegExp("[" + nonWS + "]", "g");
    var hasNonWS = regexTester(nonWSregex);
    var $trim = require_string_prototype();
    module.exports = function StringToNumber(argument) {
      if (typeof argument !== "string") {
        throw new $TypeError("Assertion failed: `argument` is not a String");
      }
      if (isBinary(argument)) {
        return $Number($parseInteger($strSlice(argument, 2), 2));
      }
      if (isOctal(argument)) {
        return $Number($parseInteger($strSlice(argument, 2), 8));
      }
      if (hasNonWS(argument) || isInvalidHexLiteral(argument)) {
        return NaN;
      }
      var trimmed = $trim(argument);
      if (trimmed !== argument) {
        return StringToNumber(trimmed);
      }
      return $Number(argument);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/ToNumber.js
var require_ToNumber2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/ToNumber.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = require_type();
    var $Number = GetIntrinsic("%Number%");
    var isPrimitive = require_isPrimitive();
    var ToPrimitive = require_ToPrimitive();
    var StringToNumber = require_StringToNumber2();
    module.exports = function ToNumber(argument) {
      var value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
      if (typeof value === "symbol") {
        throw new $TypeError("Cannot convert a Symbol value to a number");
      }
      if (typeof value === "bigint") {
        throw new $TypeError("Conversion from 'BigInt' to 'number' is not allowed.");
      }
      if (typeof value === "string") {
        return StringToNumber(value);
      }
      return $Number(value);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/floor.js
var require_floor2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/floor.js"(exports, module) {
    "use strict";
    var $floor = Math.floor;
    module.exports = function floor(x) {
      if (typeof x === "bigint") {
        return x;
      }
      return $floor(x);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/truncate.js
var require_truncate2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/truncate.js"(exports, module) {
    "use strict";
    var floor = require_floor2();
    var $TypeError = require_type();
    module.exports = function truncate(x) {
      if (typeof x !== "number" && typeof x !== "bigint") {
        throw new $TypeError("argument must be a Number or a BigInt");
      }
      var result = x < 0 ? -floor(-x) : floor(x);
      return result === 0 ? 0 : result;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/ToIntegerOrInfinity.js
var require_ToIntegerOrInfinity2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/ToIntegerOrInfinity.js"(exports, module) {
    "use strict";
    var ToNumber = require_ToNumber2();
    var truncate = require_truncate2();
    var $isNaN = require_isNaN();
    var $isFinite = require_isFinite();
    module.exports = function ToIntegerOrInfinity(value) {
      var number = ToNumber(value);
      if ($isNaN(number) || number === 0) {
        return 0;
      }
      if (!$isFinite(number)) {
        return number;
      }
      return truncate(number);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/ToLength.js
var require_ToLength2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/ToLength.js"(exports, module) {
    "use strict";
    var MAX_SAFE_INTEGER = require_maxSafeInteger();
    var ToIntegerOrInfinity = require_ToIntegerOrInfinity2();
    module.exports = function ToLength(argument) {
      var len = ToIntegerOrInfinity(argument);
      if (len <= 0) {
        return 0;
      }
      if (len > MAX_SAFE_INTEGER) {
        return MAX_SAFE_INTEGER;
      }
      return len;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/SameValueZero.js
var require_SameValueZero = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/SameValueZero.js"(exports, module) {
    "use strict";
    var $isNaN = require_isNaN();
    module.exports = function SameValueZero(x, y) {
      return x === y || $isNaN(x) && $isNaN(y);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array-includes@3.1.8/node_modules/array-includes/implementation.js
var require_implementation8 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array-includes@3.1.8/node_modules/array-includes/implementation.js"(exports, module) {
    "use strict";
    var ToIntegerOrInfinity = require_ToIntegerOrInfinity2();
    var ToLength = require_ToLength2();
    var ToObject = require_ToObject();
    var SameValueZero = require_SameValueZero();
    var $isNaN = require_isNaN();
    var $isFinite = require_isFinite();
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var isString = require_is_string();
    var $charAt = callBound("String.prototype.charAt");
    var $indexOf = GetIntrinsic("%Array.prototype.indexOf%");
    var $max = GetIntrinsic("%Math.max%");
    module.exports = function includes(searchElement) {
      var fromIndex = arguments.length > 1 ? ToIntegerOrInfinity(arguments[1]) : 0;
      if ($indexOf && !$isNaN(searchElement) && $isFinite(fromIndex) && typeof searchElement !== "undefined") {
        return $indexOf.apply(this, arguments) > -1;
      }
      var O = ToObject(this);
      var length = ToLength(O.length);
      if (length === 0) {
        return false;
      }
      var k = fromIndex >= 0 ? fromIndex : $max(0, length + fromIndex);
      while (k < length) {
        if (SameValueZero(searchElement, isString(O) ? $charAt(O, k) : O[k])) {
          return true;
        }
        k += 1;
      }
      return false;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array-includes@3.1.8/node_modules/array-includes/polyfill.js
var require_polyfill6 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array-includes@3.1.8/node_modules/array-includes/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation8();
    module.exports = function getPolyfill() {
      if (Array.prototype.includes && Array(1).includes(void 0)) {
        return Array.prototype.includes;
      }
      return implementation;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array-includes@3.1.8/node_modules/array-includes/shim.js
var require_shim6 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array-includes@3.1.8/node_modules/array-includes/shim.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var getPolyfill = require_polyfill6();
    module.exports = function shimArrayPrototypeIncludes() {
      var polyfill = getPolyfill();
      define(
        Array.prototype,
        { includes: polyfill },
        { includes: function() {
          return Array.prototype.includes !== polyfill;
        } }
      );
      return polyfill;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array-includes@3.1.8/node_modules/array-includes/index.js
var require_array_includes = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array-includes@3.1.8/node_modules/array-includes/index.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var callBind = require_call_bind();
    var callBound = require_callBound();
    var implementation = require_implementation8();
    var getPolyfill = require_polyfill6();
    var polyfill = callBind.apply(getPolyfill());
    var shim = require_shim6();
    var $slice = callBound("Array.prototype.slice");
    var boundShim = function includes(array, searchElement) {
      RequireObjectCoercible(array);
      return polyfill(array, $slice(arguments, 1));
    };
    define(boundShim, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = boundShim;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/aos/GetIteratorDirect.js
var require_GetIteratorDirect = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/aos/GetIteratorDirect.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var Get = require_Get();
    var Type = require_Type2();
    module.exports = function GetIteratorDirect(obj) {
      if (Type(obj) !== "Object") {
        throw new $TypeError("Assertion failed: `obj` must be an Object");
      }
      var nextMethod = Get(obj, "next");
      var iteratorRecord = { "[[Iterator]]": obj, "[[NextMethod]]": nextMethod, "[[Done]]": false };
      return iteratorRecord;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/aos/GetIteratorFlattenable.js
var require_GetIteratorFlattenable = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/aos/GetIteratorFlattenable.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var AdvanceStringIndex = require_AdvanceStringIndex();
    var Call = require_Call();
    var GetIteratorDirect = require_GetIteratorDirect();
    var GetMethod = require_GetMethod();
    var IsArray = require_IsArray2();
    var Type = require_Type2();
    var getIteratorMethod = require_getIteratorMethod();
    module.exports = function GetIteratorFlattenable(obj, stringHandling) {
      if (Type(obj) !== "Object") {
        if (stringHandling === "reject-strings" || typeof obj !== "string") {
          throw new $TypeError("obj must be an Object");
        }
      }
      var method = void 0;
      method = getIteratorMethod(
        {
          AdvanceStringIndex,
          GetMethod,
          IsArray
        },
        obj
      );
      var iterator;
      if (typeof method === "undefined") {
        iterator = obj;
      } else {
        iterator = Call(method, obj);
      }
      if (Type(iterator) !== "Object") {
        throw new $TypeError("iterator must be an Object");
      }
      return GetIteratorDirect(iterator);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/OrdinaryHasInstance.js
var require_OrdinaryHasInstance = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/OrdinaryHasInstance.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var Get = require_Get();
    var IsCallable = require_IsCallable();
    var Type = require_Type2();
    module.exports = function OrdinaryHasInstance(C, O) {
      if (!IsCallable(C)) {
        return false;
      }
      if (Type(O) !== "Object") {
        return false;
      }
      var P = Get(C, "prototype");
      if (Type(P) !== "Object") {
        throw new $TypeError("OrdinaryHasInstance called on an object with an invalid prototype property.");
      }
      return O instanceof C;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/globalthis@1.0.4/node_modules/globalthis/implementation.browser.js
var require_implementation_browser = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/globalthis@1.0.4/node_modules/globalthis/implementation.browser.js"(exports, module) {
    "use strict";
    if (typeof self !== "undefined") {
      module.exports = self;
    } else if (typeof window !== "undefined") {
      module.exports = window;
    } else {
      module.exports = Function("return this")();
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/globalthis@1.0.4/node_modules/globalthis/polyfill.js
var require_polyfill7 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/globalthis@1.0.4/node_modules/globalthis/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation_browser();
    module.exports = function getPolyfill() {
      if (typeof __global$ !== "object" || !__global$ || __global$.Math !== Math || __global$.Array !== Array) {
        return implementation;
      }
      return __global$;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/globalthis@1.0.4/node_modules/globalthis/shim.js
var require_shim7 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/globalthis@1.0.4/node_modules/globalthis/shim.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var gOPD = require_gopd();
    var getPolyfill = require_polyfill7();
    module.exports = function shimGlobal() {
      var polyfill = getPolyfill();
      if (define.supportsDescriptors) {
        var descriptor = gOPD(polyfill, "globalThis");
        if (!descriptor || descriptor.configurable && (descriptor.enumerable || !descriptor.writable || globalThis !== polyfill)) {
          Object.defineProperty(polyfill, "globalThis", {
            configurable: true,
            enumerable: false,
            value: polyfill,
            writable: true
          });
        }
      } else if (typeof globalThis !== "object" || globalThis !== polyfill) {
        polyfill.globalThis = polyfill;
      }
      return polyfill;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/globalthis@1.0.4/node_modules/globalthis/index.js
var require_globalthis = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/globalthis@1.0.4/node_modules/globalthis/index.js"(exports, module) {
    "use strict";
    var defineProperties = require_define_properties();
    var implementation = require_implementation_browser();
    var getPolyfill = require_polyfill7();
    var shim = require_shim7();
    var polyfill = getPolyfill();
    var getGlobal = function() {
      return polyfill;
    };
    defineProperties(getGlobal, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = getGlobal;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-number-object@1.0.7/node_modules/is-number-object/index.js
var require_is_number_object = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-number-object@1.0.7/node_modules/is-number-object/index.js"(exports, module) {
    "use strict";
    var numToStr = Number.prototype.toString;
    var tryNumberObject = function tryNumberObject2(value) {
      try {
        numToStr.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var numClass = "[object Number]";
    var hasToStringTag = require_shams2()();
    module.exports = function isNumberObject(value) {
      if (typeof value === "number") {
        return true;
      }
      if (typeof value !== "object") {
        return false;
      }
      return hasToStringTag ? tryNumberObject(value) : toStr.call(value) === numClass;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-boolean-object@1.1.2/node_modules/is-boolean-object/index.js
var require_is_boolean_object = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-boolean-object@1.1.2/node_modules/is-boolean-object/index.js"(exports, module) {
    "use strict";
    var callBound = require_callBound();
    var $boolToStr = callBound("Boolean.prototype.toString");
    var $toString = callBound("Object.prototype.toString");
    var tryBooleanObject = function booleanBrandCheck(value) {
      try {
        $boolToStr(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var boolClass = "[object Boolean]";
    var hasToStringTag = require_shams2()();
    module.exports = function isBoolean(value) {
      if (typeof value === "boolean") {
        return true;
      }
      if (value === null || typeof value !== "object") {
        return false;
      }
      return hasToStringTag && Symbol.toStringTag in value ? tryBooleanObject(value) : $toString(value) === boolClass;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/has-bigints@1.0.2/node_modules/has-bigints/index.js
var require_has_bigints = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/has-bigints@1.0.2/node_modules/has-bigints/index.js"(exports, module) {
    "use strict";
    var $BigInt = typeof BigInt !== "undefined" && BigInt;
    module.exports = function hasNativeBigInts() {
      return typeof $BigInt === "function" && typeof BigInt === "function" && typeof $BigInt(42) === "bigint" && typeof BigInt(42) === "bigint";
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-bigint@1.0.4/node_modules/is-bigint/index.js
var require_is_bigint = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-bigint@1.0.4/node_modules/is-bigint/index.js"(exports, module) {
    "use strict";
    var hasBigInts = require_has_bigints()();
    if (hasBigInts) {
      bigIntValueOf = BigInt.prototype.valueOf;
      tryBigInt = function tryBigIntObject(value) {
        try {
          bigIntValueOf.call(value);
          return true;
        } catch (e) {
        }
        return false;
      };
      module.exports = function isBigInt(value) {
        if (value === null || typeof value === "undefined" || typeof value === "boolean" || typeof value === "string" || typeof value === "number" || typeof value === "symbol" || typeof value === "function") {
          return false;
        }
        if (typeof value === "bigint") {
          return true;
        }
        return tryBigInt(value);
      };
    } else {
      module.exports = function isBigInt(value) {
        return false;
      };
    }
    var bigIntValueOf;
    var tryBigInt;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/which-boxed-primitive@1.0.2/node_modules/which-boxed-primitive/index.js
var require_which_boxed_primitive = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/which-boxed-primitive@1.0.2/node_modules/which-boxed-primitive/index.js"(exports, module) {
    "use strict";
    var isString = require_is_string();
    var isNumber = require_is_number_object();
    var isBoolean = require_is_boolean_object();
    var isSymbol = require_is_symbol();
    var isBigInt = require_is_bigint();
    module.exports = function whichBoxedPrimitive(value) {
      if (value == null || typeof value !== "object" && typeof value !== "function") {
        return null;
      }
      if (isString(value)) {
        return "String";
      }
      if (isNumber(value)) {
        return "Number";
      }
      if (isBoolean(value)) {
        return "Boolean";
      }
      if (isSymbol(value)) {
        return "Symbol";
      }
      if (isBigInt(value)) {
        return "BigInt";
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-map@2.0.3/node_modules/is-map/index.js
var require_is_map = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-map@2.0.3/node_modules/is-map/index.js"(exports, module) {
    "use strict";
    var $Map = typeof Map === "function" && Map.prototype ? Map : null;
    var $Set = typeof Set === "function" && Set.prototype ? Set : null;
    var exported;
    if (!$Map) {
      exported = function isMap(x) {
        return false;
      };
    }
    var $mapHas = $Map ? Map.prototype.has : null;
    var $setHas = $Set ? Set.prototype.has : null;
    if (!exported && !$mapHas) {
      exported = function isMap(x) {
        return false;
      };
    }
    module.exports = exported || function isMap(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      try {
        $mapHas.call(x);
        if ($setHas) {
          try {
            $setHas.call(x);
          } catch (e) {
            return true;
          }
        }
        return x instanceof $Map;
      } catch (e) {
      }
      return false;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-set@2.0.3/node_modules/is-set/index.js
var require_is_set = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-set@2.0.3/node_modules/is-set/index.js"(exports, module) {
    "use strict";
    var $Map = typeof Map === "function" && Map.prototype ? Map : null;
    var $Set = typeof Set === "function" && Set.prototype ? Set : null;
    var exported;
    if (!$Set) {
      exported = function isSet(x) {
        return false;
      };
    }
    var $mapHas = $Map ? Map.prototype.has : null;
    var $setHas = $Set ? Set.prototype.has : null;
    if (!exported && !$setHas) {
      exported = function isSet(x) {
        return false;
      };
    }
    module.exports = exported || function isSet(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      try {
        $setHas.call(x);
        if ($mapHas) {
          try {
            $mapHas.call(x);
          } catch (e) {
            return true;
          }
        }
        return x instanceof $Set;
      } catch (e) {
      }
      return false;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-weakmap@2.0.2/node_modules/is-weakmap/index.js
var require_is_weakmap = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-weakmap@2.0.2/node_modules/is-weakmap/index.js"(exports, module) {
    "use strict";
    var $WeakMap = typeof WeakMap === "function" && WeakMap.prototype ? WeakMap : null;
    var $WeakSet = typeof WeakSet === "function" && WeakSet.prototype ? WeakSet : null;
    var exported;
    if (!$WeakMap) {
      exported = function isWeakMap(x) {
        return false;
      };
    }
    var $mapHas = $WeakMap ? $WeakMap.prototype.has : null;
    var $setHas = $WeakSet ? $WeakSet.prototype.has : null;
    if (!exported && !$mapHas) {
      exported = function isWeakMap(x) {
        return false;
      };
    }
    module.exports = exported || function isWeakMap(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      try {
        $mapHas.call(x, $mapHas);
        if ($setHas) {
          try {
            $setHas.call(x, $setHas);
          } catch (e) {
            return true;
          }
        }
        return x instanceof $WeakMap;
      } catch (e) {
      }
      return false;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-weakset@2.0.3/node_modules/is-weakset/index.js
var require_is_weakset = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-weakset@2.0.3/node_modules/is-weakset/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var $WeakSet = GetIntrinsic("%WeakSet%", true);
    var $setHas = callBound("WeakSet.prototype.has", true);
    if ($setHas) {
      $mapHas = callBound("WeakMap.prototype.has", true);
      module.exports = function isWeakSet(x) {
        if (!x || typeof x !== "object") {
          return false;
        }
        try {
          $setHas(x, $setHas);
          if ($mapHas) {
            try {
              $mapHas(x, $mapHas);
            } catch (e) {
              return true;
            }
          }
          return x instanceof $WeakSet;
        } catch (e) {
        }
        return false;
      };
    } else {
      module.exports = function isWeakSet(x) {
        return false;
      };
    }
    var $mapHas;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/which-collection@1.0.2/node_modules/which-collection/index.js
var require_which_collection = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/which-collection@1.0.2/node_modules/which-collection/index.js"(exports, module) {
    "use strict";
    var isMap = require_is_map();
    var isSet = require_is_set();
    var isWeakMap = require_is_weakmap();
    var isWeakSet = require_is_weakset();
    module.exports = function whichCollection(value) {
      if (value && typeof value === "object") {
        if (isMap(value)) {
          return "Map";
        }
        if (isSet(value)) {
          return "Set";
        }
        if (isWeakMap(value)) {
          return "WeakMap";
        }
        if (isWeakSet(value)) {
          return "WeakSet";
        }
      }
      return false;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/for-each@0.3.3/node_modules/for-each/index.js
var require_for_each = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/for-each@0.3.3/node_modules/for-each/index.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    var toStr = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var forEachArray = function forEachArray2(array, iterator, receiver) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
          if (receiver == null) {
            iterator(array[i], i, array);
          } else {
            iterator.call(receiver, array[i], i, array);
          }
        }
      }
    };
    var forEachString = function forEachString2(string, iterator, receiver) {
      for (var i = 0, len = string.length; i < len; i++) {
        if (receiver == null) {
          iterator(string.charAt(i), i, string);
        } else {
          iterator.call(receiver, string.charAt(i), i, string);
        }
      }
    };
    var forEachObject = function forEachObject2(object, iterator, receiver) {
      for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
          if (receiver == null) {
            iterator(object[k], k, object);
          } else {
            iterator.call(receiver, object[k], k, object);
          }
        }
      }
    };
    var forEach = function forEach2(list, iterator, thisArg) {
      if (!isCallable(iterator)) {
        throw new TypeError("iterator must be a function");
      }
      var receiver;
      if (arguments.length >= 3) {
        receiver = thisArg;
      }
      if (toStr.call(list) === "[object Array]") {
        forEachArray(list, iterator, receiver);
      } else if (typeof list === "string") {
        forEachString(list, iterator, receiver);
      } else {
        forEachObject(list, iterator, receiver);
      }
    };
    module.exports = forEach;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/possible-typed-array-names@1.0.0/node_modules/possible-typed-array-names/index.js
var require_possible_typed_array_names = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/possible-typed-array-names@1.0.0/node_modules/possible-typed-array-names/index.js"(exports, module) {
    "use strict";
    module.exports = [
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array"
    ];
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/available-typed-arrays@1.0.7/node_modules/available-typed-arrays/index.js
var require_available_typed_arrays = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/available-typed-arrays@1.0.7/node_modules/available-typed-arrays/index.js"(exports, module) {
    "use strict";
    var possibleNames = require_possible_typed_array_names();
    var g = typeof globalThis === "undefined" ? __global$ : globalThis;
    module.exports = function availableTypedArrays() {
      var out = [];
      for (var i = 0; i < possibleNames.length; i++) {
        if (typeof g[possibleNames[i]] === "function") {
          out[out.length] = possibleNames[i];
        }
      }
      return out;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/which-typed-array@1.1.15/node_modules/which-typed-array/index.js
var require_which_typed_array = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/which-typed-array@1.1.15/node_modules/which-typed-array/index.js"(exports, module) {
    "use strict";
    var forEach = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBind = require_call_bind();
    var callBound = require_callBound();
    var gOPD = require_gopd();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g = typeof globalThis === "undefined" ? __global$ : globalThis;
    var typedArrays = availableTypedArrays();
    var $slice = callBound("String.prototype.slice");
    var getPrototypeOf = Object.getPrototypeOf;
    var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
      for (var i = 0; i < array.length; i += 1) {
        if (array[i] === value) {
          return i;
        }
      }
      return -1;
    };
    var cache = { __proto__: null };
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr) {
          var proto = getPrototypeOf(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor) {
            var superProto = getPrototypeOf(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          cache["$" + typedArray] = callBind(descriptor.get);
        }
      });
    } else {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        var fn = arr.slice || arr.set;
        if (fn) {
          cache["$" + typedArray] = callBind(fn);
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var found = false;
      forEach(
        // eslint-disable-next-line no-extra-parens
        /** @type {Record<`\$${TypedArrayName}`, Getter>} */
        /** @type {any} */
        cache,
        /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, typedArray) {
          if (!found) {
            try {
              if ("$" + getter(value) === typedArray) {
                found = $slice(typedArray, 1);
              }
            } catch (e) {
            }
          }
        }
      );
      return found;
    };
    var trySlices = function tryAllSlices(value) {
      var found = false;
      forEach(
        // eslint-disable-next-line no-extra-parens
        /** @type {Record<`\$${TypedArrayName}`, Getter>} */
        /** @type {any} */
        cache,
        /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, name) {
          if (!found) {
            try {
              getter(value);
              found = $slice(name, 1);
            } catch (e) {
            }
          }
        }
      );
      return found;
    };
    module.exports = function whichTypedArray(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag) {
        var tag = $slice($toString(value), 8, -1);
        if ($indexOf(typedArrays, tag) > -1) {
          return tag;
        }
        if (tag !== "Object") {
          return false;
        }
        return trySlices(value);
      }
      if (!gOPD) {
        return null;
      }
      return tryTypedArrays(value);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/isarray@2.0.5/node_modules/isarray/index.js
var require_isarray = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/isarray@2.0.5/node_modules/isarray/index.js"(exports, module) {
    var toString = {}.toString;
    module.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-weakref@1.0.2/node_modules/is-weakref/index.js
var require_is_weakref = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-weakref@1.0.2/node_modules/is-weakref/index.js"(exports, module) {
    "use strict";
    var callBound = require_callBound();
    var $deref = callBound("WeakRef.prototype.deref", true);
    module.exports = typeof WeakRef === "undefined" ? function isWeakRef(value) {
      return false;
    } : function isWeakRef(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      try {
        $deref(value);
        return true;
      } catch (e) {
        return false;
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-finalizationregistry@1.0.2/node_modules/is-finalizationregistry/index.js
var require_is_finalizationregistry = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-finalizationregistry@1.0.2/node_modules/is-finalizationregistry/index.js"(exports, module) {
    "use strict";
    var callBound = require_callBound();
    var $register = callBound("FinalizationRegistry.prototype.register", true);
    module.exports = $register ? function isFinalizationRegistry(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      try {
        $register(value, {});
        return true;
      } catch (e) {
        return false;
      }
    } : function isFinalizationRegistry(value) {
      return false;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/HasOwnProperty.js
var require_HasOwnProperty = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2023/HasOwnProperty.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var hasOwn = require_hasown();
    var IsPropertyKey = require_IsPropertyKey2();
    var Type = require_Type3();
    module.exports = function HasOwnProperty(O, P) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: `O` must be an Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: `P` must be a Property Key");
      }
      return hasOwn(O, P);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/functions-have-names@1.2.3/node_modules/functions-have-names/index.js
var require_functions_have_names = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/functions-have-names@1.2.3/node_modules/functions-have-names/index.js"(exports, module) {
    "use strict";
    var functionsHaveNames = function functionsHaveNames2() {
      return typeof function f() {
      }.name === "string";
    };
    var gOPD = Object.getOwnPropertyDescriptor;
    if (gOPD) {
      try {
        gOPD([], "length");
      } catch (e) {
        gOPD = null;
      }
    }
    functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
      if (!functionsHaveNames() || !gOPD) {
        return false;
      }
      var desc = gOPD(function() {
      }, "name");
      return !!desc && !!desc.configurable;
    };
    var $bind = Function.prototype.bind;
    functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
      return functionsHaveNames() && typeof $bind === "function" && function f() {
      }.bind().name !== "";
    };
    module.exports = functionsHaveNames;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/function.prototype.name@1.1.6/node_modules/function.prototype.name/implementation.js
var require_implementation9 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/function.prototype.name@1.1.6/node_modules/function.prototype.name/implementation.js"(exports, module) {
    "use strict";
    var IsCallable = require_IsCallable2();
    var HasOwnProperty = require_HasOwnProperty();
    var functionsHaveNames = require_functions_have_names()();
    var callBound = require_callBound();
    var $functionToString = callBound("Function.prototype.toString");
    var $stringMatch = callBound("String.prototype.match");
    var toStr = callBound("Object.prototype.toString");
    var classRegex = /^class /;
    var isClass = function isClassConstructor(fn) {
      if (IsCallable(fn)) {
        return false;
      }
      if (typeof fn !== "function") {
        return false;
      }
      try {
        var match = $stringMatch($functionToString(fn), classRegex);
        return !!match;
      } catch (e) {
      }
      return false;
    };
    var regex = /\s*function\s+([^(\s]*)\s*/;
    var isIE68 = !(0 in [,]);
    var objectClass = "[object Object]";
    var ddaClass = "[object HTMLAllCollection]";
    var functionProto = Function.prototype;
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      all = document.all;
      if (toStr(all) === toStr(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr(value);
              return (str === ddaClass || str === objectClass) && value("") == null;
            } catch (e) {
            }
          }
          return false;
        };
      }
    }
    var all;
    module.exports = function getName() {
      if (isDDA(this) || !isClass(this) && !IsCallable(this)) {
        throw new TypeError("Function.prototype.name sham getter called on non-function");
      }
      if (functionsHaveNames && HasOwnProperty(this, "name")) {
        return this.name;
      }
      if (this === functionProto) {
        return "";
      }
      var str = $functionToString(this);
      var match = $stringMatch(str, regex);
      var name = match && match[1];
      return name;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/function.prototype.name@1.1.6/node_modules/function.prototype.name/polyfill.js
var require_polyfill8 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/function.prototype.name@1.1.6/node_modules/function.prototype.name/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation9();
    module.exports = function getPolyfill() {
      return implementation;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/function.prototype.name@1.1.6/node_modules/function.prototype.name/shim.js
var require_shim8 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/function.prototype.name@1.1.6/node_modules/function.prototype.name/shim.js"(exports, module) {
    "use strict";
    var supportsDescriptors = require_define_properties().supportsDescriptors;
    var functionsHaveNames = require_functions_have_names()();
    var getPolyfill = require_polyfill8();
    var defineProperty = Object.defineProperty;
    var TypeErr = TypeError;
    module.exports = function shimName() {
      var polyfill = getPolyfill();
      if (functionsHaveNames) {
        return polyfill;
      }
      if (!supportsDescriptors) {
        throw new TypeErr("Shimming Function.prototype.name support requires ES5 property descriptor support.");
      }
      var functionProto = Function.prototype;
      defineProperty(functionProto, "name", {
        configurable: true,
        enumerable: false,
        get: function() {
          var name = polyfill.call(this);
          if (this !== functionProto) {
            defineProperty(this, "name", {
              configurable: true,
              enumerable: false,
              value: name,
              writable: false
            });
          }
          return name;
        }
      });
      return polyfill;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/function.prototype.name@1.1.6/node_modules/function.prototype.name/index.js
var require_function_prototype = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/function.prototype.name@1.1.6/node_modules/function.prototype.name/index.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation9();
    var getPolyfill = require_polyfill8();
    var shim = require_shim8();
    var bound = callBind(implementation);
    define(bound, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = bound;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-generator-function@1.0.10/node_modules/is-generator-function/index.js
var require_is_generator_function = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-generator-function@1.0.10/node_modules/is-generator-function/index.js"(exports, module) {
    "use strict";
    var toStr = Object.prototype.toString;
    var fnToStr = Function.prototype.toString;
    var isFnRegex = /^\s*(?:function)?\*/;
    var hasToStringTag = require_shams2()();
    var getProto = Object.getPrototypeOf;
    var getGeneratorFunc = function() {
      if (!hasToStringTag) {
        return false;
      }
      try {
        return Function("return function*() {}")();
      } catch (e) {
      }
    };
    var GeneratorFunction;
    module.exports = function isGeneratorFunction(fn) {
      if (typeof fn !== "function") {
        return false;
      }
      if (isFnRegex.test(fnToStr.call(fn))) {
        return true;
      }
      if (!hasToStringTag) {
        var str = toStr.call(fn);
        return str === "[object GeneratorFunction]";
      }
      if (!getProto) {
        return false;
      }
      if (typeof GeneratorFunction === "undefined") {
        var generatorFunc = getGeneratorFunc();
        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
      }
      return getProto(fn) === GeneratorFunction;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-async-function@2.0.0/node_modules/is-async-function/index.js
var require_is_async_function = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-async-function@2.0.0/node_modules/is-async-function/index.js"(exports, module) {
    "use strict";
    var toStr = Object.prototype.toString;
    var fnToStr = Function.prototype.toString;
    var isFnRegex = /^\s*async(?:\s+function(?:\s+|\()|\s*\()/;
    var hasToStringTag = require_shams2()();
    var getProto = Object.getPrototypeOf;
    var getAsyncFunc = function() {
      if (!hasToStringTag) {
        return false;
      }
      try {
        return Function("return async function () {}")();
      } catch (e) {
      }
    };
    var AsyncFunction;
    module.exports = function isAsyncFunction(fn) {
      if (typeof fn !== "function") {
        return false;
      }
      if (isFnRegex.test(fnToStr.call(fn))) {
        return true;
      }
      if (!hasToStringTag) {
        var str = toStr.call(fn);
        return str === "[object AsyncFunction]";
      }
      if (!getProto) {
        return false;
      }
      if (typeof AsyncFunction === "undefined") {
        var asyncFunc = getAsyncFunc();
        AsyncFunction = asyncFunc ? getProto(asyncFunc) : false;
      }
      return getProto(fn) === AsyncFunction;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/which-builtin-type@1.1.3/node_modules/which-builtin-type/index.js
var require_which_builtin_type = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/which-builtin-type@1.1.3/node_modules/which-builtin-type/index.js"(exports, module) {
    "use strict";
    var whichBoxedPrimitive = require_which_boxed_primitive();
    var whichCollection = require_which_collection();
    var whichTypedArray = require_which_typed_array();
    var isArray = require_isarray();
    var isDate = require_is_date_object();
    var isRegex = require_is_regex();
    var isWeakRef = require_is_weakref();
    var isFinalizationRegistry = require_is_finalizationregistry();
    var name = require_function_prototype();
    var isGeneratorFunction = require_is_generator_function();
    var isAsyncFunction = require_is_async_function();
    var hasToStringTag = require_shams2()();
    var toStringTag = hasToStringTag && Symbol.toStringTag;
    var $Object = Object;
    var promiseThen = typeof Promise === "function" && Promise.prototype.then;
    var isPromise = function isPromise2(value) {
      if (!value || typeof value !== "object" || !promiseThen) {
        return false;
      }
      try {
        promiseThen.call(value, null, function() {
        });
        return true;
      } catch (e) {
      }
      return false;
    };
    var isKnownBuiltin = function isKnownBuiltin2(builtinName) {
      return builtinName && builtinName !== "BigInt" && builtinName !== "Boolean" && builtinName !== "Null" && builtinName !== "Number" && builtinName !== "String" && builtinName !== "Symbol" && builtinName !== "Undefined" && builtinName !== "Math" && builtinName !== "JSON" && builtinName !== "Reflect" && builtinName !== "Atomics" && builtinName !== "Map" && builtinName !== "Set" && builtinName !== "WeakMap" && builtinName !== "WeakSet" && builtinName !== "BigInt64Array" && builtinName !== "BigUint64Array" && builtinName !== "Float32Array" && builtinName !== "Float64Array" && builtinName !== "Int16Array" && builtinName !== "Int32Array" && builtinName !== "Int8Array" && builtinName !== "Uint16Array" && builtinName !== "Uint32Array" && builtinName !== "Uint8Array" && builtinName !== "Uint8ClampedArray" && builtinName !== "Array" && builtinName !== "Date" && builtinName !== "FinalizationRegistry" && builtinName !== "Promise" && builtinName !== "RegExp" && builtinName !== "WeakRef" && builtinName !== "Function" && builtinName !== "GeneratorFunction" && builtinName !== "AsyncFunction";
    };
    module.exports = function whichBuiltinType(value) {
      if (value == null) {
        return value;
      }
      var which = whichBoxedPrimitive($Object(value)) || whichCollection(value) || whichTypedArray(value);
      if (which) {
        return which;
      }
      if (isArray(value)) {
        return "Array";
      }
      if (isDate(value)) {
        return "Date";
      }
      if (isRegex(value)) {
        return "RegExp";
      }
      if (isWeakRef(value)) {
        return "WeakRef";
      }
      if (isFinalizationRegistry(value)) {
        return "FinalizationRegistry";
      }
      if (typeof value === "function") {
        if (isGeneratorFunction(value)) {
          return "GeneratorFunction";
        }
        if (isAsyncFunction(value)) {
          return "AsyncFunction";
        }
        return "Function";
      }
      if (isPromise(value)) {
        return "Promise";
      }
      if (toStringTag && toStringTag in value) {
        var tag = value[toStringTag];
        if (isKnownBuiltin(tag)) {
          return tag;
        }
      }
      if (typeof value.constructor === "function") {
        var constructorName = name(value.constructor);
        if (isKnownBuiltin(constructorName)) {
          return constructorName;
        }
      }
      return "Object";
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/reflect.getprototypeof@1.0.6/node_modules/reflect.getprototypeof/implementation.js
var require_implementation10 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/reflect.getprototypeof@1.0.6/node_modules/reflect.getprototypeof/implementation.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var IsCallable = require_IsCallable();
    var Type = require_Type2();
    var whichBuiltinType = require_which_builtin_type();
    var $TypeError = require_type();
    var $gPO = GetIntrinsic("%Object.getPrototypeOf%", true);
    var $ObjectPrototype = GetIntrinsic("%Object.prototype%");
    var hasProto = [].__proto__ === Array.prototype;
    module.exports = function getPrototypeOf(O) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Reflect.getPrototypeOf called on non-object");
      }
      if ($gPO) {
        return $gPO(O);
      }
      if (hasProto) {
        var proto = O.__proto__;
        if (proto || proto === null) {
          return proto;
        }
      }
      var type = whichBuiltinType(O);
      if (type) {
        var intrinsic = GetIntrinsic("%" + type + ".prototype%", true);
        if (intrinsic) {
          return intrinsic;
        }
      }
      if (IsCallable(O.constructor)) {
        return O.constructor.prototype;
      }
      if (O instanceof Object) {
        return $ObjectPrototype;
      }
      return null;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/reflect.getprototypeof@1.0.6/node_modules/reflect.getprototypeof/polyfill.js
var require_polyfill9 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/reflect.getprototypeof@1.0.6/node_modules/reflect.getprototypeof/polyfill.js"(exports, module) {
    "use strict";
    var Type = require_Type2();
    var $TypeError = require_type();
    var implementation = require_implementation10();
    var hasProto = [].__proto__ === Array.prototype;
    var getProto = function getPrototypeOf(value) {
      if (Type(value) !== "Object") {
        throw new $TypeError("Reflect.getPrototypeOf called on non-object");
      }
      return value.__proto__;
    };
    module.exports = function getPolyfill() {
      if (typeof Reflect === "object" && Reflect && Reflect.getPrototypeOf) {
        return Reflect.getPrototypeOf;
      }
      if (hasProto) {
        return getProto;
      }
      return implementation;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/reflect.getprototypeof@1.0.6/node_modules/reflect.getprototypeof/shim.js
var require_shim9 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/reflect.getprototypeof@1.0.6/node_modules/reflect.getprototypeof/shim.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var getPolyfill = require_polyfill9();
    module.exports = function shimGetPrototypeOf() {
      define(
        __global$,
        { Reflect: {} },
        { Reflect: function() {
          return typeof Reflect !== "object" || !Reflect;
        } }
      );
      var polyfill = getPolyfill();
      define(
        Reflect,
        { getPrototypeOf: polyfill },
        { getPrototypeOf: function() {
          return Reflect.getPrototypeOf !== polyfill;
        } }
      );
      return polyfill;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/reflect.getprototypeof@1.0.6/node_modules/reflect.getprototypeof/index.js
var require_reflect = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/reflect.getprototypeof@1.0.6/node_modules/reflect.getprototypeof/index.js"(exports, module) {
    "use strict";
    var callBind = require_call_bind();
    var define = require_define_properties();
    var implementation = require_implementation10();
    var getPolyfill = require_polyfill9();
    var shim = require_shim9();
    var bound = callBind(getPolyfill(), typeof Reflect === "object" ? Reflect : Object);
    define(bound, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = bound;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/set-function-name@2.0.2/node_modules/set-function-name/index.js
var require_set_function_name = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/set-function-name@2.0.2/node_modules/set-function-name/index.js"(exports, module) {
    "use strict";
    var define = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var functionsHaveConfigurableNames = require_functions_have_names().functionsHaveConfigurableNames();
    var $TypeError = require_type();
    module.exports = function setFunctionName(fn, name) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      if (!loose || functionsHaveConfigurableNames) {
        if (hasDescriptors) {
          define(
            /** @type {Parameters<define>[0]} */
            fn,
            "name",
            name,
            true,
            true
          );
        } else {
          define(
            /** @type {Parameters<define>[0]} */
            fn,
            "name",
            name
          );
        }
      }
      return fn;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/iterator.prototype@1.1.2/node_modules/iterator.prototype/index.js
var require_iterator = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/iterator.prototype@1.1.2/node_modules/iterator.prototype/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var gPO = require_reflect();
    var hasSymbols = require_has_symbols();
    var define = require_define_properties();
    var setFunctionName = require_set_function_name();
    var arrayIterProto = GetIntrinsic("%ArrayIteratorPrototype%", true);
    var iterProto = arrayIterProto && gPO(arrayIterProto);
    var result = iterProto || {};
    if (hasSymbols()) {
      defined = {};
      predicates = {};
      trueThunk = function() {
        return true;
      };
      if (!(Symbol.iterator in result)) {
        defined[Symbol.iterator] = setFunctionName(function SymbolIterator() {
          return this;
        }, "[Symbol.iterator]", true);
        predicates[Symbol.iterator] = trueThunk;
      }
      define(result, defined, predicates);
    }
    var defined;
    var predicates;
    var trueThunk;
    module.exports = result;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator/implementation.js
var require_implementation11 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator/implementation.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var hasPropertyDescriptors = require_has_property_descriptors()();
    var $TypeError = require_type();
    var $defineProperty = hasPropertyDescriptors && GetIntrinsic("%Object.defineProperty%", true);
    var iterProto = require_iterator();
    var callBound = require_callBound();
    var $isPrototypeOf = callBound("Object.prototype.isPrototypeOf");
    var $Iterator = typeof Iterator === "function" ? Iterator : function Iterator2() {
      if (!(this instanceof Iterator2) || this.constructor === Iterator2 || !$isPrototypeOf(Iterator2, this.constructor)) {
        throw new $TypeError("`Iterator` can not be called or constructed directly");
      }
    };
    if ($Iterator.prototype !== iterProto) {
      $Iterator.prototype = iterProto;
    }
    $defineProperty($Iterator, "prototype", { writable: false });
    module.exports = $Iterator;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator/polyfill.js
var require_polyfill10 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator/polyfill.js"(exports, module) {
    "use strict";
    var globalThis2 = require_globalthis()();
    var implementation = require_implementation11();
    module.exports = function getPolyfill() {
      return typeof globalThis2.Iterator === "function" ? globalThis2.Iterator : implementation;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype/implementation.js
var require_implementation12 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype/implementation.js"(exports, module) {
    "use strict";
    module.exports = require_iterator();
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/WrapForValidIteratorPrototype/index.js
var require_WrapForValidIteratorPrototype = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/WrapForValidIteratorPrototype/index.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var Call = require_Call();
    var CreateIterResultObject = require_CreateIterResultObject();
    var GetMethod = require_GetMethod();
    var Type = require_Type2();
    var SLOT = require_internal_slot();
    var iterProto = require_implementation12();
    module.exports = /* GetIntrinsic('%WrapForValidIteratorPrototype%', true) || */
    {
      __proto__: iterProto,
      next: function next() {
        var O = this;
        SLOT.assert(O, "[[Iterated]]");
        var iteratorRecord = SLOT.get(O, "[[Iterated]]");
        return Call(iteratorRecord["[[NextMethod]]"], iteratorRecord["[[Iterator]]"]);
      },
      "return": function() {
        var O = this;
        SLOT.assert(O, "[[Iterated]]");
        var iterator = SLOT.get(O, "[[Iterated]]")["[[Iterator]]"];
        if (Type(iterator) !== "Object") {
          throw new $TypeError("iterator must be an Object");
        }
        var returnMethod = GetMethod(iterator, "return");
        if (typeof returnMethod === "undefined") {
          return CreateIterResultObject(void 0, true);
        }
        return Call(returnMethod, iterator);
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.from/implementation.js
var require_implementation13 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.from/implementation.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var GetIteratorFlattenable = require_GetIteratorFlattenable();
    var OrdinaryHasInstance = require_OrdinaryHasInstance();
    var OrdinaryObjectCreate = require_OrdinaryObjectCreate();
    var $Iterator = require_polyfill10()();
    var $WrapForValidIteratorPrototype = require_WrapForValidIteratorPrototype();
    var SLOT = require_internal_slot();
    module.exports = function from(O) {
      if (this instanceof from) {
        throw new $TypeError("`Iterator.from` is not a constructor");
      }
      var iteratorRecord = GetIteratorFlattenable(O, "iterate-strings");
      var hasInstance = OrdinaryHasInstance($Iterator, iteratorRecord["[[Iterator]]"]);
      if (hasInstance) {
        return iteratorRecord["[[Iterator]]"];
      }
      var wrapper = OrdinaryObjectCreate($WrapForValidIteratorPrototype);
      SLOT.set(wrapper, "[[Iterated]]", iteratorRecord);
      return wrapper;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator/shim.js
var require_shim10 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator/shim.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var globalThis2 = require_globalthis()();
    var getPolyfill = require_polyfill10();
    module.exports = function shimIterator() {
      var polyfill = getPolyfill();
      define(
        globalThis2,
        { Iterator: polyfill },
        { Iterator: function() {
          return Iterator !== polyfill;
        } }
      );
      return polyfill;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator/index.js
var require_Iterator = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator/index.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation11();
    var getPolyfill = require_polyfill10();
    var shim = require_shim10();
    var polyfill = callBind(getPolyfill());
    define(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = polyfill;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.from/polyfill.js
var require_polyfill11 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.from/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation13();
    var $Iterator = require_Iterator();
    module.exports = function getPolyfill() {
      return typeof $Iterator.from === "function" ? $Iterator.from : implementation;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.from/shim.js
var require_shim11 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.from/shim.js"(exports, module) {
    "use strict";
    var getPolyfill = require_polyfill11();
    var define = require_define_properties();
    var getIteratorPolyfill = require_polyfill10();
    module.exports = function shimIteratorFrom() {
      var $Iterator = getIteratorPolyfill();
      var polyfill = getPolyfill();
      define(
        $Iterator,
        { from: polyfill },
        { from: function() {
          return $Iterator.from !== polyfill;
        } }
      );
      return polyfill;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.from/index.js
var require_Iterator2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.from/index.js"(exports, module) {
    "use strict";
    var callBind = require_call_bind();
    var define = require_define_properties();
    var implementation = require_implementation13();
    var getPolyfill = require_polyfill11();
    var shim = require_shim11();
    var bound = callBind(getPolyfill(), null);
    define(bound, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = bound;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/aos/GeneratorStart.js
var require_GeneratorStart = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/aos/GeneratorStart.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var CreateIterResultObject = require_CreateIterResultObject();
    var IsCallable = require_IsCallable();
    var Type = require_Type2();
    var SLOT = require_internal_slot();
    module.exports = function GeneratorStart(generator, closure) {
      SLOT.assert(generator, "[[GeneratorState]]");
      SLOT.assert(generator, "[[GeneratorContext]]");
      SLOT.assert(generator, "[[GeneratorBrand]]");
      SLOT.assert(generator, "[[Sentinel]]");
      SLOT.assert(generator, "[[CloseIfAbrupt]]");
      if (!IsCallable(closure) || closure.length !== 0) {
        throw new $TypeError("`closure` must be a function that takes no arguments");
      }
      var sentinel = SLOT.get(closure, "[[Sentinel]]");
      if (Type(sentinel) !== "Object") {
        throw new $TypeError("`closure.[[Sentinel]]` must be an object");
      }
      SLOT.set(generator, "[[GeneratorContext]]", function() {
        try {
          var result = closure();
          if (result === sentinel) {
            SLOT.set(generator, "[[GeneratorState]]", "completed");
            SLOT.set(generator, "[[GeneratorContext]]", null);
            return CreateIterResultObject(void 0, true);
          }
          SLOT.set(generator, "[[GeneratorState]]", "suspendedYield");
          return CreateIterResultObject(result, false);
        } catch (e) {
          SLOT.set(generator, "[[GeneratorState]]", "completed");
          SLOT.set(generator, "[[GeneratorContext]]", null);
          throw e;
        }
      });
      SLOT.set(generator, "[[GeneratorState]]", "suspendedStart");
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/every.js
var require_every = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/every.js"(exports, module) {
    "use strict";
    module.exports = function every(array, predicate) {
      for (var i = 0; i < array.length; i += 1) {
        if (!predicate(array[i], i, array)) {
          return false;
        }
      }
      return true;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/safe-array-concat@1.1.2/node_modules/safe-array-concat/index.js
var require_safe_array_concat = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/safe-array-concat@1.1.2/node_modules/safe-array-concat/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $concat = GetIntrinsic("%Array.prototype.concat%");
    var callBind = require_call_bind();
    var callBound = require_callBound();
    var $slice = callBound("Array.prototype.slice");
    var hasSymbols = require_shams()();
    var isConcatSpreadable = hasSymbols && Symbol.isConcatSpreadable;
    var empty = [];
    var $concatApply = isConcatSpreadable ? callBind.apply($concat, empty) : null;
    var isArray = isConcatSpreadable ? (
      /** @type {(value: unknown) => value is unknown[]} */
      require_isarray()
    ) : null;
    module.exports = isConcatSpreadable ? function safeArrayConcat(item) {
      for (var i = 0; i < arguments.length; i += 1) {
        var arg = arguments[i];
        if (arg && typeof arg === "object" && typeof arg[isConcatSpreadable] === "boolean") {
          if (!empty[isConcatSpreadable]) {
            empty[isConcatSpreadable] = true;
          }
          var arr = isArray(arg) ? $slice(arg) : [arg];
          arr[isConcatSpreadable] = true;
          arguments[i] = arr;
        }
      }
      return $concatApply(arguments);
    } : callBind($concat, empty);
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/aos/CreateIteratorFromClosure.js
var require_CreateIteratorFromClosure = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/aos/CreateIteratorFromClosure.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var GeneratorStart = require_GeneratorStart();
    var IsArray = require_IsArray2();
    var IsCallable = require_IsCallable();
    var OrdinaryObjectCreate = require_OrdinaryObjectCreate();
    var every = require_every();
    var SLOT = require_internal_slot();
    var safeConcat = require_safe_array_concat();
    var isString = function isString2(slot) {
      return typeof slot === "string";
    };
    module.exports = function CreateIteratorFromClosure(closure, generatorBrand, proto) {
      if (!IsCallable(closure)) {
        throw new $TypeError("`closure` must be a function");
      }
      if (typeof generatorBrand !== "string") {
        throw new $TypeError("`generatorBrand` must be a string");
      }
      var extraSlots = arguments.length > 3 ? arguments[3] : [];
      if (arguments.length > 3) {
        if (!IsArray(extraSlots) || !every(extraSlots, isString)) {
          throw new $TypeError("`extraSlots` must be a List of String internal slot names");
        }
      }
      var internalSlotsList = safeConcat(extraSlots, ["[[GeneratorContext]]", "[[GeneratorBrand]]", "[[GeneratorState]]"]);
      var generator = OrdinaryObjectCreate(proto, internalSlotsList);
      SLOT.set(generator, "[[GeneratorBrand]]", generatorBrand);
      SLOT.assert(closure, "[[Sentinel]]");
      SLOT.set(generator, "[[Sentinel]]", SLOT.get(closure, "[[Sentinel]]"));
      SLOT.assert(closure, "[[CloseIfAbrupt]]");
      SLOT.set(generator, "[[CloseIfAbrupt]]", SLOT.get(closure, "[[CloseIfAbrupt]]"));
      GeneratorStart(generator, closure);
      return generator;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IteratorStepValue.js
var require_IteratorStepValue = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IteratorStepValue.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var Get = require_Get();
    var IteratorComplete = require_IteratorComplete();
    var IteratorNext = require_IteratorNext();
    var isIteratorRecord = require_iterator_record();
    module.exports = function IteratorStepValue(iteratorRecord) {
      if (!isIteratorRecord(iteratorRecord)) {
        throw new $TypeError("Assertion failed: `iteratorRecord` must be an Iterator Record");
      }
      var result;
      try {
        result = IteratorNext(iteratorRecord);
      } catch (e) {
        iteratorRecord["[[Done]]"] = true;
        throw e;
      }
      var done;
      try {
        done = IteratorComplete(result);
      } catch (e) {
        iteratorRecord["[[Done]]"] = true;
        throw e;
      }
      if (done) {
        iteratorRecord["[[Done]]"] = true;
        return "DONE";
      }
      var value;
      try {
        value = Get(result, "value");
      } catch (e) {
        iteratorRecord["[[Done]]"] = true;
        throw e;
      }
      return value;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-set-tostringtag@2.0.3/node_modules/es-set-tostringtag/index.js
var require_es_set_tostringtag = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-set-tostringtag@2.0.3/node_modules/es-set-tostringtag/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasToStringTag = require_shams2()();
    var hasOwn = require_hasown();
    var toStringTag = hasToStringTag ? Symbol.toStringTag : null;
    module.exports = function setToStringTag(object, value) {
      var overrideIfSet = arguments.length > 2 && arguments[2] && arguments[2].force;
      if (toStringTag && (overrideIfSet || !hasOwn(object, toStringTag))) {
        if ($defineProperty) {
          $defineProperty(object, toStringTag, {
            configurable: true,
            enumerable: false,
            value,
            writable: false
          });
        } else {
          object[toStringTag] = value;
        }
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/aos/GeneratorValidate.js
var require_GeneratorValidate = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/aos/GeneratorValidate.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var SLOT = require_internal_slot();
    module.exports = function GeneratorValidate(generator, generatorBrand) {
      SLOT.assert(generator, "[[GeneratorState]]");
      SLOT.assert(generator, "[[GeneratorBrand]]");
      var brand = SLOT.get(generator, "[[GeneratorBrand]]");
      if (brand !== generatorBrand) {
        throw new $TypeError("Assertion failed: generator brand is unexpected: " + brand);
      }
      SLOT.assert(generator, "[[GeneratorContext]]");
      var state = SLOT.get(generator, "[[GeneratorState]]");
      if (state === "executing") {
        throw new $TypeError("generator is executing");
      }
      return state;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/aos/GeneratorResume.js
var require_GeneratorResume = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/aos/GeneratorResume.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var CreateIterResultObject = require_CreateIterResultObject();
    var GeneratorValidate = require_GeneratorValidate();
    var SLOT = require_internal_slot();
    module.exports = function GeneratorResume(generator, value, generatorBrand) {
      var state = GeneratorValidate(generator, generatorBrand);
      if (state === "completed") {
        return CreateIterResultObject(void 0, true);
      }
      if (state !== "suspendedStart" && state !== "suspendedYield") {
        throw new $TypeError("Assertion failed: generator state is unexpected: " + state);
      }
      var genContext = SLOT.get(generator, "[[GeneratorContext]]");
      SLOT.set(generator, "[[GeneratorState]]", "executing");
      var result = genContext(value);
      return result;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/NormalCompletion.js
var require_NormalCompletion = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/NormalCompletion.js"(exports, module) {
    "use strict";
    var CompletionRecord = require_CompletionRecord();
    module.exports = function NormalCompletion(value) {
      return new CompletionRecord("normal", value);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/aos/GeneratorResumeAbrupt.js
var require_GeneratorResumeAbrupt = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/aos/GeneratorResumeAbrupt.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var CompletionRecord = require_CompletionRecord();
    var CreateIterResultObject = require_CreateIterResultObject();
    var GeneratorValidate = require_GeneratorValidate();
    var NormalCompletion = require_NormalCompletion();
    var SLOT = require_internal_slot();
    module.exports = function GeneratorResumeAbrupt(generator, abruptCompletion, generatorBrand) {
      if (!(abruptCompletion instanceof CompletionRecord)) {
        throw new $TypeError("Assertion failed: abruptCompletion must be a Completion Record");
      }
      var state = GeneratorValidate(generator, generatorBrand);
      if (state === "suspendedStart") {
        SLOT.set(generator, "[[GeneratorState]]", "completed");
        SLOT.set(generator, "[[GeneratorContext]]", null);
        state = "completed";
      }
      var value = abruptCompletion.value();
      if (state === "completed") {
        return CreateIterResultObject(value, true);
      }
      if (state !== "suspendedYield") {
        throw new $TypeError("Assertion failed: generator state is unexpected: " + state);
      }
      if (abruptCompletion.type() === "return") {
        return CreateIterResultObject(SLOT.get(generator, "[[CloseIfAbrupt]]")(NormalCompletion(abruptCompletion.value())), true);
      }
      var genContext = SLOT.get(generator, "[[GeneratorContext]]");
      SLOT.set(generator, "[[GeneratorState]]", "executing");
      var result = genContext(value);
      return result;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/IteratorHelperPrototype/index.js
var require_IteratorHelperPrototype = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/IteratorHelperPrototype/index.js"(exports, module) {
    "use strict";
    var setToStringTag = require_es_set_tostringtag();
    var hasProto = require_has_proto()();
    var iterProto = require_implementation12();
    var SLOT = require_internal_slot();
    var CompletionRecord = require_CompletionRecord();
    var CreateIterResultObject = require_CreateIterResultObject();
    var GeneratorResume = require_GeneratorResume();
    var GeneratorResumeAbrupt = require_GeneratorResumeAbrupt();
    var IteratorClose = require_IteratorClose();
    var NormalCompletion = require_NormalCompletion();
    var implementation;
    if (hasProto) {
      implementation = {
        __proto__: iterProto,
        next: function next() {
          return GeneratorResume(this, void 0, "Iterator Helper");
        },
        "return": function() {
          var O = this;
          SLOT.assert(O, "[[UnderlyingIterator]]");
          SLOT.assert(O, "[[GeneratorState]]");
          if (SLOT.get(O, "[[GeneratorState]]") === "suspendedStart") {
            SLOT.set(O, "[[GeneratorState]]", "completed");
            IteratorClose(SLOT.get(O, "[[UnderlyingIterator]]"), NormalCompletion("unused"));
            return CreateIterResultObject(void 0, true);
          }
          var C = new CompletionRecord("return", void 0);
          return GeneratorResumeAbrupt(O, C, "Iterator Helper");
        }
      };
      setToStringTag(implementation, "Iterator Helper");
    } else {
      IteratorHelper = function IteratorHelper2() {
      };
      IteratorHelper.prototype = iterProto;
      implementation = new IteratorHelper();
      delete implementation.constructor;
      implementation.next = function next() {
        return GeneratorResume(this, void 0, "Iterator Helper");
      };
      implementation["return"] = function() {
        var C = new CompletionRecord("return", void 0);
        return GeneratorResumeAbrupt(this, C, "Iterator Helper");
      };
    }
    var IteratorHelper;
    module.exports = implementation;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.map/implementation.js
var require_implementation14 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.map/implementation.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var Call = require_Call();
    var CompletionRecord = require_CompletionRecord();
    var CreateIteratorFromClosure = require_CreateIteratorFromClosure();
    var GetIteratorDirect = require_GetIteratorDirect();
    var IsCallable = require_IsCallable();
    var IteratorClose = require_IteratorClose();
    var IteratorStepValue = require_IteratorStepValue();
    var ThrowCompletion = require_ThrowCompletion();
    var Type = require_Type2();
    var iterHelperProto = require_IteratorHelperPrototype();
    var SLOT = require_internal_slot();
    module.exports = function map(mapper) {
      if (this instanceof map) {
        throw new $TypeError("`map` is not a constructor");
      }
      var O = this;
      if (Type(O) !== "Object") {
        throw new $TypeError("`this` value must be an Object");
      }
      if (!IsCallable(mapper)) {
        throw new $TypeError("`mapper` must be a function");
      }
      var iterated = GetIteratorDirect(O);
      var closeIfAbrupt = function(abruptCompletion) {
        if (!(abruptCompletion instanceof CompletionRecord)) {
          throw new $TypeError("`abruptCompletion` must be a Completion Record");
        }
        IteratorClose(
          iterated,
          abruptCompletion
        );
      };
      var sentinel = {};
      var counter = 0;
      var closure = function() {
        var value = IteratorStepValue(iterated);
        if (iterated["[[Done]]"]) {
          return sentinel;
        }
        var mapped;
        try {
          mapped = Call(mapper, void 0, [value, counter]);
          return mapped;
        } catch (e) {
          closeIfAbrupt(ThrowCompletion(e));
          throw e;
        } finally {
          counter += 1;
        }
      };
      SLOT.set(closure, "[[Sentinel]]", sentinel);
      SLOT.set(closure, "[[CloseIfAbrupt]]", closeIfAbrupt);
      var result = CreateIteratorFromClosure(closure, "Iterator Helper", iterHelperProto, ["[[UnderlyingIterator]]"]);
      SLOT.set(result, "[[UnderlyingIterator]]", iterated);
      return result;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.map/polyfill.js
var require_polyfill12 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.map/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation14();
    module.exports = function getPolyfill() {
      if (typeof Iterator === "function" && typeof Iterator.prototype.map === "function") {
        try {
          Iterator.prototype.map.call({ next: null }, function() {
          }).next();
        } catch (e) {
          return Iterator.prototype.map;
        }
      }
      return implementation;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.map/shim.js
var require_shim12 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.map/shim.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var getPolyfill = require_polyfill12();
    var $IteratorPrototype = require_implementation12();
    module.exports = function shimIteratorPrototypeMap() {
      var polyfill = getPolyfill();
      define(
        $IteratorPrototype,
        { map: polyfill },
        { map: function() {
          return $IteratorPrototype.map !== polyfill;
        } }
      );
      return polyfill;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.map/index.js
var require_Iterator_prototype = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.map/index.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation14();
    var getPolyfill = require_polyfill12();
    var shim = require_shim12();
    var polyfill = callBind(getPolyfill());
    define(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = polyfill;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.toreversed@1.1.2/node_modules/array.prototype.toreversed/implementation.js
var require_implementation15 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.toreversed@1.1.2/node_modules/array.prototype.toreversed/implementation.js"(exports, module) {
    "use strict";
    var ArrayCreate = require_ArrayCreate();
    var CreateDataPropertyOrThrow = require_CreateDataPropertyOrThrow2();
    var Get = require_Get2();
    var LengthOfArrayLike = require_LengthOfArrayLike();
    var ToObject = require_ToObject2();
    var ToString = require_ToString2();
    module.exports = function toReversed() {
      var O = ToObject(this);
      var len = LengthOfArrayLike(O);
      var A = ArrayCreate(len);
      var k = 0;
      while (k < len) {
        var from = ToString(len - k - 1);
        var Pk = ToString(k);
        var fromValue = Get(O, from);
        CreateDataPropertyOrThrow(A, Pk, fromValue);
        k += 1;
      }
      return A;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.toreversed@1.1.2/node_modules/array.prototype.toreversed/polyfill.js
var require_polyfill13 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.toreversed@1.1.2/node_modules/array.prototype.toreversed/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation15();
    module.exports = function getPolyfill() {
      return Array.prototype.toReversed || implementation;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.toreversed@1.1.2/node_modules/array.prototype.toreversed/shim.js
var require_shim13 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.toreversed@1.1.2/node_modules/array.prototype.toreversed/shim.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var shimUnscopables = require_es_shim_unscopables();
    var getPolyfill = require_polyfill13();
    module.exports = function shim() {
      var polyfill = getPolyfill();
      define(
        Array.prototype,
        { toReversed: polyfill },
        { toReversed: function() {
          return Array.prototype.toReversed !== polyfill;
        } }
      );
      shimUnscopables("toReversed");
      return polyfill;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.toreversed@1.1.2/node_modules/array.prototype.toreversed/index.js
var require_array_prototype2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.toreversed@1.1.2/node_modules/array.prototype.toreversed/index.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation15();
    var getPolyfill = require_polyfill13();
    var polyfill = getPolyfill();
    var shim = require_shim13();
    var bound = callBind(polyfill);
    define(bound, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = bound;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/eslint.js
var require_eslint = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/eslint.js"(exports, module) {
    "use strict";
    function getSourceCode(context) {
      return context.getSourceCode ? context.getSourceCode() : context.sourceCode;
    }
    function getAncestors(context, node) {
      const sourceCode = getSourceCode(context);
      return sourceCode.getAncestors ? sourceCode.getAncestors(node) : context.getAncestors();
    }
    function getScope(context, node) {
      const sourceCode = getSourceCode(context);
      if (sourceCode.getScope) {
        return sourceCode.getScope(node);
      }
      return context.getScope();
    }
    function markVariableAsUsed(name, node, context) {
      const sourceCode = getSourceCode(context);
      return sourceCode.markVariableAsUsed ? sourceCode.markVariableAsUsed(name, node) : context.markVariableAsUsed(name);
    }
    function getFirstTokens(context, node, count) {
      const sourceCode = getSourceCode(context);
      return sourceCode.getFirstTokens ? sourceCode.getFirstTokens(node, count) : context.getFirstTokens(node, count);
    }
    function getText(context) {
      const sourceCode = getSourceCode(context);
      const args = Array.prototype.slice.call(arguments, 1);
      return sourceCode.getText ? sourceCode.getText.apply(sourceCode, args) : context.getSource.apply(context, args);
    }
    module.exports = {
      getAncestors,
      getFirstTokens,
      getScope,
      getSourceCode,
      getText,
      markVariableAsUsed
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/variable.js
var require_variable = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/variable.js"(exports, module) {
    "use strict";
    var toReversed = require_array_prototype2();
    var getScope = require_eslint().getScope;
    function findVariable(variables, name) {
      return variables.some((variable) => variable.name === name);
    }
    function getVariable(variables, name) {
      return variables.find((variable) => variable.name === name);
    }
    function variablesInScope(context, node) {
      let scope = getScope(context, node);
      let variables = scope.variables;
      while (scope.type !== "global") {
        scope = scope.upper;
        variables = scope.variables.concat(variables);
      }
      if (scope.childScopes.length) {
        variables = scope.childScopes[0].variables.concat(variables);
        if (scope.childScopes[0].childScopes.length) {
          variables = scope.childScopes[0].childScopes[0].variables.concat(variables);
        }
      }
      return toReversed(variables);
    }
    function findVariableByName(context, node, name) {
      const variable = getVariable(variablesInScope(context, node), name);
      if (!variable || !variable.defs[0] || !variable.defs[0].node) {
        return null;
      }
      if (variable.defs[0].node.type === "TypeAlias") {
        return variable.defs[0].node.right;
      }
      if (variable.defs[0].type === "ImportBinding") {
        return variable.defs[0].node;
      }
      return variable.defs[0].node.init;
    }
    function getLatestVariableDefinition(variable) {
      return variable.defs[variable.defs.length - 1];
    }
    module.exports = {
      findVariable,
      findVariableByName,
      getVariable,
      variablesInScope,
      getLatestVariableDefinition
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/pragma.js
var require_pragma = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/pragma.js"(exports, module) {
    "use strict";
    var getSourceCode = require_eslint().getSourceCode;
    var JSX_ANNOTATION_REGEX = /@jsx\s+([^\s]+)/;
    var JS_IDENTIFIER_REGEX = /^[_$a-zA-Z][_$a-zA-Z0-9]*$/;
    function getCreateClassFromContext(context) {
      let pragma = "createReactClass";
      if (context.settings.react && context.settings.react.createClass) {
        pragma = context.settings.react.createClass;
      }
      if (!JS_IDENTIFIER_REGEX.test(pragma)) {
        throw new Error(`createClass pragma ${pragma} is not a valid function name`);
      }
      return pragma;
    }
    function getFragmentFromContext(context) {
      let pragma = "Fragment";
      if (context.settings.react && context.settings.react.fragment) {
        pragma = context.settings.react.fragment;
      }
      if (!JS_IDENTIFIER_REGEX.test(pragma)) {
        throw new Error(`Fragment pragma ${pragma} is not a valid identifier`);
      }
      return pragma;
    }
    function getFromContext(context) {
      let pragma = "React";
      const sourceCode = getSourceCode(context);
      const pragmaNode = sourceCode.getAllComments().find((node) => JSX_ANNOTATION_REGEX.test(node.value));
      if (pragmaNode) {
        const matches = JSX_ANNOTATION_REGEX.exec(pragmaNode.value);
        pragma = matches[1].split(".")[0];
      } else if (context.settings.react && context.settings.react.pragma) {
        pragma = context.settings.react.pragma;
      }
      if (!JS_IDENTIFIER_REGEX.test(pragma)) {
        throw new Error(`React pragma ${pragma} is not a valid identifier`);
      }
      return pragma;
    }
    module.exports = {
      getCreateClassFromContext,
      getFragmentFromContext,
      getFromContext
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/estraverse@5.3.0/node_modules/estraverse/estraverse.js
var require_estraverse = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/estraverse@5.3.0/node_modules/estraverse/estraverse.js"(exports) {
    (function clone(exports2) {
      "use strict";
      var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE;
      function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            val = obj[key];
            if (typeof val === "object" && val !== null) {
              ret[key] = deepCopy(val);
            } else {
              ret[key] = val;
            }
          }
        }
        return ret;
      }
      function upperBound(array, func) {
        var diff, len, i, current;
        len = array.length;
        i = 0;
        while (len) {
          diff = len >>> 1;
          current = i + diff;
          if (func(array[current])) {
            len = diff;
          } else {
            i = current + 1;
            len -= diff + 1;
          }
        }
        return i;
      }
      Syntax = {
        AssignmentExpression: "AssignmentExpression",
        AssignmentPattern: "AssignmentPattern",
        ArrayExpression: "ArrayExpression",
        ArrayPattern: "ArrayPattern",
        ArrowFunctionExpression: "ArrowFunctionExpression",
        AwaitExpression: "AwaitExpression",
        // CAUTION: It's deferred to ES7.
        BlockStatement: "BlockStatement",
        BinaryExpression: "BinaryExpression",
        BreakStatement: "BreakStatement",
        CallExpression: "CallExpression",
        CatchClause: "CatchClause",
        ChainExpression: "ChainExpression",
        ClassBody: "ClassBody",
        ClassDeclaration: "ClassDeclaration",
        ClassExpression: "ClassExpression",
        ComprehensionBlock: "ComprehensionBlock",
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: "ComprehensionExpression",
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: "ConditionalExpression",
        ContinueStatement: "ContinueStatement",
        DebuggerStatement: "DebuggerStatement",
        DirectiveStatement: "DirectiveStatement",
        DoWhileStatement: "DoWhileStatement",
        EmptyStatement: "EmptyStatement",
        ExportAllDeclaration: "ExportAllDeclaration",
        ExportDefaultDeclaration: "ExportDefaultDeclaration",
        ExportNamedDeclaration: "ExportNamedDeclaration",
        ExportSpecifier: "ExportSpecifier",
        ExpressionStatement: "ExpressionStatement",
        ForStatement: "ForStatement",
        ForInStatement: "ForInStatement",
        ForOfStatement: "ForOfStatement",
        FunctionDeclaration: "FunctionDeclaration",
        FunctionExpression: "FunctionExpression",
        GeneratorExpression: "GeneratorExpression",
        // CAUTION: It's deferred to ES7.
        Identifier: "Identifier",
        IfStatement: "IfStatement",
        ImportExpression: "ImportExpression",
        ImportDeclaration: "ImportDeclaration",
        ImportDefaultSpecifier: "ImportDefaultSpecifier",
        ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
        ImportSpecifier: "ImportSpecifier",
        Literal: "Literal",
        LabeledStatement: "LabeledStatement",
        LogicalExpression: "LogicalExpression",
        MemberExpression: "MemberExpression",
        MetaProperty: "MetaProperty",
        MethodDefinition: "MethodDefinition",
        ModuleSpecifier: "ModuleSpecifier",
        NewExpression: "NewExpression",
        ObjectExpression: "ObjectExpression",
        ObjectPattern: "ObjectPattern",
        PrivateIdentifier: "PrivateIdentifier",
        Program: "Program",
        Property: "Property",
        PropertyDefinition: "PropertyDefinition",
        RestElement: "RestElement",
        ReturnStatement: "ReturnStatement",
        SequenceExpression: "SequenceExpression",
        SpreadElement: "SpreadElement",
        Super: "Super",
        SwitchStatement: "SwitchStatement",
        SwitchCase: "SwitchCase",
        TaggedTemplateExpression: "TaggedTemplateExpression",
        TemplateElement: "TemplateElement",
        TemplateLiteral: "TemplateLiteral",
        ThisExpression: "ThisExpression",
        ThrowStatement: "ThrowStatement",
        TryStatement: "TryStatement",
        UnaryExpression: "UnaryExpression",
        UpdateExpression: "UpdateExpression",
        VariableDeclaration: "VariableDeclaration",
        VariableDeclarator: "VariableDeclarator",
        WhileStatement: "WhileStatement",
        WithStatement: "WithStatement",
        YieldExpression: "YieldExpression"
      };
      VisitorKeys = {
        AssignmentExpression: ["left", "right"],
        AssignmentPattern: ["left", "right"],
        ArrayExpression: ["elements"],
        ArrayPattern: ["elements"],
        ArrowFunctionExpression: ["params", "body"],
        AwaitExpression: ["argument"],
        // CAUTION: It's deferred to ES7.
        BlockStatement: ["body"],
        BinaryExpression: ["left", "right"],
        BreakStatement: ["label"],
        CallExpression: ["callee", "arguments"],
        CatchClause: ["param", "body"],
        ChainExpression: ["expression"],
        ClassBody: ["body"],
        ClassDeclaration: ["id", "superClass", "body"],
        ClassExpression: ["id", "superClass", "body"],
        ComprehensionBlock: ["left", "right"],
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: ["test", "consequent", "alternate"],
        ContinueStatement: ["label"],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ["body", "test"],
        EmptyStatement: [],
        ExportAllDeclaration: ["source"],
        ExportDefaultDeclaration: ["declaration"],
        ExportNamedDeclaration: ["declaration", "specifiers", "source"],
        ExportSpecifier: ["exported", "local"],
        ExpressionStatement: ["expression"],
        ForStatement: ["init", "test", "update", "body"],
        ForInStatement: ["left", "right", "body"],
        ForOfStatement: ["left", "right", "body"],
        FunctionDeclaration: ["id", "params", "body"],
        FunctionExpression: ["id", "params", "body"],
        GeneratorExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ["test", "consequent", "alternate"],
        ImportExpression: ["source"],
        ImportDeclaration: ["specifiers", "source"],
        ImportDefaultSpecifier: ["local"],
        ImportNamespaceSpecifier: ["local"],
        ImportSpecifier: ["imported", "local"],
        Literal: [],
        LabeledStatement: ["label", "body"],
        LogicalExpression: ["left", "right"],
        MemberExpression: ["object", "property"],
        MetaProperty: ["meta", "property"],
        MethodDefinition: ["key", "value"],
        ModuleSpecifier: [],
        NewExpression: ["callee", "arguments"],
        ObjectExpression: ["properties"],
        ObjectPattern: ["properties"],
        PrivateIdentifier: [],
        Program: ["body"],
        Property: ["key", "value"],
        PropertyDefinition: ["key", "value"],
        RestElement: ["argument"],
        ReturnStatement: ["argument"],
        SequenceExpression: ["expressions"],
        SpreadElement: ["argument"],
        Super: [],
        SwitchStatement: ["discriminant", "cases"],
        SwitchCase: ["test", "consequent"],
        TaggedTemplateExpression: ["tag", "quasi"],
        TemplateElement: [],
        TemplateLiteral: ["quasis", "expressions"],
        ThisExpression: [],
        ThrowStatement: ["argument"],
        TryStatement: ["block", "handler", "finalizer"],
        UnaryExpression: ["argument"],
        UpdateExpression: ["argument"],
        VariableDeclaration: ["declarations"],
        VariableDeclarator: ["id", "init"],
        WhileStatement: ["test", "body"],
        WithStatement: ["object", "body"],
        YieldExpression: ["argument"]
      };
      BREAK = {};
      SKIP = {};
      REMOVE = {};
      VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE
      };
      function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
      }
      Reference.prototype.replace = function replace2(node) {
        this.parent[this.key] = node;
      };
      Reference.prototype.remove = function remove() {
        if (Array.isArray(this.parent)) {
          this.parent.splice(this.key, 1);
          return true;
        } else {
          this.replace(null);
          return false;
        }
      };
      function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
      }
      function Controller() {
      }
      Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;
        function addToPath(result2, path2) {
          if (Array.isArray(path2)) {
            for (j = 0, jz = path2.length; j < jz; ++j) {
              result2.push(path2[j]);
            }
          } else {
            result2.push(path2);
          }
        }
        if (!this.__current.path) {
          return null;
        }
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
          element = this.__leavelist[i];
          addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
      };
      Controller.prototype.type = function() {
        var node = this.current();
        return node.type || this.__current.wrap;
      };
      Controller.prototype.parents = function parents() {
        var i, iz, result;
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
          result.push(this.__leavelist[i].node);
        }
        return result;
      };
      Controller.prototype.current = function current() {
        return this.__current.node;
      };
      Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;
        result = void 0;
        previous = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
          result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;
        return result;
      };
      Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
      };
      Controller.prototype.skip = function() {
        this.notify(SKIP);
      };
      Controller.prototype["break"] = function() {
        this.notify(BREAK);
      };
      Controller.prototype.remove = function() {
        this.notify(REMOVE);
      };
      Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
        this.__fallback = null;
        if (visitor.fallback === "iteration") {
          this.__fallback = Object.keys;
        } else if (typeof visitor.fallback === "function") {
          this.__fallback = visitor.fallback;
        }
        this.__keys = VisitorKeys;
        if (visitor.keys) {
          this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
        }
      };
      function isNode(node) {
        if (node == null) {
          return false;
        }
        return typeof node === "object" && typeof node.type === "string";
      }
      function isProperty(nodeType, key) {
        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && "properties" === key;
      }
      function candidateExistsInLeaveList(leavelist, candidate) {
        for (var i = leavelist.length - 1; i >= 0; --i) {
          if (leavelist[i].node === candidate) {
            return true;
          }
        }
        return false;
      }
      Controller.prototype.traverse = function traverse2(root, visitor) {
        var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));
        while (worklist.length) {
          element = worklist.pop();
          if (element === sentinel) {
            element = leavelist.pop();
            ret = this.__execute(visitor.leave, element);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            continue;
          }
          if (element.node) {
            ret = this.__execute(visitor.enter, element);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            worklist.push(sentinel);
            leavelist.push(element);
            if (this.__state === SKIP || ret === SKIP) {
              continue;
            }
            node = element.node;
            nodeType = node.type || element.wrap;
            candidates = this.__keys[nodeType];
            if (!candidates) {
              if (this.__fallback) {
                candidates = this.__fallback(node);
              } else {
                throw new Error("Unknown node type " + nodeType + ".");
              }
            }
            current = candidates.length;
            while ((current -= 1) >= 0) {
              key = candidates[current];
              candidate = node[key];
              if (!candidate) {
                continue;
              }
              if (Array.isArray(candidate)) {
                current2 = candidate.length;
                while ((current2 -= 1) >= 0) {
                  if (!candidate[current2]) {
                    continue;
                  }
                  if (candidateExistsInLeaveList(leavelist, candidate[current2])) {
                    continue;
                  }
                  if (isProperty(nodeType, candidates[current])) {
                    element = new Element(candidate[current2], [key, current2], "Property", null);
                  } else if (isNode(candidate[current2])) {
                    element = new Element(candidate[current2], [key, current2], null, null);
                  } else {
                    continue;
                  }
                  worklist.push(element);
                }
              } else if (isNode(candidate)) {
                if (candidateExistsInLeaveList(leavelist, candidate)) {
                  continue;
                }
                worklist.push(new Element(candidate, key, null, null));
              }
            }
          }
        }
      };
      Controller.prototype.replace = function replace2(root, visitor) {
        var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;
        function removeElem(element2) {
          var i, key2, nextElem, parent;
          if (element2.ref.remove()) {
            key2 = element2.ref.key;
            parent = element2.ref.parent;
            i = worklist.length;
            while (i--) {
              nextElem = worklist[i];
              if (nextElem.ref && nextElem.ref.parent === parent) {
                if (nextElem.ref.key < key2) {
                  break;
                }
                --nextElem.ref.key;
              }
            }
          }
        }
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        outer = {
          root
        };
        element = new Element(root, null, null, new Reference(outer, "root"));
        worklist.push(element);
        leavelist.push(element);
        while (worklist.length) {
          element = worklist.pop();
          if (element === sentinel) {
            element = leavelist.pop();
            target = this.__execute(visitor.leave, element);
            if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE) {
              element.ref.replace(target);
            }
            if (this.__state === REMOVE || target === REMOVE) {
              removeElem(element);
            }
            if (this.__state === BREAK || target === BREAK) {
              return outer.root;
            }
            continue;
          }
          target = this.__execute(visitor.enter, element);
          if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE) {
            element.ref.replace(target);
            element.node = target;
          }
          if (this.__state === REMOVE || target === REMOVE) {
            removeElem(element);
            element.node = null;
          }
          if (this.__state === BREAK || target === BREAK) {
            return outer.root;
          }
          node = element.node;
          if (!node) {
            continue;
          }
          worklist.push(sentinel);
          leavelist.push(element);
          if (this.__state === SKIP || target === SKIP) {
            continue;
          }
          nodeType = node.type || element.wrap;
          candidates = this.__keys[nodeType];
          if (!candidates) {
            if (this.__fallback) {
              candidates = this.__fallback(node);
            } else {
              throw new Error("Unknown node type " + nodeType + ".");
            }
          }
          current = candidates.length;
          while ((current -= 1) >= 0) {
            key = candidates[current];
            candidate = node[key];
            if (!candidate) {
              continue;
            }
            if (Array.isArray(candidate)) {
              current2 = candidate.length;
              while ((current2 -= 1) >= 0) {
                if (!candidate[current2]) {
                  continue;
                }
                if (isProperty(nodeType, candidates[current])) {
                  element = new Element(candidate[current2], [key, current2], "Property", new Reference(candidate, current2));
                } else if (isNode(candidate[current2])) {
                  element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                } else {
                  continue;
                }
                worklist.push(element);
              }
            } else if (isNode(candidate)) {
              worklist.push(new Element(candidate, key, null, new Reference(node, key)));
            }
          }
        }
        return outer.root;
      };
      function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
      }
      function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
      }
      function extendCommentRange(comment, tokens) {
        var target;
        target = upperBound(tokens, function search(token) {
          return token.range[0] > comment.range[0];
        });
        comment.extendedRange = [comment.range[0], comment.range[1]];
        if (target !== tokens.length) {
          comment.extendedRange[1] = tokens[target].range[0];
        }
        target -= 1;
        if (target >= 0) {
          comment.extendedRange[0] = tokens[target].range[1];
        }
        return comment;
      }
      function attachComments(tree, providedComments, tokens) {
        var comments = [], comment, len, i, cursor;
        if (!tree.range) {
          throw new Error("attachComments needs range information");
        }
        if (!tokens.length) {
          if (providedComments.length) {
            for (i = 0, len = providedComments.length; i < len; i += 1) {
              comment = deepCopy(providedComments[i]);
              comment.extendedRange = [0, tree.range[0]];
              comments.push(comment);
            }
            tree.leadingComments = comments;
          }
          return tree;
        }
        for (i = 0, len = providedComments.length; i < len; i += 1) {
          comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }
        cursor = 0;
        traverse(tree, {
          enter: function(node) {
            var comment2;
            while (cursor < comments.length) {
              comment2 = comments[cursor];
              if (comment2.extendedRange[1] > node.range[0]) {
                break;
              }
              if (comment2.extendedRange[1] === node.range[0]) {
                if (!node.leadingComments) {
                  node.leadingComments = [];
                }
                node.leadingComments.push(comment2);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        cursor = 0;
        traverse(tree, {
          leave: function(node) {
            var comment2;
            while (cursor < comments.length) {
              comment2 = comments[cursor];
              if (node.range[1] < comment2.extendedRange[0]) {
                break;
              }
              if (node.range[1] === comment2.extendedRange[0]) {
                if (!node.trailingComments) {
                  node.trailingComments = [];
                }
                node.trailingComments.push(comment2);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        return tree;
      }
      exports2.Syntax = Syntax;
      exports2.traverse = traverse;
      exports2.replace = replace;
      exports2.attachComments = attachComments;
      exports2.VisitorKeys = VisitorKeys;
      exports2.VisitorOption = VisitorOption;
      exports2.Controller = Controller;
      exports2.cloneEnvironment = function() {
        return clone({});
      };
      return exports2;
    })(exports);
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/ast.js
var require_ast = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/ast.js"(exports, module) {
    "use strict";
    var estraverse = require_estraverse();
    var eslintUtil = require_eslint();
    var getFirstTokens = eslintUtil.getFirstTokens;
    var getScope = eslintUtil.getScope;
    var getSourceCode = eslintUtil.getSourceCode;
    function traverse(ASTnode, visitor) {
      const opts = Object.assign({}, {
        fallback(node) {
          return Object.keys(node).filter((key) => key === "children" || key === "argument");
        }
      }, visitor);
      opts.keys = Object.assign({}, visitor.keys, {
        JSXElement: ["children"],
        JSXFragment: ["children"]
      });
      estraverse.traverse(ASTnode, opts);
    }
    function loopNodes(nodes) {
      for (let i = nodes.length - 1; i >= 0; i--) {
        if (nodes[i].type === "ReturnStatement") {
          return nodes[i];
        }
        if (nodes[i].type === "SwitchStatement") {
          const j = nodes[i].cases.length - 1;
          if (j >= 0) {
            return loopNodes(nodes[i].cases[j].consequent);
          }
        }
      }
      return false;
    }
    function findReturnStatement(node) {
      if ((!node.value || !node.value.body || !node.value.body.body) && (!node.body || !node.body.body)) {
        return false;
      }
      const bodyNodes = node.value ? node.value.body.body : node.body.body;
      return loopNodes(bodyNodes);
    }
    function traverseReturns(ASTNode, context, onReturn) {
      const nodeType = ASTNode.type;
      if (nodeType === "ReturnStatement") {
        onReturn(ASTNode.argument, () => {
        });
        return;
      }
      if (nodeType === "ArrowFunctionExpression" && ASTNode.expression) {
        onReturn(ASTNode.body, () => {
        });
        return;
      }
      if (nodeType !== "FunctionExpression" && nodeType !== "FunctionDeclaration" && nodeType !== "ArrowFunctionExpression" && nodeType !== "MethodDefinition") {
        return;
      }
      traverse(ASTNode.body, {
        enter(node) {
          const breakTraverse = () => {
            this.break();
          };
          switch (node.type) {
            case "ReturnStatement":
              this.skip();
              onReturn(node.argument, breakTraverse);
              return;
            case "BlockStatement":
            case "IfStatement":
            case "ForStatement":
            case "WhileStatement":
            case "SwitchStatement":
            case "SwitchCase":
              return;
            default:
              this.skip();
          }
        }
      });
    }
    function getPropertyNameNode(node) {
      if (node.key || ["MethodDefinition", "Property"].indexOf(node.type) !== -1) {
        return node.key;
      }
      if (node.type === "MemberExpression") {
        return node.property;
      }
      return null;
    }
    function getPropertyName(node) {
      const nameNode = getPropertyNameNode(node);
      return nameNode ? nameNode.name : "";
    }
    function getComponentProperties(node) {
      switch (node.type) {
        case "ClassDeclaration":
        case "ClassExpression":
          return node.body.body;
        case "ObjectExpression":
          return node.properties;
        default:
          return [];
      }
    }
    function getFirstNodeInLine(context, node) {
      const sourceCode = getSourceCode(context);
      let token = node;
      let lines;
      do {
        token = sourceCode.getTokenBefore(token);
        lines = token.type === "JSXText" ? token.value.split("\n") : null;
      } while (token.type === "JSXText" && /^\s*$/.test(lines[lines.length - 1]));
      return token;
    }
    function isNodeFirstInLine(context, node) {
      const token = getFirstNodeInLine(context, node);
      const startLine = node.loc.start.line;
      const endLine = token ? token.loc.end.line : -1;
      return startLine !== endLine;
    }
    function isFunctionLikeExpression(node) {
      return node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression";
    }
    function isFunction(node) {
      return node.type === "FunctionExpression" || node.type === "FunctionDeclaration";
    }
    function isFunctionLike(node) {
      return node.type === "FunctionDeclaration" || isFunctionLikeExpression(node);
    }
    function isClass(node) {
      return node.type === "ClassDeclaration" || node.type === "ClassExpression";
    }
    function inConstructor(context, node) {
      let scope = getScope(context, node);
      while (scope) {
        if (scope.block && scope.block.parent && scope.block.parent.kind === "constructor") {
          return true;
        }
        scope = scope.upper;
      }
      return false;
    }
    function stripQuotes(string) {
      return string.replace(/^'|'$/g, "");
    }
    function getKeyValue(context, node) {
      if (node.type === "ObjectTypeProperty") {
        const tokens = getFirstTokens(context, node, 2);
        return tokens[0].value === "+" || tokens[0].value === "-" ? tokens[1].value : stripQuotes(tokens[0].value);
      }
      if (node.type === "GenericTypeAnnotation") {
        return node.id.name;
      }
      if (node.type === "ObjectTypeAnnotation") {
        return;
      }
      const key = node.key || node.argument;
      if (!key) {
        return;
      }
      return key.type === "Identifier" ? key.name : key.value;
    }
    function isParenthesized(context, node) {
      const sourceCode = getSourceCode(context);
      const previousToken = sourceCode.getTokenBefore(node);
      const nextToken = sourceCode.getTokenAfter(node);
      return !!previousToken && !!nextToken && previousToken.value === "(" && previousToken.range[1] <= node.range[0] && nextToken.value === ")" && nextToken.range[0] >= node.range[1];
    }
    function isAssignmentLHS(node) {
      return node.parent && node.parent.type === "AssignmentExpression" && node.parent.left === node;
    }
    function unwrapTSAsExpression(node) {
      if (node && node.type === "TSAsExpression")
        return node.expression;
      return node;
    }
    function isTSTypeReference(node) {
      if (!node)
        return false;
      const nodeType = node.type;
      return nodeType === "TSTypeReference";
    }
    function isTSTypeAnnotation(node) {
      if (!node)
        return false;
      const nodeType = node.type;
      return nodeType === "TSTypeAnnotation";
    }
    function isTSTypeLiteral(node) {
      if (!node)
        return false;
      const nodeType = node.type;
      return nodeType === "TSTypeLiteral";
    }
    function isTSIntersectionType(node) {
      if (!node)
        return false;
      const nodeType = node.type;
      return nodeType === "TSIntersectionType";
    }
    function isTSInterfaceHeritage(node) {
      if (!node)
        return false;
      const nodeType = node.type;
      return nodeType === "TSInterfaceHeritage";
    }
    function isTSInterfaceDeclaration(node) {
      if (!node)
        return false;
      let nodeType = node.type;
      if (node.type === "ExportNamedDeclaration" && node.declaration) {
        nodeType = node.declaration.type;
      }
      return nodeType === "TSInterfaceDeclaration";
    }
    function isTSTypeDeclaration(node) {
      if (!node)
        return false;
      let nodeType = node.type;
      let nodeKind = node.kind;
      if (node.type === "ExportNamedDeclaration" && node.declaration) {
        nodeType = node.declaration.type;
        nodeKind = node.declaration.kind;
      }
      return nodeType === "VariableDeclaration" && nodeKind === "type";
    }
    function isTSTypeAliasDeclaration(node) {
      if (!node)
        return false;
      let nodeType = node.type;
      if (node.type === "ExportNamedDeclaration" && node.declaration) {
        nodeType = node.declaration.type;
        return nodeType === "TSTypeAliasDeclaration" && node.exportKind === "type";
      }
      return nodeType === "TSTypeAliasDeclaration";
    }
    function isTSParenthesizedType(node) {
      if (!node)
        return false;
      const nodeType = node.type;
      return nodeType === "TSTypeAliasDeclaration";
    }
    function isTSFunctionType(node) {
      if (!node)
        return false;
      const nodeType = node.type;
      return nodeType === "TSFunctionType";
    }
    function isTSTypeQuery(node) {
      if (!node)
        return false;
      const nodeType = node.type;
      return nodeType === "TSTypeQuery";
    }
    function isTSTypeParameterInstantiation(node) {
      if (!node)
        return false;
      const nodeType = node.type;
      return nodeType === "TSTypeParameterInstantiation";
    }
    module.exports = {
      traverse,
      findReturnStatement,
      getFirstNodeInLine,
      getPropertyName,
      getPropertyNameNode,
      getComponentProperties,
      getKeyValue,
      isParenthesized,
      isAssignmentLHS,
      isClass,
      isFunction,
      isFunctionLikeExpression,
      isFunctionLike,
      inConstructor,
      isNodeFirstInLine,
      unwrapTSAsExpression,
      traverseReturns,
      isTSTypeReference,
      isTSTypeAnnotation,
      isTSTypeLiteral,
      isTSIntersectionType,
      isTSInterfaceHeritage,
      isTSInterfaceDeclaration,
      isTSTypeAliasDeclaration,
      isTSParenthesizedType,
      isTSFunctionType,
      isTSTypeQuery,
      isTSTypeParameterInstantiation,
      isTSTypeDeclaration
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/esutils@2.0.3/node_modules/esutils/lib/ast.js
var require_ast2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/esutils@2.0.3/node_modules/esutils/lib/ast.js"(exports, module) {
    (function() {
      "use strict";
      function isExpression(node) {
        if (node == null) {
          return false;
        }
        switch (node.type) {
          case "ArrayExpression":
          case "AssignmentExpression":
          case "BinaryExpression":
          case "CallExpression":
          case "ConditionalExpression":
          case "FunctionExpression":
          case "Identifier":
          case "Literal":
          case "LogicalExpression":
          case "MemberExpression":
          case "NewExpression":
          case "ObjectExpression":
          case "SequenceExpression":
          case "ThisExpression":
          case "UnaryExpression":
          case "UpdateExpression":
            return true;
        }
        return false;
      }
      function isIterationStatement(node) {
        if (node == null) {
          return false;
        }
        switch (node.type) {
          case "DoWhileStatement":
          case "ForInStatement":
          case "ForStatement":
          case "WhileStatement":
            return true;
        }
        return false;
      }
      function isStatement(node) {
        if (node == null) {
          return false;
        }
        switch (node.type) {
          case "BlockStatement":
          case "BreakStatement":
          case "ContinueStatement":
          case "DebuggerStatement":
          case "DoWhileStatement":
          case "EmptyStatement":
          case "ExpressionStatement":
          case "ForInStatement":
          case "ForStatement":
          case "IfStatement":
          case "LabeledStatement":
          case "ReturnStatement":
          case "SwitchStatement":
          case "ThrowStatement":
          case "TryStatement":
          case "VariableDeclaration":
          case "WhileStatement":
          case "WithStatement":
            return true;
        }
        return false;
      }
      function isSourceElement(node) {
        return isStatement(node) || node != null && node.type === "FunctionDeclaration";
      }
      function trailingStatement(node) {
        switch (node.type) {
          case "IfStatement":
            if (node.alternate != null) {
              return node.alternate;
            }
            return node.consequent;
          case "LabeledStatement":
          case "ForStatement":
          case "ForInStatement":
          case "WhileStatement":
          case "WithStatement":
            return node.body;
        }
        return null;
      }
      function isProblematicIfStatement(node) {
        var current;
        if (node.type !== "IfStatement") {
          return false;
        }
        if (node.alternate == null) {
          return false;
        }
        current = node.consequent;
        do {
          if (current.type === "IfStatement") {
            if (current.alternate == null) {
              return true;
            }
          }
          current = trailingStatement(current);
        } while (current);
        return false;
      }
      module.exports = {
        isExpression,
        isStatement,
        isIterationStatement,
        isSourceElement,
        isProblematicIfStatement,
        trailingStatement
      };
    })();
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/esutils@2.0.3/node_modules/esutils/lib/code.js
var require_code = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/esutils@2.0.3/node_modules/esutils/lib/code.js"(exports, module) {
    (function() {
      "use strict";
      var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;
      ES5Regex = {
        // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
        // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
      };
      ES6Regex = {
        // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
        // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
      };
      function isDecimalDigit(ch2) {
        return 48 <= ch2 && ch2 <= 57;
      }
      function isHexDigit(ch2) {
        return 48 <= ch2 && ch2 <= 57 || // 0..9
        97 <= ch2 && ch2 <= 102 || // a..f
        65 <= ch2 && ch2 <= 70;
      }
      function isOctalDigit(ch2) {
        return ch2 >= 48 && ch2 <= 55;
      }
      NON_ASCII_WHITESPACES = [
        5760,
        8192,
        8193,
        8194,
        8195,
        8196,
        8197,
        8198,
        8199,
        8200,
        8201,
        8202,
        8239,
        8287,
        12288,
        65279
      ];
      function isWhiteSpace(ch2) {
        return ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && NON_ASCII_WHITESPACES.indexOf(ch2) >= 0;
      }
      function isLineTerminator(ch2) {
        return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233;
      }
      function fromCodePoint(cp) {
        if (cp <= 65535) {
          return String.fromCharCode(cp);
        }
        var cu1 = String.fromCharCode(Math.floor((cp - 65536) / 1024) + 55296);
        var cu2 = String.fromCharCode((cp - 65536) % 1024 + 56320);
        return cu1 + cu2;
      }
      IDENTIFIER_START = new Array(128);
      for (ch = 0; ch < 128; ++ch) {
        IDENTIFIER_START[ch] = ch >= 97 && ch <= 122 || // a..z
        ch >= 65 && ch <= 90 || // A..Z
        ch === 36 || ch === 95;
      }
      IDENTIFIER_PART = new Array(128);
      for (ch = 0; ch < 128; ++ch) {
        IDENTIFIER_PART[ch] = ch >= 97 && ch <= 122 || // a..z
        ch >= 65 && ch <= 90 || // A..Z
        ch >= 48 && ch <= 57 || // 0..9
        ch === 36 || ch === 95;
      }
      function isIdentifierStartES5(ch2) {
        return ch2 < 128 ? IDENTIFIER_START[ch2] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch2));
      }
      function isIdentifierPartES5(ch2) {
        return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch2));
      }
      function isIdentifierStartES6(ch2) {
        return ch2 < 128 ? IDENTIFIER_START[ch2] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch2));
      }
      function isIdentifierPartES6(ch2) {
        return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch2));
      }
      module.exports = {
        isDecimalDigit,
        isHexDigit,
        isOctalDigit,
        isWhiteSpace,
        isLineTerminator,
        isIdentifierStartES5,
        isIdentifierPartES5,
        isIdentifierStartES6,
        isIdentifierPartES6
      };
    })();
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/esutils@2.0.3/node_modules/esutils/lib/keyword.js
var require_keyword = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/esutils@2.0.3/node_modules/esutils/lib/keyword.js"(exports, module) {
    (function() {
      "use strict";
      var code = require_code();
      function isStrictModeReservedWordES6(id) {
        switch (id) {
          case "implements":
          case "interface":
          case "package":
          case "private":
          case "protected":
          case "public":
          case "static":
          case "let":
            return true;
          default:
            return false;
        }
      }
      function isKeywordES5(id, strict) {
        if (!strict && id === "yield") {
          return false;
        }
        return isKeywordES6(id, strict);
      }
      function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
          return true;
        }
        switch (id.length) {
          case 2:
            return id === "if" || id === "in" || id === "do";
          case 3:
            return id === "var" || id === "for" || id === "new" || id === "try";
          case 4:
            return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
          case 5:
            return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
          case 6:
            return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
          case 7:
            return id === "default" || id === "finally" || id === "extends";
          case 8:
            return id === "function" || id === "continue" || id === "debugger";
          case 10:
            return id === "instanceof";
          default:
            return false;
        }
      }
      function isReservedWordES5(id, strict) {
        return id === "null" || id === "true" || id === "false" || isKeywordES5(id, strict);
      }
      function isReservedWordES6(id, strict) {
        return id === "null" || id === "true" || id === "false" || isKeywordES6(id, strict);
      }
      function isRestrictedWord(id) {
        return id === "eval" || id === "arguments";
      }
      function isIdentifierNameES5(id) {
        var i, iz, ch;
        if (id.length === 0) {
          return false;
        }
        ch = id.charCodeAt(0);
        if (!code.isIdentifierStartES5(ch)) {
          return false;
        }
        for (i = 1, iz = id.length; i < iz; ++i) {
          ch = id.charCodeAt(i);
          if (!code.isIdentifierPartES5(ch)) {
            return false;
          }
        }
        return true;
      }
      function decodeUtf16(lead, trail) {
        return (lead - 55296) * 1024 + (trail - 56320) + 65536;
      }
      function isIdentifierNameES6(id) {
        var i, iz, ch, lowCh, check;
        if (id.length === 0) {
          return false;
        }
        check = code.isIdentifierStartES6;
        for (i = 0, iz = id.length; i < iz; ++i) {
          ch = id.charCodeAt(i);
          if (55296 <= ch && ch <= 56319) {
            ++i;
            if (i >= iz) {
              return false;
            }
            lowCh = id.charCodeAt(i);
            if (!(56320 <= lowCh && lowCh <= 57343)) {
              return false;
            }
            ch = decodeUtf16(ch, lowCh);
          }
          if (!check(ch)) {
            return false;
          }
          check = code.isIdentifierPartES6;
        }
        return true;
      }
      function isIdentifierES5(id, strict) {
        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
      }
      function isIdentifierES6(id, strict) {
        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
      }
      module.exports = {
        isKeywordES5,
        isKeywordES6,
        isReservedWordES5,
        isReservedWordES6,
        isRestrictedWord,
        isIdentifierNameES5,
        isIdentifierNameES6,
        isIdentifierES5,
        isIdentifierES6
      };
    })();
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/esutils@2.0.3/node_modules/esutils/lib/utils.js
var require_utils = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/esutils@2.0.3/node_modules/esutils/lib/utils.js"(exports) {
    (function() {
      "use strict";
      exports.ast = require_ast2();
      exports.code = require_code();
      exports.keyword = require_keyword();
    })();
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/doctrine@2.1.0/node_modules/doctrine/package.json
var require_package = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/doctrine@2.1.0/node_modules/doctrine/package.json"(exports, module) {
    module.exports = {
      name: "doctrine",
      description: "JSDoc parser",
      homepage: "https://github.com/eslint/doctrine",
      main: "lib/doctrine.js",
      version: "2.1.0",
      engines: {
        node: ">=0.10.0"
      },
      directories: {
        lib: "./lib"
      },
      files: [
        "lib"
      ],
      maintainers: [
        {
          name: "Nicholas C. Zakas",
          email: "nicholas+npm@nczconsulting.com",
          web: "https://www.nczonline.net"
        },
        {
          name: "Yusuke Suzuki",
          email: "utatane.tea@gmail.com",
          web: "https://github.com/Constellation"
        }
      ],
      repository: "eslint/doctrine",
      devDependencies: {
        coveralls: "^2.11.2",
        dateformat: "^1.0.11",
        eslint: "^1.10.3",
        "eslint-release": "^0.10.0",
        linefix: "^0.1.1",
        mocha: "^3.4.2",
        "npm-license": "^0.3.1",
        nyc: "^10.3.2",
        semver: "^5.0.3",
        shelljs: "^0.5.3",
        "shelljs-nodecli": "^0.1.1",
        should: "^5.0.1"
      },
      license: "Apache-2.0",
      scripts: {
        pretest: "npm run lint",
        test: "nyc mocha",
        coveralls: "nyc report --reporter=text-lcov | coveralls",
        lint: "eslint lib/",
        release: "eslint-release",
        "ci-release": "eslint-ci-release",
        alpharelease: "eslint-prerelease alpha",
        betarelease: "eslint-prerelease beta"
      },
      dependencies: {
        esutils: "^2.0.2"
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/doctrine@2.1.0/node_modules/doctrine/lib/utility.js
var require_utility = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/doctrine@2.1.0/node_modules/doctrine/lib/utility.js"(exports) {
    (function() {
      "use strict";
      var VERSION;
      VERSION = require_package().version;
      exports.VERSION = VERSION;
      function DoctrineError(message) {
        this.name = "DoctrineError";
        this.message = message;
      }
      DoctrineError.prototype = function() {
        var Middle = function() {
        };
        Middle.prototype = Error.prototype;
        return new Middle();
      }();
      DoctrineError.prototype.constructor = DoctrineError;
      exports.DoctrineError = DoctrineError;
      function throwError(message) {
        throw new DoctrineError(message);
      }
      exports.throwError = throwError;
      exports.assert = __require("assert");
    })();
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/doctrine@2.1.0/node_modules/doctrine/lib/typed.js
var require_typed = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/doctrine@2.1.0/node_modules/doctrine/lib/typed.js"(exports) {
    (function() {
      "use strict";
      var Syntax, Token, source, length, index, previous, token, value, esutils, utility, rangeOffset, addRange;
      esutils = require_utils();
      utility = require_utility();
      Syntax = {
        NullableLiteral: "NullableLiteral",
        AllLiteral: "AllLiteral",
        NullLiteral: "NullLiteral",
        UndefinedLiteral: "UndefinedLiteral",
        VoidLiteral: "VoidLiteral",
        UnionType: "UnionType",
        ArrayType: "ArrayType",
        RecordType: "RecordType",
        FieldType: "FieldType",
        FunctionType: "FunctionType",
        ParameterType: "ParameterType",
        RestType: "RestType",
        NonNullableType: "NonNullableType",
        OptionalType: "OptionalType",
        NullableType: "NullableType",
        NameExpression: "NameExpression",
        TypeApplication: "TypeApplication",
        StringLiteralType: "StringLiteralType",
        NumericLiteralType: "NumericLiteralType",
        BooleanLiteralType: "BooleanLiteralType"
      };
      Token = {
        ILLEGAL: 0,
        // ILLEGAL
        DOT_LT: 1,
        // .<
        REST: 2,
        // ...
        LT: 3,
        // <
        GT: 4,
        // >
        LPAREN: 5,
        // (
        RPAREN: 6,
        // )
        LBRACE: 7,
        // {
        RBRACE: 8,
        // }
        LBRACK: 9,
        // [
        RBRACK: 10,
        // ]
        COMMA: 11,
        // ,
        COLON: 12,
        // :
        STAR: 13,
        // *
        PIPE: 14,
        // |
        QUESTION: 15,
        // ?
        BANG: 16,
        // !
        EQUAL: 17,
        // =
        NAME: 18,
        // name token
        STRING: 19,
        // string
        NUMBER: 20,
        // number
        EOF: 21
      };
      function isTypeName(ch) {
        return "><(){}[],:*|?!=".indexOf(String.fromCharCode(ch)) === -1 && !esutils.code.isWhiteSpace(ch) && !esutils.code.isLineTerminator(ch);
      }
      function Context(previous2, index2, token2, value2) {
        this._previous = previous2;
        this._index = index2;
        this._token = token2;
        this._value = value2;
      }
      Context.prototype.restore = function() {
        previous = this._previous;
        index = this._index;
        token = this._token;
        value = this._value;
      };
      Context.save = function() {
        return new Context(previous, index, token, value);
      };
      function maybeAddRange(node, range) {
        if (addRange) {
          node.range = [range[0] + rangeOffset, range[1] + rangeOffset];
        }
        return node;
      }
      function advance() {
        var ch = source.charAt(index);
        index += 1;
        return ch;
      }
      function scanHexEscape(prefix) {
        var i, len, ch, code = 0;
        len = prefix === "u" ? 4 : 2;
        for (i = 0; i < len; ++i) {
          if (index < length && esutils.code.isHexDigit(source.charCodeAt(index))) {
            ch = advance();
            code = code * 16 + "0123456789abcdef".indexOf(ch.toLowerCase());
          } else {
            return "";
          }
        }
        return String.fromCharCode(code);
      }
      function scanString() {
        var str = "", quote, ch, code, unescaped, restore;
        quote = source.charAt(index);
        ++index;
        while (index < length) {
          ch = advance();
          if (ch === quote) {
            quote = "";
            break;
          } else if (ch === "\\") {
            ch = advance();
            if (!esutils.code.isLineTerminator(ch.charCodeAt(0))) {
              switch (ch) {
                case "n":
                  str += "\n";
                  break;
                case "r":
                  str += "\r";
                  break;
                case "t":
                  str += "	";
                  break;
                case "u":
                case "x":
                  restore = index;
                  unescaped = scanHexEscape(ch);
                  if (unescaped) {
                    str += unescaped;
                  } else {
                    index = restore;
                    str += ch;
                  }
                  break;
                case "b":
                  str += "\b";
                  break;
                case "f":
                  str += "\f";
                  break;
                case "v":
                  str += "\v";
                  break;
                default:
                  if (esutils.code.isOctalDigit(ch.charCodeAt(0))) {
                    code = "01234567".indexOf(ch);
                    if (index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {
                      code = code * 8 + "01234567".indexOf(advance());
                      if ("0123".indexOf(ch) >= 0 && index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {
                        code = code * 8 + "01234567".indexOf(advance());
                      }
                    }
                    str += String.fromCharCode(code);
                  } else {
                    str += ch;
                  }
                  break;
              }
            } else {
              if (ch === "\r" && source.charCodeAt(index) === 10) {
                ++index;
              }
            }
          } else if (esutils.code.isLineTerminator(ch.charCodeAt(0))) {
            break;
          } else {
            str += ch;
          }
        }
        if (quote !== "") {
          utility.throwError("unexpected quote");
        }
        value = str;
        return Token.STRING;
      }
      function scanNumber() {
        var number, ch;
        number = "";
        ch = source.charCodeAt(index);
        if (ch !== 46) {
          number = advance();
          ch = source.charCodeAt(index);
          if (number === "0") {
            if (ch === 120 || ch === 88) {
              number += advance();
              while (index < length) {
                ch = source.charCodeAt(index);
                if (!esutils.code.isHexDigit(ch)) {
                  break;
                }
                number += advance();
              }
              if (number.length <= 2) {
                utility.throwError("unexpected token");
              }
              if (index < length) {
                ch = source.charCodeAt(index);
                if (esutils.code.isIdentifierStartES5(ch)) {
                  utility.throwError("unexpected token");
                }
              }
              value = parseInt(number, 16);
              return Token.NUMBER;
            }
            if (esutils.code.isOctalDigit(ch)) {
              number += advance();
              while (index < length) {
                ch = source.charCodeAt(index);
                if (!esutils.code.isOctalDigit(ch)) {
                  break;
                }
                number += advance();
              }
              if (index < length) {
                ch = source.charCodeAt(index);
                if (esutils.code.isIdentifierStartES5(ch) || esutils.code.isDecimalDigit(ch)) {
                  utility.throwError("unexpected token");
                }
              }
              value = parseInt(number, 8);
              return Token.NUMBER;
            }
            if (esutils.code.isDecimalDigit(ch)) {
              utility.throwError("unexpected token");
            }
          }
          while (index < length) {
            ch = source.charCodeAt(index);
            if (!esutils.code.isDecimalDigit(ch)) {
              break;
            }
            number += advance();
          }
        }
        if (ch === 46) {
          number += advance();
          while (index < length) {
            ch = source.charCodeAt(index);
            if (!esutils.code.isDecimalDigit(ch)) {
              break;
            }
            number += advance();
          }
        }
        if (ch === 101 || ch === 69) {
          number += advance();
          ch = source.charCodeAt(index);
          if (ch === 43 || ch === 45) {
            number += advance();
          }
          ch = source.charCodeAt(index);
          if (esutils.code.isDecimalDigit(ch)) {
            number += advance();
            while (index < length) {
              ch = source.charCodeAt(index);
              if (!esutils.code.isDecimalDigit(ch)) {
                break;
              }
              number += advance();
            }
          } else {
            utility.throwError("unexpected token");
          }
        }
        if (index < length) {
          ch = source.charCodeAt(index);
          if (esutils.code.isIdentifierStartES5(ch)) {
            utility.throwError("unexpected token");
          }
        }
        value = parseFloat(number);
        return Token.NUMBER;
      }
      function scanTypeName() {
        var ch, ch2;
        value = advance();
        while (index < length && isTypeName(source.charCodeAt(index))) {
          ch = source.charCodeAt(index);
          if (ch === 46) {
            if (index + 1 >= length) {
              return Token.ILLEGAL;
            }
            ch2 = source.charCodeAt(index + 1);
            if (ch2 === 60) {
              break;
            }
          }
          value += advance();
        }
        return Token.NAME;
      }
      function next() {
        var ch;
        previous = index;
        while (index < length && esutils.code.isWhiteSpace(source.charCodeAt(index))) {
          advance();
        }
        if (index >= length) {
          token = Token.EOF;
          return token;
        }
        ch = source.charCodeAt(index);
        switch (ch) {
          case 39:
          case 34:
            token = scanString();
            return token;
          case 58:
            advance();
            token = Token.COLON;
            return token;
          case 44:
            advance();
            token = Token.COMMA;
            return token;
          case 40:
            advance();
            token = Token.LPAREN;
            return token;
          case 41:
            advance();
            token = Token.RPAREN;
            return token;
          case 91:
            advance();
            token = Token.LBRACK;
            return token;
          case 93:
            advance();
            token = Token.RBRACK;
            return token;
          case 123:
            advance();
            token = Token.LBRACE;
            return token;
          case 125:
            advance();
            token = Token.RBRACE;
            return token;
          case 46:
            if (index + 1 < length) {
              ch = source.charCodeAt(index + 1);
              if (ch === 60) {
                advance();
                advance();
                token = Token.DOT_LT;
                return token;
              }
              if (ch === 46 && index + 2 < length && source.charCodeAt(index + 2) === 46) {
                advance();
                advance();
                advance();
                token = Token.REST;
                return token;
              }
              if (esutils.code.isDecimalDigit(ch)) {
                token = scanNumber();
                return token;
              }
            }
            token = Token.ILLEGAL;
            return token;
          case 60:
            advance();
            token = Token.LT;
            return token;
          case 62:
            advance();
            token = Token.GT;
            return token;
          case 42:
            advance();
            token = Token.STAR;
            return token;
          case 124:
            advance();
            token = Token.PIPE;
            return token;
          case 63:
            advance();
            token = Token.QUESTION;
            return token;
          case 33:
            advance();
            token = Token.BANG;
            return token;
          case 61:
            advance();
            token = Token.EQUAL;
            return token;
          case 45:
            token = scanNumber();
            return token;
          default:
            if (esutils.code.isDecimalDigit(ch)) {
              token = scanNumber();
              return token;
            }
            utility.assert(isTypeName(ch));
            token = scanTypeName();
            return token;
        }
      }
      function consume(target, text) {
        utility.assert(token === target, text || "consumed token not matched");
        next();
      }
      function expect(target, message) {
        if (token !== target) {
          utility.throwError(message || "unexpected token");
        }
        next();
      }
      function parseUnionType() {
        var elements, startIndex = index - 1;
        consume(Token.LPAREN, "UnionType should start with (");
        elements = [];
        if (token !== Token.RPAREN) {
          while (true) {
            elements.push(parseTypeExpression());
            if (token === Token.RPAREN) {
              break;
            }
            expect(Token.PIPE);
          }
        }
        consume(Token.RPAREN, "UnionType should end with )");
        return maybeAddRange({
          type: Syntax.UnionType,
          elements
        }, [startIndex, previous]);
      }
      function parseArrayType() {
        var elements, startIndex = index - 1, restStartIndex;
        consume(Token.LBRACK, "ArrayType should start with [");
        elements = [];
        while (token !== Token.RBRACK) {
          if (token === Token.REST) {
            restStartIndex = index - 3;
            consume(Token.REST);
            elements.push(maybeAddRange({
              type: Syntax.RestType,
              expression: parseTypeExpression()
            }, [restStartIndex, previous]));
            break;
          } else {
            elements.push(parseTypeExpression());
          }
          if (token !== Token.RBRACK) {
            expect(Token.COMMA);
          }
        }
        expect(Token.RBRACK);
        return maybeAddRange({
          type: Syntax.ArrayType,
          elements
        }, [startIndex, previous]);
      }
      function parseFieldName() {
        var v = value;
        if (token === Token.NAME || token === Token.STRING) {
          next();
          return v;
        }
        if (token === Token.NUMBER) {
          consume(Token.NUMBER);
          return String(v);
        }
        utility.throwError("unexpected token");
      }
      function parseFieldType() {
        var key, rangeStart = previous;
        key = parseFieldName();
        if (token === Token.COLON) {
          consume(Token.COLON);
          return maybeAddRange({
            type: Syntax.FieldType,
            key,
            value: parseTypeExpression()
          }, [rangeStart, previous]);
        }
        return maybeAddRange({
          type: Syntax.FieldType,
          key,
          value: null
        }, [rangeStart, previous]);
      }
      function parseRecordType() {
        var fields, rangeStart = index - 1, rangeEnd;
        consume(Token.LBRACE, "RecordType should start with {");
        fields = [];
        if (token === Token.COMMA) {
          consume(Token.COMMA);
        } else {
          while (token !== Token.RBRACE) {
            fields.push(parseFieldType());
            if (token !== Token.RBRACE) {
              expect(Token.COMMA);
            }
          }
        }
        rangeEnd = index;
        expect(Token.RBRACE);
        return maybeAddRange({
          type: Syntax.RecordType,
          fields
        }, [rangeStart, rangeEnd]);
      }
      function parseNameExpression() {
        var name = value, rangeStart = index - name.length;
        expect(Token.NAME);
        if (token === Token.COLON && (name === "module" || name === "external" || name === "event")) {
          consume(Token.COLON);
          name += ":" + value;
          expect(Token.NAME);
        }
        return maybeAddRange({
          type: Syntax.NameExpression,
          name
        }, [rangeStart, previous]);
      }
      function parseTypeExpressionList() {
        var elements = [];
        elements.push(parseTop());
        while (token === Token.COMMA) {
          consume(Token.COMMA);
          elements.push(parseTop());
        }
        return elements;
      }
      function parseTypeName() {
        var expr, applications, startIndex = index - value.length;
        expr = parseNameExpression();
        if (token === Token.DOT_LT || token === Token.LT) {
          next();
          applications = parseTypeExpressionList();
          expect(Token.GT);
          return maybeAddRange({
            type: Syntax.TypeApplication,
            expression: expr,
            applications
          }, [startIndex, previous]);
        }
        return expr;
      }
      function parseResultType() {
        consume(Token.COLON, "ResultType should start with :");
        if (token === Token.NAME && value === "void") {
          consume(Token.NAME);
          return {
            type: Syntax.VoidLiteral
          };
        }
        return parseTypeExpression();
      }
      function parseParametersType() {
        var params = [], optionalSequence = false, expr, rest = false, startIndex, restStartIndex = index - 3, nameStartIndex;
        while (token !== Token.RPAREN) {
          if (token === Token.REST) {
            consume(Token.REST);
            rest = true;
          }
          startIndex = previous;
          expr = parseTypeExpression();
          if (expr.type === Syntax.NameExpression && token === Token.COLON) {
            nameStartIndex = previous - expr.name.length;
            consume(Token.COLON);
            expr = maybeAddRange({
              type: Syntax.ParameterType,
              name: expr.name,
              expression: parseTypeExpression()
            }, [nameStartIndex, previous]);
          }
          if (token === Token.EQUAL) {
            consume(Token.EQUAL);
            expr = maybeAddRange({
              type: Syntax.OptionalType,
              expression: expr
            }, [startIndex, previous]);
            optionalSequence = true;
          } else {
            if (optionalSequence) {
              utility.throwError("unexpected token");
            }
          }
          if (rest) {
            expr = maybeAddRange({
              type: Syntax.RestType,
              expression: expr
            }, [restStartIndex, previous]);
          }
          params.push(expr);
          if (token !== Token.RPAREN) {
            expect(Token.COMMA);
          }
        }
        return params;
      }
      function parseFunctionType() {
        var isNew, thisBinding, params, result, fnType, startIndex = index - value.length;
        utility.assert(token === Token.NAME && value === "function", "FunctionType should start with 'function'");
        consume(Token.NAME);
        expect(Token.LPAREN);
        isNew = false;
        params = [];
        thisBinding = null;
        if (token !== Token.RPAREN) {
          if (token === Token.NAME && (value === "this" || value === "new")) {
            isNew = value === "new";
            consume(Token.NAME);
            expect(Token.COLON);
            thisBinding = parseTypeName();
            if (token === Token.COMMA) {
              consume(Token.COMMA);
              params = parseParametersType();
            }
          } else {
            params = parseParametersType();
          }
        }
        expect(Token.RPAREN);
        result = null;
        if (token === Token.COLON) {
          result = parseResultType();
        }
        fnType = maybeAddRange({
          type: Syntax.FunctionType,
          params,
          result
        }, [startIndex, previous]);
        if (thisBinding) {
          fnType["this"] = thisBinding;
          if (isNew) {
            fnType["new"] = true;
          }
        }
        return fnType;
      }
      function parseBasicTypeExpression() {
        var context, startIndex;
        switch (token) {
          case Token.STAR:
            consume(Token.STAR);
            return maybeAddRange({
              type: Syntax.AllLiteral
            }, [previous - 1, previous]);
          case Token.LPAREN:
            return parseUnionType();
          case Token.LBRACK:
            return parseArrayType();
          case Token.LBRACE:
            return parseRecordType();
          case Token.NAME:
            startIndex = index - value.length;
            if (value === "null") {
              consume(Token.NAME);
              return maybeAddRange({
                type: Syntax.NullLiteral
              }, [startIndex, previous]);
            }
            if (value === "undefined") {
              consume(Token.NAME);
              return maybeAddRange({
                type: Syntax.UndefinedLiteral
              }, [startIndex, previous]);
            }
            if (value === "true" || value === "false") {
              consume(Token.NAME);
              return maybeAddRange({
                type: Syntax.BooleanLiteralType,
                value: value === "true"
              }, [startIndex, previous]);
            }
            context = Context.save();
            if (value === "function") {
              try {
                return parseFunctionType();
              } catch (e) {
                context.restore();
              }
            }
            return parseTypeName();
          case Token.STRING:
            next();
            return maybeAddRange({
              type: Syntax.StringLiteralType,
              value
            }, [previous - value.length - 2, previous]);
          case Token.NUMBER:
            next();
            return maybeAddRange({
              type: Syntax.NumericLiteralType,
              value
            }, [previous - String(value).length, previous]);
          default:
            utility.throwError("unexpected token");
        }
      }
      function parseTypeExpression() {
        var expr, rangeStart;
        if (token === Token.QUESTION) {
          rangeStart = index - 1;
          consume(Token.QUESTION);
          if (token === Token.COMMA || token === Token.EQUAL || token === Token.RBRACE || token === Token.RPAREN || token === Token.PIPE || token === Token.EOF || token === Token.RBRACK || token === Token.GT) {
            return maybeAddRange({
              type: Syntax.NullableLiteral
            }, [rangeStart, previous]);
          }
          return maybeAddRange({
            type: Syntax.NullableType,
            expression: parseBasicTypeExpression(),
            prefix: true
          }, [rangeStart, previous]);
        } else if (token === Token.BANG) {
          rangeStart = index - 1;
          consume(Token.BANG);
          return maybeAddRange({
            type: Syntax.NonNullableType,
            expression: parseBasicTypeExpression(),
            prefix: true
          }, [rangeStart, previous]);
        } else {
          rangeStart = previous;
        }
        expr = parseBasicTypeExpression();
        if (token === Token.BANG) {
          consume(Token.BANG);
          return maybeAddRange({
            type: Syntax.NonNullableType,
            expression: expr,
            prefix: false
          }, [rangeStart, previous]);
        }
        if (token === Token.QUESTION) {
          consume(Token.QUESTION);
          return maybeAddRange({
            type: Syntax.NullableType,
            expression: expr,
            prefix: false
          }, [rangeStart, previous]);
        }
        if (token === Token.LBRACK) {
          consume(Token.LBRACK);
          expect(Token.RBRACK, "expected an array-style type declaration (" + value + "[])");
          return maybeAddRange({
            type: Syntax.TypeApplication,
            expression: maybeAddRange({
              type: Syntax.NameExpression,
              name: "Array"
            }, [rangeStart, previous]),
            applications: [expr]
          }, [rangeStart, previous]);
        }
        return expr;
      }
      function parseTop() {
        var expr, elements;
        expr = parseTypeExpression();
        if (token !== Token.PIPE) {
          return expr;
        }
        elements = [expr];
        consume(Token.PIPE);
        while (true) {
          elements.push(parseTypeExpression());
          if (token !== Token.PIPE) {
            break;
          }
          consume(Token.PIPE);
        }
        return maybeAddRange({
          type: Syntax.UnionType,
          elements
        }, [0, index]);
      }
      function parseTopParamType() {
        var expr;
        if (token === Token.REST) {
          consume(Token.REST);
          return maybeAddRange({
            type: Syntax.RestType,
            expression: parseTop()
          }, [0, index]);
        }
        expr = parseTop();
        if (token === Token.EQUAL) {
          consume(Token.EQUAL);
          return maybeAddRange({
            type: Syntax.OptionalType,
            expression: expr
          }, [0, index]);
        }
        return expr;
      }
      function parseType(src, opt) {
        var expr;
        source = src;
        length = source.length;
        index = 0;
        previous = 0;
        addRange = opt && opt.range;
        rangeOffset = opt && opt.startIndex || 0;
        next();
        expr = parseTop();
        if (opt && opt.midstream) {
          return {
            expression: expr,
            index: previous
          };
        }
        if (token !== Token.EOF) {
          utility.throwError("not reach to EOF");
        }
        return expr;
      }
      function parseParamType(src, opt) {
        var expr;
        source = src;
        length = source.length;
        index = 0;
        previous = 0;
        addRange = opt && opt.range;
        rangeOffset = opt && opt.startIndex || 0;
        next();
        expr = parseTopParamType();
        if (opt && opt.midstream) {
          return {
            expression: expr,
            index: previous
          };
        }
        if (token !== Token.EOF) {
          utility.throwError("not reach to EOF");
        }
        return expr;
      }
      function stringifyImpl(node, compact, topLevel) {
        var result, i, iz;
        switch (node.type) {
          case Syntax.NullableLiteral:
            result = "?";
            break;
          case Syntax.AllLiteral:
            result = "*";
            break;
          case Syntax.NullLiteral:
            result = "null";
            break;
          case Syntax.UndefinedLiteral:
            result = "undefined";
            break;
          case Syntax.VoidLiteral:
            result = "void";
            break;
          case Syntax.UnionType:
            if (!topLevel) {
              result = "(";
            } else {
              result = "";
            }
            for (i = 0, iz = node.elements.length; i < iz; ++i) {
              result += stringifyImpl(node.elements[i], compact);
              if (i + 1 !== iz) {
                result += compact ? "|" : " | ";
              }
            }
            if (!topLevel) {
              result += ")";
            }
            break;
          case Syntax.ArrayType:
            result = "[";
            for (i = 0, iz = node.elements.length; i < iz; ++i) {
              result += stringifyImpl(node.elements[i], compact);
              if (i + 1 !== iz) {
                result += compact ? "," : ", ";
              }
            }
            result += "]";
            break;
          case Syntax.RecordType:
            result = "{";
            for (i = 0, iz = node.fields.length; i < iz; ++i) {
              result += stringifyImpl(node.fields[i], compact);
              if (i + 1 !== iz) {
                result += compact ? "," : ", ";
              }
            }
            result += "}";
            break;
          case Syntax.FieldType:
            if (node.value) {
              result = node.key + (compact ? ":" : ": ") + stringifyImpl(node.value, compact);
            } else {
              result = node.key;
            }
            break;
          case Syntax.FunctionType:
            result = compact ? "function(" : "function (";
            if (node["this"]) {
              if (node["new"]) {
                result += compact ? "new:" : "new: ";
              } else {
                result += compact ? "this:" : "this: ";
              }
              result += stringifyImpl(node["this"], compact);
              if (node.params.length !== 0) {
                result += compact ? "," : ", ";
              }
            }
            for (i = 0, iz = node.params.length; i < iz; ++i) {
              result += stringifyImpl(node.params[i], compact);
              if (i + 1 !== iz) {
                result += compact ? "," : ", ";
              }
            }
            result += ")";
            if (node.result) {
              result += (compact ? ":" : ": ") + stringifyImpl(node.result, compact);
            }
            break;
          case Syntax.ParameterType:
            result = node.name + (compact ? ":" : ": ") + stringifyImpl(node.expression, compact);
            break;
          case Syntax.RestType:
            result = "...";
            if (node.expression) {
              result += stringifyImpl(node.expression, compact);
            }
            break;
          case Syntax.NonNullableType:
            if (node.prefix) {
              result = "!" + stringifyImpl(node.expression, compact);
            } else {
              result = stringifyImpl(node.expression, compact) + "!";
            }
            break;
          case Syntax.OptionalType:
            result = stringifyImpl(node.expression, compact) + "=";
            break;
          case Syntax.NullableType:
            if (node.prefix) {
              result = "?" + stringifyImpl(node.expression, compact);
            } else {
              result = stringifyImpl(node.expression, compact) + "?";
            }
            break;
          case Syntax.NameExpression:
            result = node.name;
            break;
          case Syntax.TypeApplication:
            result = stringifyImpl(node.expression, compact) + ".<";
            for (i = 0, iz = node.applications.length; i < iz; ++i) {
              result += stringifyImpl(node.applications[i], compact);
              if (i + 1 !== iz) {
                result += compact ? "," : ", ";
              }
            }
            result += ">";
            break;
          case Syntax.StringLiteralType:
            result = '"' + node.value + '"';
            break;
          case Syntax.NumericLiteralType:
            result = String(node.value);
            break;
          case Syntax.BooleanLiteralType:
            result = String(node.value);
            break;
          default:
            utility.throwError("Unknown type " + node.type);
        }
        return result;
      }
      function stringify(node, options) {
        if (options == null) {
          options = {};
        }
        return stringifyImpl(node, options.compact, options.topLevel);
      }
      exports.parseType = parseType;
      exports.parseParamType = parseParamType;
      exports.stringify = stringify;
      exports.Syntax = Syntax;
    })();
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/doctrine@2.1.0/node_modules/doctrine/lib/doctrine.js
var require_doctrine = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/doctrine@2.1.0/node_modules/doctrine/lib/doctrine.js"(exports) {
    (function() {
      "use strict";
      var typed, utility, jsdoc, esutils, hasOwnProperty;
      esutils = require_utils();
      typed = require_typed();
      utility = require_utility();
      function sliceSource(source, index, last) {
        return source.slice(index, last);
      }
      hasOwnProperty = /* @__PURE__ */ function() {
        var func = Object.prototype.hasOwnProperty;
        return function hasOwnProperty2(obj, name) {
          return func.call(obj, name);
        };
      }();
      function shallowCopy(obj) {
        var ret = {}, key;
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            ret[key] = obj[key];
          }
        }
        return ret;
      }
      function isASCIIAlphanumeric(ch) {
        return ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90 || ch >= 48 && ch <= 57;
      }
      function isParamTitle(title) {
        return title === "param" || title === "argument" || title === "arg";
      }
      function isReturnTitle(title) {
        return title === "return" || title === "returns";
      }
      function isProperty(title) {
        return title === "property" || title === "prop";
      }
      function isNameParameterRequired(title) {
        return isParamTitle(title) || isProperty(title) || title === "alias" || title === "this" || title === "mixes" || title === "requires";
      }
      function isAllowedName(title) {
        return isNameParameterRequired(title) || title === "const" || title === "constant";
      }
      function isAllowedNested(title) {
        return isProperty(title) || isParamTitle(title);
      }
      function isAllowedOptional(title) {
        return isProperty(title) || isParamTitle(title);
      }
      function isTypeParameterRequired(title) {
        return isParamTitle(title) || isReturnTitle(title) || title === "define" || title === "enum" || title === "implements" || title === "this" || title === "type" || title === "typedef" || isProperty(title);
      }
      function isAllowedType(title) {
        return isTypeParameterRequired(title) || title === "throws" || title === "const" || title === "constant" || title === "namespace" || title === "member" || title === "var" || title === "module" || title === "constructor" || title === "class" || title === "extends" || title === "augments" || title === "public" || title === "private" || title === "protected";
      }
      var WHITESPACE = "[ \\f\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]";
      var STAR_MATCHER = "(" + WHITESPACE + "*(?:\\*" + WHITESPACE + "?)?)(.+|[\r\n\u2028\u2029])";
      function unwrapComment(doc) {
        return doc.replace(/^\/\*\*?/, "").replace(/\*\/$/, "").replace(new RegExp(STAR_MATCHER, "g"), "$2").replace(/\s*$/, "");
      }
      function convertUnwrappedCommentIndex(originalSource, unwrappedIndex) {
        var replacedSource = originalSource.replace(/^\/\*\*?/, "");
        var numSkippedChars = 0;
        var matcher = new RegExp(STAR_MATCHER, "g");
        var match;
        while (match = matcher.exec(replacedSource)) {
          numSkippedChars += match[1].length;
          if (match.index + match[0].length > unwrappedIndex + numSkippedChars) {
            return unwrappedIndex + numSkippedChars + originalSource.length - replacedSource.length;
          }
        }
        return originalSource.replace(/\*\/$/, "").replace(/\s*$/, "").length;
      }
      (function(exports2) {
        var Rules, index, lineNumber, length, source, originalSource, recoverable, sloppy, strict;
        function advance() {
          var ch = source.charCodeAt(index);
          index += 1;
          if (esutils.code.isLineTerminator(ch) && !(ch === 13 && source.charCodeAt(index) === 10)) {
            lineNumber += 1;
          }
          return String.fromCharCode(ch);
        }
        function scanTitle() {
          var title = "";
          advance();
          while (index < length && isASCIIAlphanumeric(source.charCodeAt(index))) {
            title += advance();
          }
          return title;
        }
        function seekContent() {
          var ch, waiting, last = index;
          waiting = false;
          while (last < length) {
            ch = source.charCodeAt(last);
            if (esutils.code.isLineTerminator(ch) && !(ch === 13 && source.charCodeAt(last + 1) === 10)) {
              waiting = true;
            } else if (waiting) {
              if (ch === 64) {
                break;
              }
              if (!esutils.code.isWhiteSpace(ch)) {
                waiting = false;
              }
            }
            last += 1;
          }
          return last;
        }
        function parseType(title, last, addRange) {
          var ch, brace, type, startIndex, direct = false;
          while (index < last) {
            ch = source.charCodeAt(index);
            if (esutils.code.isWhiteSpace(ch)) {
              advance();
            } else if (ch === 123) {
              advance();
              break;
            } else {
              direct = true;
              break;
            }
          }
          if (direct) {
            return null;
          }
          brace = 1;
          type = "";
          while (index < last) {
            ch = source.charCodeAt(index);
            if (esutils.code.isLineTerminator(ch)) {
              advance();
            } else {
              if (ch === 125) {
                brace -= 1;
                if (brace === 0) {
                  advance();
                  break;
                }
              } else if (ch === 123) {
                brace += 1;
              }
              if (type === "") {
                startIndex = index;
              }
              type += advance();
            }
          }
          if (brace !== 0) {
            return utility.throwError("Braces are not balanced");
          }
          if (isAllowedOptional(title)) {
            return typed.parseParamType(type, { startIndex: convertIndex(startIndex), range: addRange });
          }
          return typed.parseType(type, { startIndex: convertIndex(startIndex), range: addRange });
        }
        function scanIdentifier(last) {
          var identifier;
          if (!esutils.code.isIdentifierStartES5(source.charCodeAt(index)) && !source[index].match(/[0-9]/)) {
            return null;
          }
          identifier = advance();
          while (index < last && esutils.code.isIdentifierPartES5(source.charCodeAt(index))) {
            identifier += advance();
          }
          return identifier;
        }
        function skipWhiteSpace(last) {
          while (index < last && (esutils.code.isWhiteSpace(source.charCodeAt(index)) || esutils.code.isLineTerminator(source.charCodeAt(index)))) {
            advance();
          }
        }
        function parseName(last, allowBrackets, allowNestedParams) {
          var name = "", useBrackets, insideString;
          skipWhiteSpace(last);
          if (index >= last) {
            return null;
          }
          if (source.charCodeAt(index) === 91) {
            if (allowBrackets) {
              useBrackets = true;
              name = advance();
            } else {
              return null;
            }
          }
          name += scanIdentifier(last);
          if (allowNestedParams) {
            if (source.charCodeAt(index) === 58 && (name === "module" || name === "external" || name === "event")) {
              name += advance();
              name += scanIdentifier(last);
            }
            if (source.charCodeAt(index) === 91 && source.charCodeAt(index + 1) === 93) {
              name += advance();
              name += advance();
            }
            while (source.charCodeAt(index) === 46 || source.charCodeAt(index) === 47 || source.charCodeAt(index) === 35 || source.charCodeAt(index) === 45 || source.charCodeAt(index) === 126) {
              name += advance();
              name += scanIdentifier(last);
            }
          }
          if (useBrackets) {
            skipWhiteSpace(last);
            if (source.charCodeAt(index) === 61) {
              name += advance();
              skipWhiteSpace(last);
              var ch;
              var bracketDepth = 1;
              while (index < last) {
                ch = source.charCodeAt(index);
                if (esutils.code.isWhiteSpace(ch)) {
                  if (!insideString) {
                    skipWhiteSpace(last);
                    ch = source.charCodeAt(index);
                  }
                }
                if (ch === 39) {
                  if (!insideString) {
                    insideString = "'";
                  } else {
                    if (insideString === "'") {
                      insideString = "";
                    }
                  }
                }
                if (ch === 34) {
                  if (!insideString) {
                    insideString = '"';
                  } else {
                    if (insideString === '"') {
                      insideString = "";
                    }
                  }
                }
                if (ch === 91) {
                  bracketDepth++;
                } else if (ch === 93 && --bracketDepth === 0) {
                  break;
                }
                name += advance();
              }
            }
            skipWhiteSpace(last);
            if (index >= last || source.charCodeAt(index) !== 93) {
              return null;
            }
            name += advance();
          }
          return name;
        }
        function skipToTag() {
          while (index < length && source.charCodeAt(index) !== 64) {
            advance();
          }
          if (index >= length) {
            return false;
          }
          utility.assert(
            source.charCodeAt(index) === 64
            /* '@' */
          );
          return true;
        }
        function convertIndex(rangeIndex) {
          if (source === originalSource) {
            return rangeIndex;
          }
          return convertUnwrappedCommentIndex(originalSource, rangeIndex);
        }
        function TagParser(options, title) {
          this._options = options;
          this._title = title.toLowerCase();
          this._tag = {
            title,
            description: null
          };
          if (this._options.lineNumbers) {
            this._tag.lineNumber = lineNumber;
          }
          this._first = index - title.length - 1;
          this._last = 0;
          this._extra = {};
        }
        TagParser.prototype.addError = function addError(errorText) {
          var args = Array.prototype.slice.call(arguments, 1), msg = errorText.replace(
            /%(\d)/g,
            function(whole, index2) {
              utility.assert(index2 < args.length, "Message reference must be in range");
              return args[index2];
            }
          );
          if (!this._tag.errors) {
            this._tag.errors = [];
          }
          if (strict) {
            utility.throwError(msg);
          }
          this._tag.errors.push(msg);
          return recoverable;
        };
        TagParser.prototype.parseType = function() {
          if (isTypeParameterRequired(this._title)) {
            try {
              this._tag.type = parseType(this._title, this._last, this._options.range);
              if (!this._tag.type) {
                if (!isParamTitle(this._title) && !isReturnTitle(this._title)) {
                  if (!this.addError("Missing or invalid tag type")) {
                    return false;
                  }
                }
              }
            } catch (error) {
              this._tag.type = null;
              if (!this.addError(error.message)) {
                return false;
              }
            }
          } else if (isAllowedType(this._title)) {
            try {
              this._tag.type = parseType(this._title, this._last, this._options.range);
            } catch (e) {
            }
          }
          return true;
        };
        TagParser.prototype._parseNamePath = function(optional) {
          var name;
          name = parseName(this._last, sloppy && isAllowedOptional(this._title), true);
          if (!name) {
            if (!optional) {
              if (!this.addError("Missing or invalid tag name")) {
                return false;
              }
            }
          }
          this._tag.name = name;
          return true;
        };
        TagParser.prototype.parseNamePath = function() {
          return this._parseNamePath(false);
        };
        TagParser.prototype.parseNamePathOptional = function() {
          return this._parseNamePath(true);
        };
        TagParser.prototype.parseName = function() {
          var assign, name;
          if (isAllowedName(this._title)) {
            this._tag.name = parseName(this._last, sloppy && isAllowedOptional(this._title), isAllowedNested(this._title));
            if (!this._tag.name) {
              if (!isNameParameterRequired(this._title)) {
                return true;
              }
              if (isParamTitle(this._title) && this._tag.type && this._tag.type.name) {
                this._extra.name = this._tag.type;
                this._tag.name = this._tag.type.name;
                this._tag.type = null;
              } else {
                if (!this.addError("Missing or invalid tag name")) {
                  return false;
                }
              }
            } else {
              name = this._tag.name;
              if (name.charAt(0) === "[" && name.charAt(name.length - 1) === "]") {
                assign = name.substring(1, name.length - 1).split("=");
                if (assign.length > 1) {
                  this._tag["default"] = assign.slice(1).join("=");
                }
                this._tag.name = assign[0];
                if (this._tag.type && this._tag.type.type !== "OptionalType") {
                  this._tag.type = {
                    type: "OptionalType",
                    expression: this._tag.type
                  };
                }
              }
            }
          }
          return true;
        };
        TagParser.prototype.parseDescription = function parseDescription() {
          var description = sliceSource(source, index, this._last).trim();
          if (description) {
            if (/^-\s+/.test(description)) {
              description = description.substring(2);
            }
            this._tag.description = description;
          }
          return true;
        };
        TagParser.prototype.parseCaption = function parseDescription() {
          var description = sliceSource(source, index, this._last).trim();
          var captionStartTag = "<caption>";
          var captionEndTag = "</caption>";
          var captionStart = description.indexOf(captionStartTag);
          var captionEnd = description.indexOf(captionEndTag);
          if (captionStart >= 0 && captionEnd >= 0) {
            this._tag.caption = description.substring(
              captionStart + captionStartTag.length,
              captionEnd
            ).trim();
            this._tag.description = description.substring(captionEnd + captionEndTag.length).trim();
          } else {
            this._tag.description = description;
          }
          return true;
        };
        TagParser.prototype.parseKind = function parseKind() {
          var kind, kinds;
          kinds = {
            "class": true,
            "constant": true,
            "event": true,
            "external": true,
            "file": true,
            "function": true,
            "member": true,
            "mixin": true,
            "module": true,
            "namespace": true,
            "typedef": true
          };
          kind = sliceSource(source, index, this._last).trim();
          this._tag.kind = kind;
          if (!hasOwnProperty(kinds, kind)) {
            if (!this.addError("Invalid kind name '%0'", kind)) {
              return false;
            }
          }
          return true;
        };
        TagParser.prototype.parseAccess = function parseAccess() {
          var access;
          access = sliceSource(source, index, this._last).trim();
          this._tag.access = access;
          if (access !== "private" && access !== "protected" && access !== "public") {
            if (!this.addError("Invalid access name '%0'", access)) {
              return false;
            }
          }
          return true;
        };
        TagParser.prototype.parseThis = function parseThis() {
          var value = sliceSource(source, index, this._last).trim();
          if (value && value.charAt(0) === "{") {
            var gotType = this.parseType();
            if (gotType && this._tag.type.type === "NameExpression" || this._tag.type.type === "UnionType") {
              this._tag.name = this._tag.type.name;
              return true;
            } else {
              return this.addError("Invalid name for this");
            }
          } else {
            return this.parseNamePath();
          }
        };
        TagParser.prototype.parseVariation = function parseVariation() {
          var variation, text;
          text = sliceSource(source, index, this._last).trim();
          variation = parseFloat(text, 10);
          this._tag.variation = variation;
          if (isNaN(variation)) {
            if (!this.addError("Invalid variation '%0'", text)) {
              return false;
            }
          }
          return true;
        };
        TagParser.prototype.ensureEnd = function() {
          var shouldBeEmpty = sliceSource(source, index, this._last).trim();
          if (shouldBeEmpty) {
            if (!this.addError("Unknown content '%0'", shouldBeEmpty)) {
              return false;
            }
          }
          return true;
        };
        TagParser.prototype.epilogue = function epilogue() {
          var description;
          description = this._tag.description;
          if (isAllowedOptional(this._title) && !this._tag.type && description && description.charAt(0) === "[") {
            this._tag.type = this._extra.name;
            if (!this._tag.name) {
              this._tag.name = void 0;
            }
            if (!sloppy) {
              if (!this.addError("Missing or invalid tag name")) {
                return false;
              }
            }
          }
          return true;
        };
        Rules = {
          // http://usejsdoc.org/tags-access.html
          "access": ["parseAccess"],
          // http://usejsdoc.org/tags-alias.html
          "alias": ["parseNamePath", "ensureEnd"],
          // http://usejsdoc.org/tags-augments.html
          "augments": ["parseType", "parseNamePathOptional", "ensureEnd"],
          // http://usejsdoc.org/tags-constructor.html
          "constructor": ["parseType", "parseNamePathOptional", "ensureEnd"],
          // Synonym: http://usejsdoc.org/tags-constructor.html
          "class": ["parseType", "parseNamePathOptional", "ensureEnd"],
          // Synonym: http://usejsdoc.org/tags-extends.html
          "extends": ["parseType", "parseNamePathOptional", "ensureEnd"],
          // http://usejsdoc.org/tags-example.html
          "example": ["parseCaption"],
          // http://usejsdoc.org/tags-deprecated.html
          "deprecated": ["parseDescription"],
          // http://usejsdoc.org/tags-global.html
          "global": ["ensureEnd"],
          // http://usejsdoc.org/tags-inner.html
          "inner": ["ensureEnd"],
          // http://usejsdoc.org/tags-instance.html
          "instance": ["ensureEnd"],
          // http://usejsdoc.org/tags-kind.html
          "kind": ["parseKind"],
          // http://usejsdoc.org/tags-mixes.html
          "mixes": ["parseNamePath", "ensureEnd"],
          // http://usejsdoc.org/tags-mixin.html
          "mixin": ["parseNamePathOptional", "ensureEnd"],
          // http://usejsdoc.org/tags-member.html
          "member": ["parseType", "parseNamePathOptional", "ensureEnd"],
          // http://usejsdoc.org/tags-method.html
          "method": ["parseNamePathOptional", "ensureEnd"],
          // http://usejsdoc.org/tags-module.html
          "module": ["parseType", "parseNamePathOptional", "ensureEnd"],
          // Synonym: http://usejsdoc.org/tags-method.html
          "func": ["parseNamePathOptional", "ensureEnd"],
          // Synonym: http://usejsdoc.org/tags-method.html
          "function": ["parseNamePathOptional", "ensureEnd"],
          // Synonym: http://usejsdoc.org/tags-member.html
          "var": ["parseType", "parseNamePathOptional", "ensureEnd"],
          // http://usejsdoc.org/tags-name.html
          "name": ["parseNamePath", "ensureEnd"],
          // http://usejsdoc.org/tags-namespace.html
          "namespace": ["parseType", "parseNamePathOptional", "ensureEnd"],
          // http://usejsdoc.org/tags-private.html
          "private": ["parseType", "parseDescription"],
          // http://usejsdoc.org/tags-protected.html
          "protected": ["parseType", "parseDescription"],
          // http://usejsdoc.org/tags-public.html
          "public": ["parseType", "parseDescription"],
          // http://usejsdoc.org/tags-readonly.html
          "readonly": ["ensureEnd"],
          // http://usejsdoc.org/tags-requires.html
          "requires": ["parseNamePath", "ensureEnd"],
          // http://usejsdoc.org/tags-since.html
          "since": ["parseDescription"],
          // http://usejsdoc.org/tags-static.html
          "static": ["ensureEnd"],
          // http://usejsdoc.org/tags-summary.html
          "summary": ["parseDescription"],
          // http://usejsdoc.org/tags-this.html
          "this": ["parseThis", "ensureEnd"],
          // http://usejsdoc.org/tags-todo.html
          "todo": ["parseDescription"],
          // http://usejsdoc.org/tags-typedef.html
          "typedef": ["parseType", "parseNamePathOptional"],
          // http://usejsdoc.org/tags-variation.html
          "variation": ["parseVariation"],
          // http://usejsdoc.org/tags-version.html
          "version": ["parseDescription"]
        };
        TagParser.prototype.parse = function parse2() {
          var i, iz, sequences, method;
          if (!this._title) {
            if (!this.addError("Missing or invalid title")) {
              return null;
            }
          }
          this._last = seekContent(this._title);
          if (this._options.range) {
            this._tag.range = [this._first, source.slice(0, this._last).replace(/\s*$/, "").length].map(convertIndex);
          }
          if (hasOwnProperty(Rules, this._title)) {
            sequences = Rules[this._title];
          } else {
            sequences = ["parseType", "parseName", "parseDescription", "epilogue"];
          }
          for (i = 0, iz = sequences.length; i < iz; ++i) {
            method = sequences[i];
            if (!this[method]()) {
              return null;
            }
          }
          return this._tag;
        };
        function parseTag(options) {
          var title, parser, tag;
          if (!skipToTag()) {
            return null;
          }
          title = scanTitle();
          parser = new TagParser(options, title);
          tag = parser.parse();
          while (index < parser._last) {
            advance();
          }
          return tag;
        }
        function scanJSDocDescription(preserveWhitespace) {
          var description = "", ch, atAllowed;
          atAllowed = true;
          while (index < length) {
            ch = source.charCodeAt(index);
            if (atAllowed && ch === 64) {
              break;
            }
            if (esutils.code.isLineTerminator(ch)) {
              atAllowed = true;
            } else if (atAllowed && !esutils.code.isWhiteSpace(ch)) {
              atAllowed = false;
            }
            description += advance();
          }
          return preserveWhitespace ? description : description.trim();
        }
        function parse(comment, options) {
          var tags = [], tag, description, interestingTags, i, iz;
          if (options === void 0) {
            options = {};
          }
          if (typeof options.unwrap === "boolean" && options.unwrap) {
            source = unwrapComment(comment);
          } else {
            source = comment;
          }
          originalSource = comment;
          if (options.tags) {
            if (Array.isArray(options.tags)) {
              interestingTags = {};
              for (i = 0, iz = options.tags.length; i < iz; i++) {
                if (typeof options.tags[i] === "string") {
                  interestingTags[options.tags[i]] = true;
                } else {
                  utility.throwError('Invalid "tags" parameter: ' + options.tags);
                }
              }
            } else {
              utility.throwError('Invalid "tags" parameter: ' + options.tags);
            }
          }
          length = source.length;
          index = 0;
          lineNumber = 0;
          recoverable = options.recoverable;
          sloppy = options.sloppy;
          strict = options.strict;
          description = scanJSDocDescription(options.preserveWhitespace);
          while (true) {
            tag = parseTag(options);
            if (!tag) {
              break;
            }
            if (!interestingTags || interestingTags.hasOwnProperty(tag.title)) {
              tags.push(tag);
            }
          }
          return {
            description,
            tags
          };
        }
        exports2.parse = parse;
      })(jsdoc = {});
      exports.version = utility.VERSION;
      exports.parse = jsdoc.parse;
      exports.parseType = typed.parseType;
      exports.parseParamType = typed.parseParamType;
      exports.unwrapComment = unwrapComment;
      exports.Syntax = shallowCopy(typed.Syntax);
      exports.Error = utility.DoctrineError;
      exports.type = {
        Syntax: exports.Syntax,
        parseType: typed.parseType,
        parseParamType: typed.parseParamType,
        stringify: typed.stringify
      };
    })();
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/componentUtil.js
var require_componentUtil = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/componentUtil.js"(exports, module) {
    "use strict";
    var doctrine = require_doctrine();
    var pragmaUtil = require_pragma();
    var eslintUtil = require_eslint();
    var getScope = eslintUtil.getScope;
    var getSourceCode = eslintUtil.getSourceCode;
    var getText = eslintUtil.getText;
    function memoize(fn) {
      const cache = /* @__PURE__ */ new WeakMap();
      return function memoizedFn(arg) {
        const cachedValue = cache.get(arg);
        if (cachedValue !== void 0) {
          return cachedValue;
        }
        const v = fn(arg);
        cache.set(arg, v);
        return v;
      };
    }
    var getPragma = memoize(pragmaUtil.getFromContext);
    var getCreateClass = memoize(pragmaUtil.getCreateClassFromContext);
    function isES5Component(node, context) {
      const pragma = getPragma(context);
      const createClass = getCreateClass(context);
      if (!node.parent || !node.parent.callee) {
        return false;
      }
      const callee = node.parent.callee;
      if (callee.type === "MemberExpression") {
        return callee.object.name === pragma && callee.property.name === createClass;
      }
      if (callee.type === "Identifier") {
        return callee.name === createClass;
      }
      return false;
    }
    function isExplicitComponent(node, context) {
      const sourceCode = getSourceCode(context);
      let comment;
      try {
        comment = sourceCode.getJSDocComment(node);
      } catch (e) {
        comment = null;
      }
      if (comment === null) {
        return false;
      }
      let commentAst;
      try {
        commentAst = doctrine.parse(comment.value, {
          unwrap: true,
          tags: ["extends", "augments"]
        });
      } catch (e) {
        return false;
      }
      const relevantTags = commentAst.tags.filter((tag) => tag.name === "React.Component" || tag.name === "React.PureComponent");
      return relevantTags.length > 0;
    }
    function isES6Component(node, context) {
      const pragma = getPragma(context);
      if (isExplicitComponent(node, context)) {
        return true;
      }
      if (!node.superClass) {
        return false;
      }
      if (node.superClass.type === "MemberExpression") {
        return node.superClass.object.name === pragma && /^(Pure)?Component$/.test(node.superClass.property.name);
      }
      if (node.superClass.type === "Identifier") {
        return /^(Pure)?Component$/.test(node.superClass.name);
      }
      return false;
    }
    function getParentES5Component(context, node) {
      let scope = getScope(context, node);
      while (scope) {
        node = scope.block && scope.block.parent && scope.block.parent.parent;
        if (node && isES5Component(node, context)) {
          return node;
        }
        scope = scope.upper;
      }
      return null;
    }
    function getParentES6Component(context, node) {
      let scope = getScope(context, node);
      while (scope && scope.type !== "class") {
        scope = scope.upper;
      }
      node = scope && scope.block;
      if (!node || !isES6Component(node, context)) {
        return null;
      }
      return node;
    }
    function isPureComponent(node, context) {
      const pragma = getPragma(context);
      if (node.superClass) {
        return new RegExp(`^(${pragma}\\.)?PureComponent$`).test(getText(context, node.superClass));
      }
      return false;
    }
    function isStateMemberExpression(node) {
      return node.type === "MemberExpression" && node.object.type === "ThisExpression" && node.property.name === "state";
    }
    module.exports = {
      isES5Component,
      isES6Component,
      getParentES5Component,
      getParentES6Component,
      isExplicitComponent,
      isPureComponent,
      isStateMemberExpression
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/annotations.js
var require_annotations = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/annotations.js"(exports, module) {
    "use strict";
    var getFirstTokens = require_eslint().getFirstTokens;
    function isAnnotatedFunctionPropsDeclaration(node, context) {
      if (!node || !node.params || !node.params.length) {
        return false;
      }
      const typeNode = node.params[0].type === "AssignmentPattern" ? node.params[0].left : node.params[0];
      const tokens = getFirstTokens(context, typeNode, 2);
      const isAnnotated = typeNode.typeAnnotation;
      const isDestructuredProps = typeNode.type === "ObjectPattern";
      const isProps = tokens[0].value === "props" || tokens[1] && tokens[1].value === "props";
      return isAnnotated && (isDestructuredProps || isProps);
    }
    module.exports = {
      isAnnotatedFunctionPropsDeclaration
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/props.js
var require_props = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/props.js"(exports, module) {
    "use strict";
    var astUtil = require_ast();
    function isPropTypesDeclaration(node) {
      if (node && (node.type === "ClassProperty" || node.type === "PropertyDefinition")) {
        if (node.typeAnnotation && node.key.name === "props") {
          return true;
        }
      }
      return astUtil.getPropertyName(node) === "propTypes";
    }
    function isContextTypesDeclaration(node) {
      if (node && (node.type === "ClassProperty" || node.type === "PropertyDefinition")) {
        if (node.typeAnnotation && node.key.name === "context") {
          return true;
        }
      }
      return astUtil.getPropertyName(node) === "contextTypes";
    }
    function isContextTypeDeclaration(node) {
      return astUtil.getPropertyName(node) === "contextType";
    }
    function isChildContextTypesDeclaration(node) {
      return astUtil.getPropertyName(node) === "childContextTypes";
    }
    function isDefaultPropsDeclaration(node) {
      const propName = astUtil.getPropertyName(node);
      return propName === "defaultProps" || propName === "getDefaultProps";
    }
    function isDisplayNameDeclaration(node) {
      switch (node.type) {
        case "ClassProperty":
        case "PropertyDefinition":
          return node.key && node.key.name === "displayName";
        case "Identifier":
          return node.name === "displayName";
        case "Literal":
          return node.value === "displayName";
        default:
          return false;
      }
    }
    function isRequiredPropType(propTypeExpression) {
      return propTypeExpression.type === "MemberExpression" && propTypeExpression.property.name === "isRequired";
    }
    module.exports = {
      isPropTypesDeclaration,
      isContextTypesDeclaration,
      isContextTypeDeclaration,
      isChildContextTypesDeclaration,
      isDefaultPropsDeclaration,
      isDisplayNameDeclaration,
      isRequiredPropType
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/resolve@2.0.0-next.5/node_modules/resolve/lib/homedir.js
var require_homedir = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/resolve@2.0.0-next.5/node_modules/resolve/lib/homedir.js"(exports, module) {
    "use strict";
    var os = __require("os");
    module.exports = os.homedir || function homedir() {
      var home = __Process$.env.HOME;
      var user = __Process$.env.LOGNAME || __Process$.env.USER || __Process$.env.LNAME || __Process$.env.USERNAME;
      if (__Process$.platform === "win32") {
        return __Process$.env.USERPROFILE || __Process$.env.HOMEDRIVE + __Process$.env.HOMEPATH || home || null;
      }
      if (__Process$.platform === "darwin") {
        return home || (user ? "/Users/" + user : null);
      }
      if (__Process$.platform === "linux") {
        return home || (__Process$.getuid() === 0 ? "/root" : user ? "/home/" + user : null);
      }
      return home || null;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/resolve@2.0.0-next.5/node_modules/resolve/lib/caller.js
var require_caller = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/resolve@2.0.0-next.5/node_modules/resolve/lib/caller.js"(exports, module) {
    module.exports = function() {
      var origPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_, stack2) {
        return stack2;
      };
      var stack = new Error().stack;
      Error.prepareStackTrace = origPrepareStackTrace;
      return stack[2].getFileName();
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/path-parse@1.0.7/node_modules/path-parse/index.js
var require_path_parse = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/path-parse@1.0.7/node_modules/path-parse/index.js"(exports, module) {
    "use strict";
    var isWindows = __Process$.platform === "win32";
    var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
    var win32 = {};
    function win32SplitPath(filename) {
      return splitWindowsRe.exec(filename).slice(1);
    }
    win32.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = win32SplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
    var posix = {};
    function posixSplitPath(filename) {
      return splitPathRe.exec(filename).slice(1);
    }
    posix.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = posixSplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    if (isWindows)
      module.exports = win32.parse;
    else
      module.exports = posix.parse;
    module.exports.posix = posix.parse;
    module.exports.win32 = win32.parse;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/resolve@2.0.0-next.5/node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/resolve@2.0.0-next.5/node_modules/resolve/lib/node-modules-paths.js"(exports, module) {
    var path = __require("path");
    var parse = path.parse || require_path_parse();
    var getNodeModulesDirs = function getNodeModulesDirs2(absoluteStart, modules) {
      var prefix = "/";
      if (/^([A-Za-z]:)/.test(absoluteStart)) {
        prefix = "";
      } else if (/^\\\\/.test(absoluteStart)) {
        prefix = "\\\\";
      }
      var paths = [absoluteStart];
      var parsed = parse(absoluteStart);
      while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse(parsed.dir);
      }
      return paths.reduce(function(dirs, aPath) {
        return dirs.concat(modules.map(function(moduleDir) {
          return path.resolve(prefix, aPath, moduleDir);
        }));
      }, []);
    };
    module.exports = function nodeModulesPaths(start, opts, request) {
      var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
      if (opts && typeof opts.paths === "function") {
        return opts.paths(
          request,
          start,
          function() {
            return getNodeModulesDirs(start, modules);
          },
          opts
        );
      }
      var dirs = getNodeModulesDirs(start, modules);
      return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/resolve@2.0.0-next.5/node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/resolve@2.0.0-next.5/node_modules/resolve/lib/normalize-options.js"(exports, module) {
    module.exports = function(x, opts) {
      return opts || {};
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-core-module@2.13.1/node_modules/is-core-module/core.json
var require_core = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-core-module@2.13.1/node_modules/is-core-module/core.json"(exports, module) {
    module.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      "inspector/promises": [">= 19"],
      "node:inspector/promises": [">= 19"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "test/reporters": ">= 19.9 && < 20.2",
      "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
      "node:test": [">= 16.17 && < 17", ">= 18"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
      "node:wasi": [">= 18.17 && < 19", ">= 20"],
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-core-module@2.13.1/node_modules/is-core-module/index.js
var require_is_core_module = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/is-core-module@2.13.1/node_modules/is-core-module/index.js"(exports, module) {
    "use strict";
    var hasOwn = require_hasown();
    function specifierIncluded(current, specifier) {
      var nodeParts = current.split(".");
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i = 0; i < 3; ++i) {
        var cur = parseInt(nodeParts[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        }
        if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    function matchesRange(current, range) {
      var specifiers = range.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(current, specifiers[i])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(nodeVersion, specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      var current = typeof nodeVersion === "undefined" ? __Process$.versions && __Process$.versions.node : nodeVersion;
      if (typeof current !== "string") {
        throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i = 0; i < specifierValue.length; ++i) {
          if (matchesRange(current, specifierValue[i])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(current, specifierValue);
    }
    var data = require_core();
    module.exports = function isCore(x, nodeVersion) {
      return hasOwn(data, x) && versionIncluded(nodeVersion, data[x]);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/resolve@2.0.0-next.5/node_modules/resolve/lib/async.js
var require_async = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/resolve@2.0.0-next.5/node_modules/resolve/lib/async.js"(exports, module) {
    var fs = __require("fs");
    var getHomedir = require_homedir();
    var path = __require("path");
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var isCore = require_is_core_module();
    var realpathFS = __Process$.platform !== "win32" && fs.realpath && typeof fs.realpath.native === "function" ? fs.realpath.native : fs.realpath;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path.join(homedir, ".node_modules"),
        path.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file, cb) {
      fs.stat(file, function(err, stat) {
        if (!err) {
          return cb(null, stat.isFile() || stat.isFIFO());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    };
    var defaultIsDir = function isDirectory(dir, cb) {
      fs.stat(dir, function(err, stat) {
        if (!err) {
          return cb(null, stat.isDirectory());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    };
    var defaultRealpath = function realpath(x, cb) {
      realpathFS(x, function(realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== "ENOENT")
          cb(realpathErr);
        else
          cb(null, realpathErr ? x : realPath);
      });
    };
    var maybeRealpath = function maybeRealpath2(realpath, x, opts, cb) {
      if (!opts || !opts.preserveSymlinks) {
        realpath(x, cb);
      } else {
        cb(null, x);
      }
    };
    var defaultReadPackage = function defaultReadPackage2(readFile, pkgfile, cb) {
      readFile(pkgfile, function(readFileErr, body) {
        if (readFileErr)
          cb(readFileErr);
        else {
          try {
            var pkg = JSON.parse(body);
            cb(null, pkg);
          } catch (jsonErr) {
            cb(jsonErr);
          }
        }
      });
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
      }
      return dirs;
    };
    module.exports = function resolve(x, options, callback) {
      var cb = callback;
      var opts = options;
      if (typeof options === "function") {
        cb = opts;
        opts = {};
      }
      if (typeof x !== "string") {
        var err = new TypeError("Path must be a string.");
        return __Process$.nextTick(function() {
          cb(err);
        });
      }
      opts = normalizeOptions(x, opts);
      var isFile = opts.isFile || defaultIsFile;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var readFile = opts.readFile || fs.readFile;
      var realpath = opts.realpath || defaultRealpath;
      var readPackage = opts.readPackage || defaultReadPackage;
      if (opts.readFile && opts.readPackage) {
        var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
        return __Process$.nextTick(function() {
          cb(conflictErr);
        });
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = path.resolve(basedir);
      maybeRealpath(
        realpath,
        absoluteStart,
        opts,
        function(err2, realStart) {
          if (err2)
            cb(err2);
          else
            validateBasedir(realStart);
        }
      );
      function validateBasedir(basedir2) {
        if (opts.basedir) {
          var dirError = new TypeError('Provided basedir "' + basedir2 + '" is not a directory' + (opts.preserveSymlinks ? "" : ", or a symlink to a directory"));
          dirError.code = "INVALID_BASEDIR";
          isDirectory(basedir2, function(err2, result) {
            if (err2)
              return cb(err2);
            if (!result) {
              return cb(dirError);
            }
            validBasedir(basedir2);
          });
        } else {
          validBasedir(basedir2);
        }
      }
      var res;
      function validBasedir(basedir2) {
        if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
          res = path.resolve(basedir2, x);
          if (x === "." || x === ".." || x.slice(-1) === "/")
            res += "/";
          if (/\/$/.test(x) && res === basedir2) {
            loadAsDirectory(res, opts.package, onfile);
          } else
            loadAsFile(res, opts.package, onfile);
        } else if (includeCoreModules && isCore(x)) {
          return cb(null, x);
        } else
          loadNodeModules(x, basedir2, function(err2, n, pkg) {
            if (err2)
              cb(err2);
            else if (n) {
              return maybeRealpath(realpath, n, opts, function(err3, realN) {
                if (err3) {
                  cb(err3);
                } else {
                  cb(null, realN, pkg);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      function onfile(err2, m, pkg) {
        if (err2)
          cb(err2);
        else if (m)
          cb(null, m, pkg);
        else
          loadAsDirectory(res, function(err3, d, pkg2) {
            if (err3)
              cb(err3);
            else if (d) {
              maybeRealpath(realpath, d, opts, function(err4, realD) {
                if (err4) {
                  cb(err4);
                } else {
                  cb(null, realD, pkg2);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      function loadAsFile(x2, thePackage, callback2) {
        var loadAsFilePackage = thePackage;
        var cb2 = callback2;
        if (typeof loadAsFilePackage === "function") {
          cb2 = loadAsFilePackage;
          loadAsFilePackage = void 0;
        }
        var exts = [""].concat(extensions);
        load(exts, x2, loadAsFilePackage);
        function load(exts2, x3, loadPackage) {
          if (exts2.length === 0)
            return cb2(null, void 0, loadPackage);
          var file = x3 + exts2[0];
          var pkg = loadPackage;
          if (pkg)
            onpkg(null, pkg);
          else
            loadpkg(path.dirname(file), onpkg);
          function onpkg(err2, pkg_, dir) {
            pkg = pkg_;
            if (err2)
              return cb2(err2);
            if (dir && pkg && opts.pathFilter) {
              var rfile = path.relative(dir, file);
              var rel = rfile.slice(0, rfile.length - exts2[0].length);
              var r = opts.pathFilter(pkg, x3, rel);
              if (r)
                return load(
                  [""].concat(extensions.slice()),
                  path.resolve(dir, r),
                  pkg
                );
            }
            isFile(file, onex);
          }
          function onex(err2, ex) {
            if (err2)
              return cb2(err2);
            if (ex)
              return cb2(null, file, pkg);
            load(exts2.slice(1), x3, pkg);
          }
        }
      }
      function loadpkg(dir, cb2) {
        if (dir === "" || dir === "/")
          return cb2(null);
        if (__Process$.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return cb2(null);
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return cb2(null);
        maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return loadpkg(path.dirname(dir), cb2);
          var pkgfile = path.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (!ex)
              return loadpkg(path.dirname(dir), cb2);
            readPackage(readFile, pkgfile, function(err3, pkgParam) {
              if (err3 && !(err3 instanceof SyntaxError))
                cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile, dir);
              }
              cb2(null, pkg, dir);
            });
          });
        });
      }
      function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {
        var cb2 = callback2;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === "function") {
          cb2 = fpkg;
          fpkg = opts.package;
        }
        maybeRealpath(realpath, x2, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return loadAsDirectory(path.dirname(x2), fpkg, cb2);
          var pkgfile = path.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (err2)
              return cb2(err2);
            if (!ex)
              return loadAsFile(path.join(x2, "index"), fpkg, cb2);
            readPackage(readFile, pkgfile, function(err3, pkgParam) {
              if (err3)
                return cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile, pkgdir);
              }
              if (pkg && pkg.main) {
                if (typeof pkg.main !== "string") {
                  var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
                  mainError.code = "INVALID_PACKAGE_MAIN";
                  return cb2(mainError);
                }
                if (pkg.main === "." || pkg.main === "./") {
                  pkg.main = "index";
                }
                loadAsFile(path.resolve(x2, pkg.main), pkg, function(err4, m, pkg2) {
                  if (err4)
                    return cb2(err4);
                  if (m)
                    return cb2(null, m, pkg2);
                  if (!pkg2)
                    return loadAsFile(path.join(x2, "index"), pkg2, cb2);
                  var dir = path.resolve(x2, pkg2.main);
                  loadAsDirectory(dir, pkg2, function(err5, n, pkg3) {
                    if (err5)
                      return cb2(err5);
                    if (n)
                      return cb2(null, n, pkg3);
                    loadAsFile(path.join(x2, "index"), pkg3, function(err6, m2, pkg4) {
                      if (err6)
                        return cb2(err6);
                      if (m2)
                        return cb2(null, m2, pkg4);
                      var incorrectMainError = new Error("Cannot find module '" + path.resolve(x2, pkg4.main) + `'. Please verify that the package.json has a valid "main" entry`);
                      incorrectMainError.code = "INCORRECT_PACKAGE_MAIN";
                      return cb2(incorrectMainError);
                    });
                  });
                });
                return;
              }
              loadAsFile(path.join(x2, "/index"), pkg, cb2);
            });
          });
        });
      }
      function processDirs(cb2, dirs) {
        if (dirs.length === 0)
          return cb2(null, void 0);
        var dir = dirs[0];
        isDirectory(path.dirname(dir), isdir);
        function isdir(err2, isdir2) {
          if (err2)
            return cb2(err2);
          if (!isdir2)
            return processDirs(cb2, dirs.slice(1));
          loadAsFile(dir, opts.package, onfile2);
        }
        function onfile2(err2, m, pkg) {
          if (err2)
            return cb2(err2);
          if (m)
            return cb2(null, m, pkg);
          loadAsDirectory(dir, opts.package, ondir);
        }
        function ondir(err2, n, pkg) {
          if (err2)
            return cb2(err2);
          if (n)
            return cb2(null, n, pkg);
          processDirs(cb2, dirs.slice(1));
        }
      }
      function loadNodeModules(x2, start, cb2) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        processDirs(
          cb2,
          packageIterator ? packageIterator(x2, start, thunk, opts) : thunk()
        );
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/resolve@2.0.0-next.5/node_modules/resolve/lib/sync.js
var require_sync = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/resolve@2.0.0-next.5/node_modules/resolve/lib/sync.js"(exports, module) {
    var isCore = require_is_core_module();
    var fs = __require("fs");
    var path = __require("path");
    var getHomedir = require_homedir();
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var realpathFS = __Process$.platform !== "win32" && fs.realpathSync && typeof fs.realpathSync.native === "function" ? fs.realpathSync.native : fs.realpathSync;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path.join(homedir, ".node_modules"),
        path.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file) {
      try {
        var stat = fs.statSync(file, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
          return false;
        throw e;
      }
      return !!stat && (stat.isFile() || stat.isFIFO());
    };
    var defaultIsDir = function isDirectory(dir) {
      try {
        var stat = fs.statSync(dir, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
          return false;
        throw e;
      }
      return !!stat && stat.isDirectory();
    };
    var defaultRealpathSync = function realpathSync(x) {
      try {
        return realpathFS(x);
      } catch (realpathErr) {
        if (realpathErr.code !== "ENOENT") {
          throw realpathErr;
        }
      }
      return x;
    };
    var maybeRealpathSync = function maybeRealpathSync2(realpathSync, x, opts) {
      if (!opts || !opts.preserveSymlinks) {
        return realpathSync(x);
      }
      return x;
    };
    var defaultReadPackageSync = function defaultReadPackageSync2(readFileSync, pkgfile) {
      return JSON.parse(readFileSync(pkgfile));
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
      }
      return dirs;
    };
    module.exports = function resolveSync(x, options) {
      if (typeof x !== "string") {
        throw new TypeError("Path must be a string.");
      }
      var opts = normalizeOptions(x, options);
      var isFile = opts.isFile || defaultIsFile;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var readFileSync = opts.readFileSync || fs.readFileSync;
      var realpathSync = opts.realpathSync || defaultRealpathSync;
      var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
      if (opts.readFileSync && opts.readPackageSync) {
        throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);
      if (opts.basedir && !isDirectory(absoluteStart)) {
        var dirError = new TypeError('Provided basedir "' + opts.basedir + '" is not a directory' + (opts.preserveSymlinks ? "" : ", or a symlink to a directory"));
        dirError.code = "INVALID_BASEDIR";
        throw dirError;
      }
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
        var res = path.resolve(absoluteStart, x);
        if (x === "." || x === ".." || x.slice(-1) === "/")
          res += "/";
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m)
          return maybeRealpathSync(realpathSync, m, opts);
      } else if (includeCoreModules && isCore(x)) {
        return x;
      } else {
        var n = loadNodeModulesSync(x, absoluteStart);
        if (n)
          return maybeRealpathSync(realpathSync, n, opts);
      }
      var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
      err.code = "MODULE_NOT_FOUND";
      throw err;
      function loadAsFileSync(x2) {
        var pkg = loadpkg(path.dirname(x2));
        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
          var rfile = path.relative(pkg.dir, x2);
          var r = opts.pathFilter(pkg.pkg, x2, rfile);
          if (r) {
            x2 = path.resolve(pkg.dir, r);
          }
        }
        if (isFile(x2)) {
          return x2;
        }
        for (var i = 0; i < extensions.length; i++) {
          var file = x2 + extensions[i];
          if (isFile(file)) {
            return file;
          }
        }
      }
      function loadpkg(dir) {
        if (dir === "" || dir === "/")
          return;
        if (__Process$.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return;
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return;
        var pkgfile = path.join(isDirectory(dir) ? maybeRealpathSync(realpathSync, dir, opts) : dir, "package.json");
        if (!isFile(pkgfile)) {
          return loadpkg(path.dirname(dir));
        }
        var pkg;
        try {
          pkg = readPackageSync(readFileSync, pkgfile);
        } catch (e) {
          if (!(e instanceof SyntaxError)) {
            throw e;
          }
        }
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(pkg, pkgfile, dir);
        }
        return { pkg, dir };
      }
      function loadAsDirectorySync(x2) {
        var pkgfile = path.join(isDirectory(x2) ? maybeRealpathSync(realpathSync, x2, opts) : x2, "/package.json");
        if (isFile(pkgfile)) {
          try {
            var pkg = readPackageSync(readFileSync, pkgfile);
          } catch (e) {
          }
          if (pkg && opts.packageFilter) {
            pkg = opts.packageFilter(pkg, pkgfile, x2);
          }
          if (pkg && pkg.main) {
            if (typeof pkg.main !== "string") {
              var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
              mainError.code = "INVALID_PACKAGE_MAIN";
              throw mainError;
            }
            if (pkg.main === "." || pkg.main === "./") {
              pkg.main = "index";
            }
            try {
              var mainPath = path.resolve(x2, pkg.main);
              var m2 = loadAsFileSync(mainPath);
              if (m2)
                return m2;
              var n2 = loadAsDirectorySync(mainPath);
              if (n2)
                return n2;
              var checkIndex = loadAsFileSync(path.resolve(x2, "index"));
              if (checkIndex)
                return checkIndex;
            } catch (e) {
            }
            var incorrectMainError = new Error("Cannot find module '" + path.resolve(x2, pkg.main) + `'. Please verify that the package.json has a valid "main" entry`);
            incorrectMainError.code = "INCORRECT_PACKAGE_MAIN";
            throw incorrectMainError;
          }
        }
        return loadAsFileSync(path.join(x2, "/index"));
      }
      function loadNodeModulesSync(x2, start) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();
        for (var i = 0; i < dirs.length; i++) {
          var dir = dirs[i];
          if (isDirectory(path.dirname(dir))) {
            var m2 = loadAsFileSync(dir);
            if (m2)
              return m2;
            var n2 = loadAsDirectorySync(dir);
            if (n2)
              return n2;
          }
        }
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/resolve@2.0.0-next.5/node_modules/resolve/index.js
var require_resolve = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/resolve@2.0.0-next.5/node_modules/resolve/index.js"(exports, module) {
    var async = require_async();
    async.sync = require_sync();
    module.exports = async;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js
var require_semver = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js"(exports, module) {
    exports = module.exports = SemVer;
    var debug;
    if (typeof __Process$ === "object" && __Process$.env && __Process$.env.NODE_DEBUG && /\bsemver\b/i.test(__Process$.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug = function() {
      };
    }
    exports.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var t = exports.tokens = {};
    var R = 0;
    function tok(n) {
      t[n] = R++;
    }
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    function makeSafeRe(value) {
      for (var i2 = 0; i2 < safeRegexReplacements.length; i2++) {
        var token = safeRegexReplacements[i2][0];
        var max = safeRegexReplacements[i2][1];
        value = value.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
      }
      return value;
    }
    tok("NUMERICIDENTIFIER");
    src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    tok("NUMERICIDENTIFIERLOOSE");
    src[t.NUMERICIDENTIFIERLOOSE] = "\\d+";
    tok("NONNUMERICIDENTIFIER");
    src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
    tok("MAINVERSION");
    src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
    tok("MAINVERSIONLOOSE");
    src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
    tok("PRERELEASEIDENTIFIER");
    src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASEIDENTIFIERLOOSE");
    src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASE");
    src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
    tok("PRERELEASELOOSE");
    src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
    tok("BUILDIDENTIFIER");
    src[t.BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
    tok("BUILD");
    src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
    tok("FULL");
    tok("FULLPLAIN");
    src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
    src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
    tok("LOOSEPLAIN");
    src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
    tok("LOOSE");
    src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
    tok("GTLT");
    src[t.GTLT] = "((?:<|>)?=?)";
    tok("XRANGEIDENTIFIERLOOSE");
    src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    tok("XRANGEIDENTIFIER");
    src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
    tok("XRANGEPLAIN");
    src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
    tok("XRANGEPLAINLOOSE");
    src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
    tok("XRANGE");
    src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
    tok("XRANGELOOSE");
    src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
    tok("COERCE");
    src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    tok("COERCERTL");
    re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
    safeRe[t.COERCERTL] = new RegExp(makeSafeRe(src[t.COERCE]), "g");
    tok("LONETILDE");
    src[t.LONETILDE] = "(?:~>?)";
    tok("TILDETRIM");
    src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
    re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
    safeRe[t.TILDETRIM] = new RegExp(makeSafeRe(src[t.TILDETRIM]), "g");
    var tildeTrimReplace = "$1~";
    tok("TILDE");
    src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
    tok("TILDELOOSE");
    src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
    tok("LONECARET");
    src[t.LONECARET] = "(?:\\^)";
    tok("CARETTRIM");
    src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
    re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
    safeRe[t.CARETTRIM] = new RegExp(makeSafeRe(src[t.CARETTRIM]), "g");
    var caretTrimReplace = "$1^";
    tok("CARET");
    src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
    tok("CARETLOOSE");
    src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
    tok("COMPARATORLOOSE");
    src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
    tok("COMPARATOR");
    src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
    tok("COMPARATORTRIM");
    src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
    re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
    safeRe[t.COMPARATORTRIM] = new RegExp(makeSafeRe(src[t.COMPARATORTRIM]), "g");
    var comparatorTrimReplace = "$1$2$3";
    tok("HYPHENRANGE");
    src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
    tok("HYPHENRANGELOOSE");
    src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
    tok("STAR");
    src[t.STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
        safeRe[i] = new RegExp(makeSafeRe(src[i]));
      }
    }
    var i;
    exports.parse = parse;
    function parse(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    }
    exports.valid = valid;
    function valid(version, options) {
      var v = parse(version, options);
      return v ? v.version : null;
    }
    exports.clean = clean;
    function clean(version, options) {
      var s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }
    exports.SemVer = SemVer;
    function SemVer(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        if (version.loose === options.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError("Invalid Version: " + version);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version, options);
      }
      debug("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version.trim().match(options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.compareBuild = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      var i2 = 0;
      do {
        var a = this.build[i2];
        var b = other.build[i2];
        debug("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports.compareBuild = compareBuild;
    function compareBuild(a, b, loose) {
      var versionA = new SemVer(a, loose);
      var versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }
    exports.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports.compareBuild(a, b, loose);
      });
    }
    exports.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports.compareBuild(b, a, loose);
      });
    }
    exports.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY || version === ANY) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports.Range = Range;
    function Range(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + this.raw);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      var hr = loose ? safeRe[t.HYPHENRANGELOOSE] : safeRe[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug("hyphen replace", range);
      range = range.replace(safeRe[t.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range, safeRe[t.COMPARATORTRIM]);
      range = range.replace(safeRe[t.TILDETRIM], tildeTrimReplace);
      range = range.replace(safeRe[t.CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
          return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    function isSatisfiable(comparators, options) {
      var result = true;
      var remainingComparators = comparators.slice();
      var testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every(function(otherComparator) {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    }
    exports.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range(range, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? safeRe[t.TILDELOOSE] : safeRe[t.TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("tilde", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug("caret", comp, options);
      var r = options.loose ? safeRe[t.CARETLOOSE] : safeRe[t.CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("caret", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options) {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? safeRe[t.XRANGELOOSE] : safeRe[t.XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p + pr;
        } else if (xm) {
          ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
        }
        debug("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options) {
      debug("replaceStars", comp, options);
      return comp.trim().replace(safeRe[t.STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version, options) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports.satisfies = satisfies;
    function satisfies(version, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    exports.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }
    exports.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }
    exports.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports.ltr = ltr;
    function ltr(version, range, options) {
      return outside(version, range, "<", options);
    }
    exports.gtr = gtr;
    function gtr(version, range, options) {
      return outside(version, range, ">", options);
    }
    exports.outside = outside;
    function outside(version, range, hilo, options) {
      version = new SemVer(version, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports.prerelease = prerelease;
    function prerelease(version, options) {
      var parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }
    exports.coerce = coerce;
    function coerce(version, options) {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      var match = null;
      if (!options.rtl) {
        match = version.match(safeRe[t.COERCE]);
      } else {
        var next;
        while ((next = safeRe[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          safeRe[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        safeRe[t.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/error.js
var require_error = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/error.js"(exports, module) {
    "use strict";
    function error(message) {
      if (!/=-(f|-format)=/.test(__Process$.argv.join("="))) {
        console.error(message);
      }
    }
    module.exports = error;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/version.js
var require_version = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/version.js"(exports, module) {
    "use strict";
    var fs = __require("fs");
    var path = __require("path");
    var resolve = require_resolve();
    var semver = require_semver();
    var error = require_error();
    var warnedForMissingVersion = false;
    function resetWarningFlag() {
      warnedForMissingVersion = false;
    }
    var cachedDetectedReactVersion;
    function resetDetectedVersion() {
      cachedDetectedReactVersion = void 0;
    }
    function resolveBasedir(contextOrFilename) {
      if (contextOrFilename) {
        const filename = typeof contextOrFilename === "string" ? contextOrFilename : contextOrFilename.getFilename();
        const dirname = path.dirname(filename);
        try {
          if (fs.statSync(filename).isFile()) {
            return dirname;
          }
        } catch (err) {
          if (err.code === "ENOTDIR") {
            return resolveBasedir(dirname);
          }
        }
      }
      return __Process$.cwd();
    }
    function detectReactVersion(context) {
      if (cachedDetectedReactVersion) {
        return cachedDetectedReactVersion;
      }
      const basedir = resolveBasedir(context);
      try {
        const reactPath = resolve.sync("react", { basedir });
        const react = __require(reactPath);
        cachedDetectedReactVersion = react.version;
        return cachedDetectedReactVersion;
      } catch (e) {
        if (e.code === "MODULE_NOT_FOUND") {
          if (!warnedForMissingVersion) {
            error('Warning: React version was set to "detect" in eslint-plugin-react settings, but the "react" package is not installed. Assuming latest React version for linting.');
            warnedForMissingVersion = true;
          }
          cachedDetectedReactVersion = "999.999.999";
          return cachedDetectedReactVersion;
        }
        throw e;
      }
    }
    var defaultVersion = "999.999.999";
    function getReactVersionFromContext(context) {
      let confVer = defaultVersion;
      if (context.settings && context.settings.react && context.settings.react.version) {
        let settingsVersion = context.settings.react.version;
        if (settingsVersion === "detect") {
          settingsVersion = detectReactVersion(context);
        }
        if (typeof settingsVersion !== "string") {
          error(`Warning: React version specified in eslint-plugin-react-settings must be a string; got \u201C${typeof settingsVersion}\u201D`);
        }
        confVer = String(settingsVersion);
      } else if (!warnedForMissingVersion) {
        error("Warning: React version not specified in eslint-plugin-react settings. See https://github.com/jsx-eslint/eslint-plugin-react#configuration .");
        warnedForMissingVersion = true;
      }
      confVer = /^[0-9]+\.[0-9]+$/.test(confVer) ? `${confVer}.0` : confVer;
      const result = semver.coerce(confVer.split(".").map((part) => Number(part)).join("."));
      if (!result) {
        error(`Warning: React version specified in eslint-plugin-react-settings must be a valid semver version, or "detect"; got \u201C${confVer}\u201D`);
      }
      return result ? result.version : defaultVersion;
    }
    function detectFlowVersion(context) {
      const basedir = resolveBasedir(context);
      try {
        const flowPackageJsonPath = resolve.sync("flow-bin/package.json", { basedir });
        const flowPackageJson = __require(flowPackageJsonPath);
        return flowPackageJson.version;
      } catch (e) {
        if (e.code === "MODULE_NOT_FOUND") {
          error('Warning: Flow version was set to "detect" in eslint-plugin-react settings, but the "flow-bin" package is not installed. Assuming latest Flow version for linting.');
          return "999.999.999";
        }
        throw e;
      }
    }
    function getFlowVersionFromContext(context) {
      let confVer = defaultVersion;
      if (context.settings.react && context.settings.react.flowVersion) {
        let flowVersion = context.settings.react.flowVersion;
        if (flowVersion === "detect") {
          flowVersion = detectFlowVersion(context);
        }
        if (typeof flowVersion !== "string") {
          error(`Warning: Flow version specified in eslint-plugin-react-settings must be a string; got \u201C${typeof flowVersion}\u201D`);
        }
        confVer = String(flowVersion);
      } else {
        throw "Could not retrieve flowVersion from settings";
      }
      confVer = /^[0-9]+\.[0-9]+$/.test(confVer) ? `${confVer}.0` : confVer;
      const result = semver.coerce(confVer.split(".").map((part) => Number(part)).join("."));
      if (!result) {
        error(`Warning: Flow version specified in eslint-plugin-react-settings must be a valid semver version, or "detect"; got \u201C${confVer}\u201D`);
      }
      return result ? result.version : defaultVersion;
    }
    function test(semverRange, confVer) {
      return semver.satisfies(confVer, semverRange);
    }
    function testReactVersion(context, semverRange) {
      return test(semverRange, getReactVersionFromContext(context));
    }
    function testFlowVersion(context, semverRange) {
      return test(semverRange, getFlowVersionFromContext(context));
    }
    module.exports = {
      testReactVersion,
      testFlowVersion,
      resetWarningFlag,
      resetDetectedVersion
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.filter/implementation.js
var require_implementation16 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.filter/implementation.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var Call = require_Call();
    var CompletionRecord = require_CompletionRecord();
    var CreateIteratorFromClosure = require_CreateIteratorFromClosure();
    var GetIteratorDirect = require_GetIteratorDirect();
    var IsCallable = require_IsCallable();
    var IteratorClose = require_IteratorClose();
    var IteratorStepValue = require_IteratorStepValue();
    var ThrowCompletion = require_ThrowCompletion();
    var ToBoolean = require_ToBoolean();
    var Type = require_Type2();
    var iterHelperProto = require_IteratorHelperPrototype();
    var SLOT = require_internal_slot();
    module.exports = function filter(predicate) {
      if (this instanceof filter) {
        throw new $TypeError("`filter` is not a constructor");
      }
      var O = this;
      if (Type(O) !== "Object") {
        throw new $TypeError("`this` value must be an Object");
      }
      if (!IsCallable(predicate)) {
        throw new $TypeError("`predicate` must be a function");
      }
      var iterated = GetIteratorDirect(O);
      var closeIfAbrupt = function(abruptCompletion) {
        if (!(abruptCompletion instanceof CompletionRecord)) {
          throw new $TypeError("`abruptCompletion` must be a Completion Record");
        }
        IteratorClose(
          iterated,
          abruptCompletion
        );
      };
      var sentinel = {};
      var counter = 0;
      var closure = function() {
        while (true) {
          var value = IteratorStepValue(iterated);
          if (iterated["[[Done]]"]) {
            return sentinel;
          }
          var selected;
          try {
            selected = Call(predicate, void 0, [value, counter]);
            if (ToBoolean(selected)) {
              return value;
            }
          } catch (e) {
            closeIfAbrupt(ThrowCompletion(e));
            throw e;
          } finally {
            counter += 1;
          }
        }
      };
      SLOT.set(closure, "[[Sentinel]]", sentinel);
      SLOT.set(closure, "[[CloseIfAbrupt]]", closeIfAbrupt);
      var result = CreateIteratorFromClosure(closure, "Iterator Helper", iterHelperProto, ["[[UnderlyingIterator]]"]);
      SLOT.set(result, "[[UnderlyingIterator]]", iterated);
      return result;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.filter/polyfill.js
var require_polyfill14 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.filter/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation16();
    module.exports = function getPolyfill() {
      if (typeof Iterator === "function" && typeof Iterator.prototype.filter === "function") {
        try {
          Iterator.prototype.filter.call({ next: null }, function() {
          }).next();
        } catch (e) {
          return Iterator.prototype.filter;
        }
      }
      return implementation;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.filter/shim.js
var require_shim14 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.filter/shim.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var getPolyfill = require_polyfill14();
    var $IteratorPrototype = require_implementation12();
    module.exports = function shimIteratorPrototypeFilter() {
      var polyfill = getPolyfill();
      define(
        $IteratorPrototype,
        { filter: polyfill },
        { filter: function() {
          return $IteratorPrototype.filter !== polyfill;
        } }
      );
      return polyfill;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.filter/index.js
var require_Iterator_prototype2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.filter/index.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation16();
    var getPolyfill = require_polyfill14();
    var shim = require_shim14();
    var polyfill = callBind(getPolyfill());
    define(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = polyfill;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.some/implementation.js
var require_implementation17 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.some/implementation.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var Call = require_Call();
    var GetIteratorDirect = require_GetIteratorDirect();
    var IsCallable = require_IsCallable();
    var IteratorClose = require_IteratorClose();
    var IteratorStepValue = require_IteratorStepValue();
    var NormalCompletion = require_NormalCompletion();
    var ThrowCompletion = require_ThrowCompletion();
    var ToBoolean = require_ToBoolean();
    var Type = require_Type2();
    module.exports = function some(predicate) {
      if (this instanceof some) {
        throw new $TypeError("`some` is not a constructor");
      }
      var O = this;
      if (Type(O) !== "Object") {
        throw new $TypeError("`this` value must be an Object");
      }
      if (!IsCallable(predicate)) {
        throw new $TypeError("`predicate` must be a function");
      }
      var iterated = GetIteratorDirect(O);
      var counter = 0;
      while (true) {
        var value = IteratorStepValue(iterated);
        if (iterated["[[Done]]"]) {
          return false;
        }
        var result;
        try {
          result = Call(predicate, void 0, [value, counter]);
        } catch (e) {
          IteratorClose(
            iterated,
            ThrowCompletion(e)
          );
        } finally {
          counter += 1;
        }
        if (ToBoolean(result)) {
          return IteratorClose(
            iterated,
            NormalCompletion(true)
          );
        }
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.some/polyfill.js
var require_polyfill15 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.some/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation17();
    module.exports = function getPolyfill() {
      return typeof Iterator === "function" && typeof Iterator.prototype.some === "function" ? Iterator.prototype.some : implementation;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.some/shim.js
var require_shim15 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.some/shim.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var getPolyfill = require_polyfill15();
    var $IteratorPrototype = require_implementation12();
    module.exports = function shimIteratorPrototypeSome() {
      var polyfill = getPolyfill();
      define(
        $IteratorPrototype,
        { some: polyfill },
        { some: function() {
          return $IteratorPrototype.some !== polyfill;
        } }
      );
      return polyfill;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.some/index.js
var require_Iterator_prototype3 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.some/index.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation17();
    var getPolyfill = require_polyfill15();
    var shim = require_shim15();
    var polyfill = callBind(getPolyfill());
    define(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = polyfill;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/propWrapper.js
var require_propWrapper = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/propWrapper.js"(exports, module) {
    "use strict";
    var filter = require_Iterator_prototype2();
    var some = require_Iterator_prototype3();
    function searchPropWrapperFunctions(name, propWrapperFunctions) {
      const splitName = name.split(".");
      return some(propWrapperFunctions.values(), (func) => {
        if (splitName.length === 2 && func.object === splitName[0] && func.property === splitName[1]) {
          return true;
        }
        return name === func || func.property === name;
      });
    }
    function getPropWrapperFunctions(context) {
      return new Set(context.settings.propWrapperFunctions || []);
    }
    function isPropWrapperFunction(context, name) {
      if (typeof name !== "string") {
        return false;
      }
      const propWrapperFunctions = getPropWrapperFunctions(context);
      return searchPropWrapperFunctions(name, propWrapperFunctions);
    }
    function getExactPropWrapperFunctions(context) {
      const propWrapperFunctions = getPropWrapperFunctions(context);
      const exactPropWrappers = filter(propWrapperFunctions.values(), (func) => func.exact === true);
      return new Set(exactPropWrappers);
    }
    function isExactPropWrapperFunction(context, name) {
      const exactPropWrappers = getExactPropWrapperFunctions(context);
      return searchPropWrapperFunctions(name, exactPropWrappers);
    }
    function formatPropWrapperFunctions(propWrapperFunctions) {
      return Array.from(propWrapperFunctions, (func) => {
        if (func.object && func.property) {
          return `'${func.object}.${func.property}'`;
        }
        if (func.property) {
          return `'${func.property}'`;
        }
        return `'${func}'`;
      }).join(", ");
    }
    module.exports = {
      formatPropWrapperFunctions,
      getExactPropWrapperFunctions,
      getPropWrapperFunctions,
      isExactPropWrapperFunction,
      isPropWrapperFunction
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/isFirstLetterCapitalized.js
var require_isFirstLetterCapitalized = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/isFirstLetterCapitalized.js"(exports, module) {
    "use strict";
    function isFirstLetterCapitalized(word) {
      if (!word) {
        return false;
      }
      const firstLetter = word.replace(/^_+/, "").charAt(0);
      return firstLetter.toUpperCase() === firstLetter;
    }
    module.exports = isFirstLetterCapitalized;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/propTypes.js
var require_propTypes = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/propTypes.js"(exports, module) {
    "use strict";
    var flatMap = require_array_prototype();
    var annotations = require_annotations();
    var propsUtil = require_props();
    var variableUtil = require_variable();
    var testFlowVersion = require_version().testFlowVersion;
    var propWrapperUtil = require_propWrapper();
    var astUtil = require_ast();
    var isFirstLetterCapitalized = require_isFirstLetterCapitalized();
    var eslintUtil = require_eslint();
    var getFirstTokens = eslintUtil.getFirstTokens;
    var getScope = eslintUtil.getScope;
    var getSourceCode = eslintUtil.getSourceCode;
    var getText = eslintUtil.getText;
    function isFunctionType(node) {
      if (!node)
        return false;
      const nodeType = node.type;
      return nodeType === "FunctionDeclaration" || nodeType === "FunctionExpression" || nodeType === "ArrowFunctionExpression";
    }
    function isSuperTypeParameterPropsDeclaration(node) {
      if (node && (node.type === "ClassDeclaration" || node.type === "ClassExpression")) {
        if (node.superTypeParameters && node.superTypeParameters.params.length > 0) {
          return true;
        }
      }
      return false;
    }
    function iterateProperties(context, properties, fn, handleSpreadFn) {
      if (properties && properties.length && typeof fn === "function") {
        for (let i = 0, j = properties.length; i < j; i++) {
          const node = properties[i];
          const key = astUtil.getKeyValue(context, node);
          if (node.type === "ObjectTypeSpreadProperty" && typeof handleSpreadFn === "function") {
            handleSpreadFn(node.argument);
          }
          const value = node.value;
          fn(key, value, node);
        }
      }
    }
    function isInsideClassBody(node) {
      let parent = node.parent;
      while (parent) {
        if (parent.type === "ClassBody") {
          return true;
        }
        parent = parent.parent;
      }
      return false;
    }
    function startWithCapitalizedLetter(node) {
      return node.parent.type === "VariableDeclarator" && !isFirstLetterCapitalized(node.parent.id.name);
    }
    module.exports = function propTypesInstructions(context, components, utils) {
      let stack = null;
      const classExpressions = [];
      const defaults = { customValidators: [] };
      const configuration = Object.assign({}, defaults, context.options[0] || {});
      const customValidators = configuration.customValidators;
      const allowedGenericTypes = /* @__PURE__ */ new Set(["forwardRef", "ForwardRefRenderFunction", "VFC", "VoidFunctionComponent", "PropsWithChildren", "SFC", "StatelessComponent", "FunctionComponent", "FC"]);
      const genericTypeParamIndexWherePropsArePresent = {
        ForwardRefRenderFunction: 1,
        forwardRef: 1,
        VoidFunctionComponent: 0,
        VFC: 0,
        PropsWithChildren: 0,
        SFC: 0,
        StatelessComponent: 0,
        FunctionComponent: 0,
        FC: 0
      };
      const genericReactTypesImport = /* @__PURE__ */ new Set();
      const localToImportedMap = {};
      function typeScope() {
        return stack[stack.length - 1];
      }
      function getInTypeScope(key) {
        return stack[stack.length - 1][key];
      }
      function setInTypeScope(key, value) {
        stack[stack.length - 1][key] = value;
        return value;
      }
      function hasCustomValidator(validator) {
        return customValidators.indexOf(validator) !== -1;
      }
      const typeDeclarationBuilders = {
        GenericTypeAnnotation(annotation, parentName, seen) {
          if (getInTypeScope(annotation.id.name)) {
            return buildTypeAnnotationDeclarationTypes(getInTypeScope(annotation.id.name), parentName, seen);
          }
          return {};
        },
        ObjectTypeAnnotation(annotation, parentName, seen) {
          let containsUnresolvedObjectTypeSpread = false;
          let containsSpread = false;
          const containsIndexers = Boolean(annotation.indexers && annotation.indexers.length);
          const shapeTypeDefinition = {
            type: "shape",
            children: {}
          };
          iterateProperties(
            context,
            annotation.properties,
            (childKey, childValue, propNode) => {
              const fullName = [parentName, childKey].join(".");
              if (childKey || childValue) {
                const types = buildTypeAnnotationDeclarationTypes(childValue, fullName, seen);
                types.fullName = fullName;
                types.name = childKey;
                types.node = propNode;
                types.isRequired = !childValue.optional;
                shapeTypeDefinition.children[childKey] = types;
              }
            },
            (spreadNode) => {
              const key = astUtil.getKeyValue(context, spreadNode);
              const types = buildTypeAnnotationDeclarationTypes(spreadNode, key, seen);
              if (!types.children) {
                containsUnresolvedObjectTypeSpread = true;
              } else {
                Object.assign(shapeTypeDefinition, types.children);
              }
              containsSpread = true;
            }
          );
          shapeTypeDefinition.containsUnresolvedSpread = containsUnresolvedObjectTypeSpread;
          shapeTypeDefinition.containsIndexers = containsIndexers;
          shapeTypeDefinition.containsSpread = containsSpread;
          return shapeTypeDefinition;
        },
        UnionTypeAnnotation(annotation, parentName, seen) {
          const unionTypeDefinition = {
            type: "union",
            children: annotation.types.map((type) => buildTypeAnnotationDeclarationTypes(type, parentName, seen))
          };
          if (unionTypeDefinition.children.length === 0) {
            return {};
          }
          return unionTypeDefinition;
        },
        ArrayTypeAnnotation(annotation, parentName, seen) {
          const fullName = [parentName, "*"].join(".");
          const child = buildTypeAnnotationDeclarationTypes(annotation.elementType, fullName, seen);
          child.fullName = fullName;
          child.name = "__ANY_KEY__";
          child.node = annotation;
          return {
            type: "object",
            children: {
              __ANY_KEY__: child
            }
          };
        }
      };
      function resolveTypeAnnotation(node) {
        let annotation = node.left && node.left.typeAnnotation || node.typeAnnotation || node;
        while (annotation && (annotation.type === "TypeAnnotation" || annotation.type === "NullableTypeAnnotation")) {
          annotation = annotation.typeAnnotation;
        }
        if (annotation.type === "GenericTypeAnnotation" && getInTypeScope(annotation.id.name)) {
          return getInTypeScope(annotation.id.name);
        }
        return annotation;
      }
      function buildTypeAnnotationDeclarationTypes(annotation, parentName, seen) {
        if (typeof seen === "undefined") {
          seen = /* @__PURE__ */ new Set();
        }
        if (seen.has(annotation)) {
          return {};
        }
        seen.add(annotation);
        if (annotation.type in typeDeclarationBuilders) {
          return typeDeclarationBuilders[annotation.type](annotation, parentName, seen);
        }
        return {};
      }
      function declarePropTypesForObjectTypeAnnotation(propTypes, declaredPropTypes) {
        let ignorePropsValidation = false;
        iterateProperties(context, propTypes.properties, (key, value, propNode) => {
          if (!value) {
            ignorePropsValidation = ignorePropsValidation || propNode.type !== "ObjectTypeSpreadProperty";
            return;
          }
          const types = buildTypeAnnotationDeclarationTypes(value, key);
          types.fullName = key;
          types.name = key;
          types.node = propNode;
          types.isRequired = !propNode.optional;
          declaredPropTypes[key] = types;
        }, (spreadNode) => {
          const key = astUtil.getKeyValue(context, spreadNode);
          const spreadAnnotation = getInTypeScope(key);
          if (!spreadAnnotation) {
            ignorePropsValidation = true;
          } else {
            const spreadIgnoreValidation = declarePropTypesForObjectTypeAnnotation(spreadAnnotation, declaredPropTypes);
            ignorePropsValidation = ignorePropsValidation || spreadIgnoreValidation;
          }
        });
        return ignorePropsValidation;
      }
      function declarePropTypesForIntersectionTypeAnnotation(propTypes, declaredPropTypes) {
        return propTypes.types.some((annotation) => {
          if (annotation.type === "ObjectTypeAnnotation") {
            return declarePropTypesForObjectTypeAnnotation(annotation, declaredPropTypes);
          }
          if (annotation.type === "UnionTypeAnnotation") {
            return true;
          }
          if (!annotation.id) {
            return true;
          }
          const typeNode = getInTypeScope(annotation.id.name);
          if (!typeNode) {
            return true;
          }
          if (typeNode.type === "IntersectionTypeAnnotation") {
            return declarePropTypesForIntersectionTypeAnnotation(typeNode, declaredPropTypes);
          }
          return declarePropTypesForObjectTypeAnnotation(typeNode, declaredPropTypes);
        });
      }
      function resolveValueForIdentifierNode(node, rootNode, callback) {
        if (node && node.type === "Identifier") {
          const scope = getScope(context, rootNode);
          const identVariable = scope.variableScope.variables.find(
            (variable) => variable.name === node.name
          );
          if (identVariable) {
            const definition = identVariable.defs[identVariable.defs.length - 1];
            callback(definition.node.init);
          }
        }
      }
      function buildReactDeclarationTypes(value, parentName, rootNode) {
        if (value && value.callee && value.callee.object && hasCustomValidator(value.callee.object.name)) {
          return {};
        }
        let identNodeResolved = false;
        resolveValueForIdentifierNode(value, rootNode, (newValue) => {
          identNodeResolved = true;
          value = newValue;
        });
        if (value && value.type === "MemberExpression" && value.property && value.property.name && value.property.name === "isRequired") {
          value = value.object;
        }
        if (!identNodeResolved) {
          resolveValueForIdentifierNode(value, rootNode, (newValue) => {
            value = newValue;
          });
        }
        if (value && value.type === "CallExpression" && value.callee && value.callee.property && value.callee.property.name && value.arguments && value.arguments.length > 0) {
          const callName = value.callee.property.name;
          const argument = value.arguments[0];
          switch (callName) {
            case "shape":
            case "exact": {
              if (argument.type !== "ObjectExpression") {
                return {};
              }
              const shapeTypeDefinition = {
                type: callName,
                children: {}
              };
              iterateProperties(context, argument.properties, (childKey, childValue, propNode) => {
                if (childValue) {
                  const fullName = [parentName, childKey].join(".");
                  const types = buildReactDeclarationTypes(childValue, fullName, rootNode);
                  types.fullName = fullName;
                  types.name = childKey;
                  types.node = propNode;
                  shapeTypeDefinition.children[childKey] = types;
                }
              });
              return shapeTypeDefinition;
            }
            case "arrayOf":
            case "objectOf": {
              const fullName = [parentName, "*"].join(".");
              const child = buildReactDeclarationTypes(argument, fullName, rootNode);
              child.fullName = fullName;
              child.name = "__ANY_KEY__";
              child.node = argument;
              return {
                type: "object",
                children: {
                  __ANY_KEY__: child
                }
              };
            }
            case "oneOfType": {
              if (!argument.elements || !argument.elements.length) {
                return {};
              }
              const unionTypeDefinition = {
                type: "union",
                children: argument.elements.map((element) => buildReactDeclarationTypes(element, parentName, rootNode))
              };
              if (unionTypeDefinition.children.length === 0) {
                return {};
              }
              return unionTypeDefinition;
            }
            default:
              return {};
          }
        }
        return {};
      }
      function isValidReactGenericTypeAnnotation(annotation) {
        if (annotation.typeName) {
          if (annotation.typeName.name) {
            const typeName = annotation.typeName.name;
            if (!genericReactTypesImport.has(typeName)) {
              return false;
            }
          } else if (annotation.typeName.right.name) {
            const right = annotation.typeName.right.name;
            const left = annotation.typeName.left.name;
            if (!genericReactTypesImport.has(left) || !allowedGenericTypes.has(right)) {
              return false;
            }
          }
        }
        return true;
      }
      function getLeftMostTypeName(node) {
        if (node.name)
          return node.name;
        if (node.left)
          return getLeftMostTypeName(node.left);
      }
      function getRightMostTypeName(node) {
        if (node.name)
          return node.name;
        if (node.right)
          return getRightMostTypeName(node.right);
      }
      function filterInterfaceOrTypeAlias(node) {
        return astUtil.isTSInterfaceDeclaration(node) || astUtil.isTSTypeAliasDeclaration(node);
      }
      function filterInterfaceOrAliasByName(node, typeName) {
        return node.id && node.id.name === typeName || node.declaration && node.declaration.id && node.declaration.id.name === typeName;
      }
      class DeclarePropTypesForTSTypeAnnotation {
        constructor(propTypes, declaredPropTypes, rootNode) {
          this.propTypes = propTypes;
          this.declaredPropTypes = declaredPropTypes;
          this.foundDeclaredPropertiesList = [];
          this.referenceNameMap = /* @__PURE__ */ new Set();
          this.sourceCode = getSourceCode(context);
          this.shouldIgnorePropTypes = false;
          this.rootNode = rootNode;
          this.visitTSNode(this.propTypes);
          this.endAndStructDeclaredPropTypes();
        }
        /**
         * The node will be distribute to different function.
         * @param {ASTNode} node
         */
        visitTSNode(node) {
          if (!node)
            return;
          if (astUtil.isTSTypeAnnotation(node)) {
            const typeAnnotation = node.typeAnnotation;
            this.visitTSNode(typeAnnotation);
          } else if (astUtil.isTSTypeReference(node)) {
            this.searchDeclarationByName(node);
          } else if (astUtil.isTSInterfaceHeritage(node)) {
            this.searchDeclarationByName(node);
          } else if (astUtil.isTSTypeLiteral(node)) {
            if (Array.isArray(node.members)) {
              this.foundDeclaredPropertiesList = this.foundDeclaredPropertiesList.concat(node.members);
            }
          } else if (astUtil.isTSIntersectionType(node)) {
            this.convertIntersectionTypeToPropTypes(node);
          } else if (astUtil.isTSParenthesizedType(node)) {
            const typeAnnotation = node.typeAnnotation;
            this.visitTSNode(typeAnnotation);
          } else if (astUtil.isTSTypeParameterInstantiation(node)) {
            if (Array.isArray(node.params)) {
              node.params.forEach((x) => this.visitTSNode(x));
            }
          } else {
            this.shouldIgnorePropTypes = true;
          }
        }
        /**
         * Search TSInterfaceDeclaration or TSTypeAliasDeclaration,
         * by using TSTypeReference and TSInterfaceHeritage name.
         * @param {ASTNode} node
         */
        searchDeclarationByName(node) {
          let typeName;
          if (astUtil.isTSTypeReference(node)) {
            typeName = node.typeName.name;
            const leftMostName = getLeftMostTypeName(node.typeName);
            const shouldTraverseTypeParams = genericReactTypesImport.has(leftMostName);
            const nodeTypeParams = node.typeParameters;
            if (shouldTraverseTypeParams && nodeTypeParams && nodeTypeParams.length !== 0) {
              this.shouldSpecifyOptionalChildrenProps = true;
              const rightMostName = getRightMostTypeName(node.typeName);
              const importedName = localToImportedMap[rightMostName];
              const idx = genericTypeParamIndexWherePropsArePresent[leftMostName !== rightMostName ? rightMostName : importedName];
              const nextNode = nodeTypeParams.params[idx];
              this.visitTSNode(nextNode);
              return;
            }
          } else if (astUtil.isTSInterfaceHeritage(node)) {
            if (!node.expression && node.id) {
              typeName = node.id.name;
            } else {
              typeName = node.expression.name;
            }
          }
          if (!typeName) {
            this.shouldIgnorePropTypes = true;
            return;
          }
          if (typeName === "ReturnType") {
            this.convertReturnTypeToPropTypes(node, this.rootNode);
            return;
          }
          if (this.referenceNameMap.has(typeName)) {
            this.shouldIgnorePropTypes = true;
            return;
          }
          this.referenceNameMap.add(typeName);
          const candidateTypes = this.sourceCode.ast.body.filter((item) => astUtil.isTSTypeDeclaration(item));
          const declarations = flatMap(
            candidateTypes,
            (type) => type.declarations || type.declaration && type.declaration.declarations || type.declaration
          );
          const typeDeclaration = declarations.filter((dec) => dec.id.name === typeName);
          const interfaceDeclarations = this.sourceCode.ast.body.filter(filterInterfaceOrTypeAlias).filter((item) => filterInterfaceOrAliasByName(item, typeName)).map((item) => item.declaration || item);
          if (typeDeclaration.length !== 0) {
            typeDeclaration.map((t) => t.init || t.typeAnnotation).forEach(this.visitTSNode, this);
          } else if (interfaceDeclarations.length !== 0) {
            interfaceDeclarations.forEach(this.traverseDeclaredInterfaceOrTypeAlias, this);
          } else {
            this.shouldIgnorePropTypes = true;
          }
        }
        /**
         * Traverse TSInterfaceDeclaration and TSTypeAliasDeclaration
         * which retrieve from function searchDeclarationByName;
         * @param {ASTNode} node
         */
        traverseDeclaredInterfaceOrTypeAlias(node) {
          if (astUtil.isTSInterfaceDeclaration(node)) {
            this.foundDeclaredPropertiesList = this.foundDeclaredPropertiesList.concat(node.body.body);
          }
          if (astUtil.isTSTypeAliasDeclaration(node)) {
            const typeAnnotation = node.typeAnnotation;
            this.visitTSNode(typeAnnotation);
          }
          if (Array.isArray(node.extends)) {
            node.extends.forEach((x) => this.visitTSNode(x));
          } else if (Array.isArray(node.heritage)) {
            node.heritage.forEach((x) => this.visitTSNode(x));
          }
        }
        convertIntersectionTypeToPropTypes(node) {
          if (!node)
            return;
          if (Array.isArray(node.types)) {
            node.types.forEach((x) => this.visitTSNode(x));
          } else {
            this.shouldIgnorePropTypes = true;
          }
        }
        convertReturnTypeToPropTypes(node, rootNode) {
          const nodeTypeParams = node.typeParameters;
          if (nodeTypeParams) {
            if (nodeTypeParams.params.length === 1) {
              let returnType = nodeTypeParams.params[0];
              if (astUtil.isTSTypeReference(returnType)) {
                returnType = returnType.typeName;
              }
              if (astUtil.isTSTypeQuery(returnType)) {
                const returnTypeFunction = flatMap(this.sourceCode.ast.body.filter(
                  (item) => item.type === "VariableDeclaration" && item.declarations.find((dec) => dec.id.name === returnType.exprName.name)
                ), (type) => type.declarations).map((dec) => dec.init);
                if (Array.isArray(returnTypeFunction)) {
                  if (returnTypeFunction.length === 0) {
                    this.shouldIgnorePropTypes = true;
                    return;
                  }
                  returnTypeFunction.forEach((func) => {
                    if (isFunctionType(func)) {
                      let res = func.body;
                      if (res.type === "BlockStatement") {
                        res = astUtil.findReturnStatement(func);
                        if (res) {
                          res = res.argument;
                        }
                      }
                      switch (res.type) {
                        case "ObjectExpression":
                          iterateProperties(context, res.properties, (key, value, propNode) => {
                            if (propNode && propNode.argument && propNode.argument.type === "CallExpression") {
                              const propNodeTypeParams = propNode.argument.typeParameters;
                              if (propNodeTypeParams) {
                                this.visitTSNode(propNodeTypeParams);
                              } else {
                                this.shouldIgnorePropTypes = true;
                                return;
                              }
                            }
                            if (!value) {
                              this.shouldIgnorePropTypes = true;
                              return;
                            }
                            const types = buildReactDeclarationTypes(value, key, rootNode);
                            types.fullName = key;
                            types.name = key;
                            types.node = propNode;
                            types.isRequired = propsUtil.isRequiredPropType(value);
                            this.declaredPropTypes[key] = types;
                          });
                          break;
                        case "CallExpression":
                          if (res.typeParameters) {
                            this.visitTSNode(res.typeParameters);
                          } else {
                            this.shouldIgnorePropTypes = true;
                          }
                          break;
                        default:
                      }
                    }
                  });
                  return;
                }
              }
              if (astUtil.isTSFunctionType(returnType)) {
                if (astUtil.isTSTypeAnnotation(returnType.returnType)) {
                  this.visitTSNode(returnType.returnType);
                  return;
                }
                if (astUtil.isTSTypeAnnotation(returnType.typeAnnotation)) {
                  this.visitTSNode(returnType.typeAnnotation);
                  return;
                }
              }
            }
          }
          this.shouldIgnorePropTypes = true;
        }
        endAndStructDeclaredPropTypes() {
          if (this.shouldSpecifyOptionalChildrenProps) {
            this.declaredPropTypes.children = {
              fullName: "children",
              name: "children",
              isRequired: false
            };
          }
          this.foundDeclaredPropertiesList.forEach((tsInterfaceBody) => {
            if (tsInterfaceBody && (tsInterfaceBody.type === "TSPropertySignature" || tsInterfaceBody.type === "TSMethodSignature")) {
              let accessor = "name";
              if (tsInterfaceBody.key.type === "Literal") {
                if (typeof tsInterfaceBody.key.value === "number") {
                  accessor = "raw";
                } else {
                  accessor = "value";
                }
              }
              this.declaredPropTypes[tsInterfaceBody.key[accessor]] = {
                fullName: tsInterfaceBody.key[accessor],
                name: tsInterfaceBody.key[accessor],
                node: tsInterfaceBody,
                isRequired: !tsInterfaceBody.optional
              };
            }
          });
        }
      }
      function markPropTypesAsDeclared(node, propTypes, rootNode) {
        let componentNode = node;
        while (componentNode && !components.get(componentNode)) {
          componentNode = componentNode.parent;
        }
        const component = components.get(componentNode);
        let declaredPropTypes = component && component.declaredPropTypes || {};
        let ignorePropsValidation = component && component.ignorePropsValidation || false;
        switch (propTypes && propTypes.type) {
          case "ObjectTypeAnnotation":
            ignorePropsValidation = declarePropTypesForObjectTypeAnnotation(propTypes, declaredPropTypes);
            break;
          case "ObjectExpression":
            iterateProperties(context, propTypes.properties, (key, value, propNode) => {
              if (!value) {
                ignorePropsValidation = true;
                return;
              }
              const types = buildReactDeclarationTypes(value, key, rootNode);
              types.fullName = key;
              types.name = key;
              types.node = propNode;
              types.isRequired = propsUtil.isRequiredPropType(value);
              declaredPropTypes[key] = types;
            });
            break;
          case "MemberExpression": {
            let curDeclaredPropTypes = declaredPropTypes;
            while (propTypes && propTypes.parent && propTypes.parent.type !== "AssignmentExpression" && propTypes.property && curDeclaredPropTypes) {
              const propName = propTypes.property.name;
              if (propName in curDeclaredPropTypes) {
                curDeclaredPropTypes = curDeclaredPropTypes[propName].children;
                propTypes = propTypes.parent;
              } else {
                propTypes = null;
              }
            }
            if (propTypes && propTypes.parent && propTypes.property) {
              if (!(propTypes === propTypes.parent.left && propTypes.parent.left.object)) {
                ignorePropsValidation = true;
                break;
              }
              const parentProp = getText(context, propTypes.parent.left.object).replace(/^.*\.propTypes\./, "");
              const types = buildReactDeclarationTypes(
                propTypes.parent.right,
                parentProp,
                rootNode
              );
              types.name = propTypes.property.name;
              types.fullName = [parentProp, propTypes.property.name].join(".");
              types.node = propTypes.parent;
              types.isRequired = propsUtil.isRequiredPropType(propTypes.parent.right);
              curDeclaredPropTypes[propTypes.property.name] = types;
            } else {
              let isUsedInPropTypes = false;
              let n = propTypes;
              while (n) {
                if (n.type === "AssignmentExpression" && propsUtil.isPropTypesDeclaration(n.left) || (n.type === "ClassProperty" || n.type === "PropertyDefinition" || n.type === "Property") && propsUtil.isPropTypesDeclaration(n)) {
                  isUsedInPropTypes = true;
                  break;
                }
                n = n.parent;
              }
              if (!isUsedInPropTypes) {
                ignorePropsValidation = true;
              }
            }
            break;
          }
          case "Identifier": {
            const firstMatchingVariable = variableUtil.variablesInScope(context, node).find((variableInScope) => variableInScope.name === propTypes.name);
            if (firstMatchingVariable) {
              const defInScope = firstMatchingVariable.defs[firstMatchingVariable.defs.length - 1];
              markPropTypesAsDeclared(node, defInScope.node && defInScope.node.init, rootNode);
              return;
            }
            ignorePropsValidation = true;
            break;
          }
          case "CallExpression": {
            if (propWrapperUtil.isPropWrapperFunction(
              context,
              getText(context, propTypes.callee)
            ) && propTypes.arguments && propTypes.arguments[0]) {
              markPropTypesAsDeclared(node, propTypes.arguments[0], rootNode);
              return;
            }
            break;
          }
          case "IntersectionTypeAnnotation":
            ignorePropsValidation = declarePropTypesForIntersectionTypeAnnotation(propTypes, declaredPropTypes);
            break;
          case "GenericTypeAnnotation":
            if (propTypes.id.name === "$ReadOnly") {
              const propTypeParams = propTypes.typeParameters;
              ignorePropsValidation = declarePropTypesForObjectTypeAnnotation(
                propTypeParams.params[0],
                declaredPropTypes
              );
            } else {
              ignorePropsValidation = true;
            }
            break;
          case "TSTypeReference":
          case "TSTypeAnnotation":
            {
              const tsTypeAnnotation = new DeclarePropTypesForTSTypeAnnotation(propTypes, declaredPropTypes, rootNode);
              ignorePropsValidation = tsTypeAnnotation.shouldIgnorePropTypes;
              declaredPropTypes = tsTypeAnnotation.declaredPropTypes;
            }
            break;
          case null:
            break;
          default:
            ignorePropsValidation = true;
            break;
        }
        components.set(node, {
          declaredPropTypes,
          ignorePropsValidation
        });
      }
      function markAnnotatedFunctionArgumentsAsDeclared(node, rootNode) {
        if (!node.params || !node.params.length) {
          return;
        }
        if (node.parent && node.parent.callee && node.parent.typeParameters && node.parent.typeParameters.params && (node.parent.callee.name === "forwardRef" || node.parent.callee.object && node.parent.callee.property && node.parent.callee.object.name === "React" && node.parent.callee.property.name === "forwardRef")) {
          const propTypesParams = node.parent.typeParameters;
          const declaredPropTypes = {};
          const obj = new DeclarePropTypesForTSTypeAnnotation(propTypesParams.params[1], declaredPropTypes, rootNode);
          components.set(node, {
            declaredPropTypes: obj.declaredPropTypes,
            ignorePropsValidation: obj.shouldIgnorePropTypes
          });
          return;
        }
        const siblingIdentifier = node.parent && node.parent.id;
        const siblingHasTypeAnnotation = siblingIdentifier && siblingIdentifier.typeAnnotation;
        const isNodeAnnotated = annotations.isAnnotatedFunctionPropsDeclaration(node, context);
        if (!isNodeAnnotated && !siblingHasTypeAnnotation) {
          return;
        }
        if (isInsideClassBody(node) && !astUtil.isFunction(node)) {
          return;
        }
        if (!utils.isReturningJSXOrNull(node) || startWithCapitalizedLetter(node)) {
          return;
        }
        if (isNodeAnnotated) {
          const param = node.params[0];
          if (param.typeAnnotation && param.typeAnnotation.typeAnnotation && param.typeAnnotation.typeAnnotation.type === "UnionTypeAnnotation") {
            param.typeAnnotation.typeAnnotation.types.forEach((annotation) => {
              if (annotation.type === "GenericTypeAnnotation") {
                markPropTypesAsDeclared(node, resolveTypeAnnotation(annotation), rootNode);
              } else {
                markPropTypesAsDeclared(node, annotation, rootNode);
              }
            });
          } else {
            markPropTypesAsDeclared(node, resolveTypeAnnotation(param), rootNode);
          }
        } else {
          const annotation = siblingIdentifier.typeAnnotation.typeAnnotation;
          if (annotation && annotation.type !== "TSTypeReference" && annotation.typeParameters == null) {
            return;
          }
          if (!isValidReactGenericTypeAnnotation(annotation))
            return;
          markPropTypesAsDeclared(node, resolveTypeAnnotation(siblingIdentifier), rootNode);
        }
      }
      function resolveSuperParameterPropsType(node) {
        let propsParameterPosition;
        try {
          propsParameterPosition = testFlowVersion(context, ">= 0.53.0") ? 0 : 1;
        } catch (e) {
          propsParameterPosition = node.superTypeParameters.params.length <= 2 ? 0 : 1;
        }
        let annotation = node.superTypeParameters.params[propsParameterPosition];
        while (annotation && (annotation.type === "TypeAnnotation" || annotation.type === "NullableTypeAnnotation")) {
          annotation = annotation.typeAnnotation;
        }
        if (annotation && annotation.type === "GenericTypeAnnotation" && getInTypeScope(annotation.id.name)) {
          return getInTypeScope(annotation.id.name);
        }
        return annotation;
      }
      function isAnnotatedClassPropsDeclaration(node) {
        if (node && (node.type === "ClassProperty" || node.type === "PropertyDefinition")) {
          const tokens = getFirstTokens(context, node, 2);
          if (node.typeAnnotation && (tokens[0].value === "props" || tokens[1] && tokens[1].value === "props")) {
            return true;
          }
        }
        return false;
      }
      return {
        ClassExpression(node) {
          classExpressions.push(node);
        },
        ClassDeclaration(node) {
          if (isSuperTypeParameterPropsDeclaration(node)) {
            markPropTypesAsDeclared(node, resolveSuperParameterPropsType(node), node);
          }
        },
        "ClassProperty, PropertyDefinition"(node) {
          if (isAnnotatedClassPropsDeclaration(node)) {
            markPropTypesAsDeclared(node, resolveTypeAnnotation(node), node);
          } else if (propsUtil.isPropTypesDeclaration(node)) {
            markPropTypesAsDeclared(node, node.value, node);
          }
        },
        ObjectExpression(node) {
          node.properties.forEach((property) => {
            if (!propsUtil.isPropTypesDeclaration(property)) {
              return;
            }
            markPropTypesAsDeclared(node, property.value, node);
          });
        },
        FunctionExpression(node) {
          if (node.parent.type !== "MethodDefinition") {
            markAnnotatedFunctionArgumentsAsDeclared(node, node);
          }
        },
        ImportDeclaration(node) {
          if (node.source.value === "react") {
            node.specifiers.forEach((specifier) => {
              if (
                // handles import * as X from 'react'
                specifier.type === "ImportNamespaceSpecifier" || specifier.type === "ImportDefaultSpecifier"
              ) {
                genericReactTypesImport.add(specifier.local.name);
              }
              if (specifier.type === "ImportSpecifier" && allowedGenericTypes.has(specifier.imported.name)) {
                genericReactTypesImport.add(specifier.local.name);
                localToImportedMap[specifier.local.name] = specifier.imported.name;
              }
            });
          }
        },
        FunctionDeclaration: markAnnotatedFunctionArgumentsAsDeclared,
        ArrowFunctionExpression: markAnnotatedFunctionArgumentsAsDeclared,
        MemberExpression(node) {
          if (propsUtil.isPropTypesDeclaration(node)) {
            const component = utils.getRelatedComponent(node);
            if (!component) {
              return;
            }
            try {
              markPropTypesAsDeclared(component.node, node.parent.right || node.parent, node);
            } catch (e) {
              if (e.constructor !== RangeError) {
                throw e;
              }
            }
          }
        },
        MethodDefinition(node) {
          if (!node.static || node.kind !== "get" || !propsUtil.isPropTypesDeclaration(node)) {
            return;
          }
          let i = node.value.body.body.length - 1;
          for (; i >= 0; i--) {
            if (node.value.body.body[i].type === "ReturnStatement") {
              break;
            }
          }
          if (i >= 0) {
            markPropTypesAsDeclared(node, node.value.body.body[i].argument, node);
          }
        },
        TypeAlias(node) {
          setInTypeScope(node.id.name, node.right);
        },
        TypeParameterDeclaration(node) {
          const identifier = node.params[0];
          if (identifier.typeAnnotation) {
            setInTypeScope(identifier.name, identifier.typeAnnotation.typeAnnotation);
          }
        },
        Program() {
          stack = [{}];
        },
        BlockStatement() {
          stack.push(Object.create(typeScope()));
        },
        "BlockStatement:exit"() {
          stack.pop();
        },
        "Program:exit"() {
          classExpressions.forEach((node) => {
            if (isSuperTypeParameterPropsDeclaration(node)) {
              markPropTypesAsDeclared(node, resolveSuperParameterPropsType(node), node);
            }
          });
        }
      };
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/propName.js
var require_propName = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/propName.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = propName;
    function propName() {
      var prop = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!prop.type || prop.type !== "JSXAttribute") {
        throw new Error("The prop must be a JSXAttribute collected by the AST parser.");
      }
      if (prop.name.type === "JSXNamespacedName") {
        return prop.name.namespace.name + ":" + prop.name.name.name;
      }
      return prop.name.name;
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/hasProp.js
var require_hasProp = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/hasProp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = hasProp;
    exports.hasAnyProp = hasAnyProp;
    exports.hasEveryProp = hasEveryProp;
    var _propName = require_propName();
    var _propName2 = _interopRequireDefault(_propName);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DEFAULT_OPTIONS = {
      spreadStrict: true,
      ignoreCase: true
    };
    function hasProp() {
      var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var prop = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : DEFAULT_OPTIONS;
      var propToCheck = options.ignoreCase ? prop.toUpperCase() : prop;
      return props.some(function(attribute) {
        if (attribute.type === "JSXSpreadAttribute") {
          return !options.spreadStrict;
        }
        var currentProp = options.ignoreCase ? (0, _propName2.default)(attribute).toUpperCase() : (0, _propName2.default)(attribute);
        return propToCheck === currentProp;
      });
    }
    function hasAnyProp() {
      var nodeProps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : DEFAULT_OPTIONS;
      var propsToCheck = typeof props === "string" ? props.split(" ") : props;
      return propsToCheck.some(function(prop) {
        return hasProp(nodeProps, prop, options);
      });
    }
    function hasEveryProp() {
      var nodeProps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : DEFAULT_OPTIONS;
      var propsToCheck = typeof props === "string" ? props.split(" ") : props;
      return propsToCheck.every(function(prop) {
        return hasProp(nodeProps, prop, options);
      });
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/elementType.js
var require_elementType = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/elementType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = elementType;
    function resolveMemberExpressions() {
      var object = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var property = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (object.type === "JSXMemberExpression") {
        return resolveMemberExpressions(object.object, object.property) + "." + property.name;
      }
      return object.name + "." + property.name;
    }
    function elementType() {
      var node = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var name = node.name;
      if (node.type === "JSXOpeningFragment") {
        return "<>";
      }
      if (!name) {
        throw new Error("The argument provided is not a JSXElement node.");
      }
      if (name.type === "JSXMemberExpression") {
        var _name$object = name.object, object = _name$object === void 0 ? {} : _name$object, _name$property = name.property, property = _name$property === void 0 ? {} : _name$property;
        return resolveMemberExpressions(object, property);
      }
      if (name.type === "JSXNamespacedName") {
        return name.namespace.name + ":" + name.name.name;
      }
      return node.name.name;
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.flat@1.3.2/node_modules/array.prototype.flat/implementation.js
var require_implementation18 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.flat@1.3.2/node_modules/array.prototype.flat/implementation.js"(exports, module) {
    "use strict";
    var ArraySpeciesCreate = require_ArraySpeciesCreate();
    var FlattenIntoArray = require_FlattenIntoArray();
    var Get = require_Get2();
    var ToIntegerOrInfinity = require_ToIntegerOrInfinity();
    var ToLength = require_ToLength();
    var ToObject = require_ToObject2();
    module.exports = function flat() {
      var O = ToObject(this);
      var sourceLen = ToLength(Get(O, "length"));
      var depthNum = 1;
      if (arguments.length > 0 && typeof arguments[0] !== "undefined") {
        depthNum = ToIntegerOrInfinity(arguments[0]);
      }
      var A = ArraySpeciesCreate(O, 0);
      FlattenIntoArray(A, O, sourceLen, 0, depthNum);
      return A;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.flat@1.3.2/node_modules/array.prototype.flat/polyfill.js
var require_polyfill16 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.flat@1.3.2/node_modules/array.prototype.flat/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation18();
    module.exports = function getPolyfill() {
      return Array.prototype.flat || implementation;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.flat@1.3.2/node_modules/array.prototype.flat/shim.js
var require_shim16 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.flat@1.3.2/node_modules/array.prototype.flat/shim.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var shimUnscopables = require_es_shim_unscopables();
    var getPolyfill = require_polyfill16();
    module.exports = function shimFlat() {
      var polyfill = getPolyfill();
      define(
        Array.prototype,
        { flat: polyfill },
        { flat: function() {
          return Array.prototype.flat !== polyfill;
        } }
      );
      shimUnscopables("flat");
      return polyfill;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.flat@1.3.2/node_modules/array.prototype.flat/index.js
var require_array_prototype3 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.flat@1.3.2/node_modules/array.prototype.flat/index.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation18();
    var getPolyfill = require_polyfill16();
    var polyfill = getPolyfill();
    var shim = require_shim16();
    var boundFlat = callBind(polyfill);
    define(boundFlat, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = boundFlat;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/eventHandlers.js
var require_eventHandlers = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/eventHandlers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.eventHandlersByType = void 0;
    var _arrayPrototype = require_array_prototype3();
    var _arrayPrototype2 = _interopRequireDefault(_arrayPrototype);
    var _object = require_object3();
    var _object2 = _interopRequireDefault(_object);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var eventHandlersByType = {
      clipboard: ["onCopy", "onCut", "onPaste"],
      composition: ["onCompositionEnd", "onCompositionStart", "onCompositionUpdate"],
      keyboard: ["onKeyDown", "onKeyPress", "onKeyUp"],
      focus: ["onFocus", "onBlur"],
      form: ["onChange", "onInput", "onSubmit"],
      mouse: ["onClick", "onContextMenu", "onDblClick", "onDoubleClick", "onDrag", "onDragEnd", "onDragEnter", "onDragExit", "onDragLeave", "onDragOver", "onDragStart", "onDrop", "onMouseDown", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseOut", "onMouseOver", "onMouseUp"],
      selection: ["onSelect"],
      touch: ["onTouchCancel", "onTouchEnd", "onTouchMove", "onTouchStart"],
      ui: ["onScroll"],
      wheel: ["onWheel"],
      media: ["onAbort", "onCanPlay", "onCanPlayThrough", "onDurationChange", "onEmptied", "onEncrypted", "onEnded", "onError", "onLoadedData", "onLoadedMetadata", "onLoadStart", "onPause", "onPlay", "onPlaying", "onProgress", "onRateChange", "onSeeked", "onSeeking", "onStalled", "onSuspend", "onTimeUpdate", "onVolumeChange", "onWaiting"],
      image: ["onLoad", "onError"],
      animation: ["onAnimationStart", "onAnimationEnd", "onAnimationIteration"],
      transition: ["onTransitionEnd"]
    };
    exports.default = (0, _arrayPrototype2.default)((0, _object2.default)(eventHandlersByType));
    exports.eventHandlersByType = eventHandlersByType;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/getProp.js
var require_getProp = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/getProp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _slicedToArray = /* @__PURE__ */ function() {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"])
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
    var _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    exports.default = getProp;
    var _propName = require_propName();
    var _propName2 = _interopRequireDefault(_propName);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _objectWithoutProperties(obj, keys) {
      var target = {};
      for (var i in obj) {
        if (keys.indexOf(i) >= 0)
          continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i))
          continue;
        target[i] = obj[i];
      }
      return target;
    }
    var DEFAULT_OPTIONS = {
      ignoreCase: true
    };
    function getProp() {
      var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var prop = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : DEFAULT_OPTIONS;
      function getName(name) {
        return options.ignoreCase ? name.toUpperCase() : name;
      }
      var propToFind = getName(prop);
      function isPropToFind(property) {
        return property.type === "Property" && property.key.type === "Identifier" && propToFind === getName(property.key.name);
      }
      var foundAttribute = props.find(function(attribute) {
        if (attribute.type === "JSXSpreadAttribute") {
          return attribute.argument.type === "ObjectExpression" && propToFind !== getName("key") && attribute.argument.properties.some(isPropToFind);
        }
        return propToFind === getName((0, _propName2.default)(attribute));
      });
      if (foundAttribute && foundAttribute.type === "JSXSpreadAttribute") {
        return propertyToJSXAttribute(foundAttribute.argument.properties.find(isPropToFind));
      }
      return foundAttribute;
    }
    function propertyToJSXAttribute(node) {
      var key = node.key, value = node.value;
      return _extends({
        type: "JSXAttribute",
        name: _extends({ type: "JSXIdentifier", name: key.name }, getBaseProps(key)),
        value: value.type === "Literal" ? adjustRangeOfNode(value) : _extends({ type: "JSXExpressionContainer", expression: adjustExpressionRange(value) }, getBaseProps(value))
      }, getBaseProps(node));
    }
    function adjustRangeOfNode(node) {
      var _ref = node.range || [node.start, node.end], _ref2 = _slicedToArray(_ref, 2), start = _ref2[0], end = _ref2[1];
      return _extends({}, node, {
        end: void 0,
        range: [start, end],
        start: void 0
      });
    }
    function adjustExpressionRange(_ref3) {
      var expressions = _ref3.expressions, quasis = _ref3.quasis, expression = _objectWithoutProperties(_ref3, ["expressions", "quasis"]);
      return _extends({}, adjustRangeOfNode(expression), expressions ? { expressions: expressions.map(adjustRangeOfNode) } : {}, quasis ? { quasis: quasis.map(adjustRangeOfNode) } : {});
    }
    function getBaseProps(_ref4) {
      var loc = _ref4.loc, node = _objectWithoutProperties(_ref4, ["loc"]);
      var _adjustRangeOfNode = adjustRangeOfNode(node), range = _adjustRangeOfNode.range;
      return {
        loc: getBaseLocation(loc),
        range
      };
    }
    function getBaseLocation(_ref5) {
      var start = _ref5.start, end = _ref5.end, source = _ref5.source, filename = _ref5.filename;
      return _extends({
        start,
        end
      }, source !== void 0 ? { source } : {}, filename !== void 0 ? { filename } : {});
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/Literal.js
var require_Literal = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/Literal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = extractValueFromLiteral;
    function extractValueFromLiteral(value) {
      var extractedValue = value.value;
      var normalizedStringValue = typeof extractedValue === "string" && extractedValue.toLowerCase();
      if (normalizedStringValue === "true") {
        return true;
      }
      if (normalizedStringValue === "false") {
        return false;
      }
      return extractedValue;
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/JSXElement.js
var require_JSXElement = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/JSXElement.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = extractValueFromJSXElement;
    function extractValueFromJSXElement(value) {
      var getValue = require_values().default;
      var Tag = value.openingElement.name.name;
      if (value.openingElement.selfClosing) {
        return "<" + Tag + " />";
      }
      return "<" + Tag + ">" + [].concat(value.children).map(function(x) {
        return getValue(x);
      }).join("") + "</" + Tag + ">";
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/JSXText.js
var require_JSXText = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/JSXText.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = extractValueFromJSXText;
    function extractValueFromJSXText(value) {
      return value.raw;
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/JSXFragment.js
var require_JSXFragment = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/JSXFragment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = extractValueFromJSXFragment;
    function extractValueFromJSXFragment(value) {
      var getValue = require_values().default;
      if (value.children.length === 0) {
        return "<></>";
      }
      return "<>" + [].concat(value.children).map(function(x) {
        return getValue(x);
      }).join("") + "</>";
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/Identifier.js
var require_Identifier = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/Identifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = extractValueFromIdentifier;
    var JS_RESERVED = {
      Array,
      Date,
      Infinity: Infinity,
      Math,
      Number,
      Object,
      String,
      undefined: void 0
    };
    function extractValueFromIdentifier(value) {
      var name = value.name;
      if (Object.hasOwnProperty.call(JS_RESERVED, name)) {
        return JS_RESERVED[name];
      }
      return name;
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/TemplateLiteral.js
var require_TemplateLiteral = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/TemplateLiteral.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = extractValueFromTemplateLiteral;
    function sortStarts(a, b) {
      return (a.range ? a.range[0] : a.start) - (b.range ? b.range[0] : b.start);
    }
    function extractValueFromTemplateLiteral(value) {
      var quasis = value.quasis, expressions = value.expressions;
      var partitions = quasis.concat(expressions);
      return partitions.sort(sortStarts).map(function(_ref) {
        var type = _ref.type, _ref$value = _ref.value;
        _ref$value = _ref$value === void 0 ? {} : _ref$value;
        var raw = _ref$value.raw, name = _ref.name;
        if (type === "TemplateElement") {
          return raw;
        }
        if (type === "Identifier") {
          return name === "undefined" ? name : "{" + name + "}";
        }
        if (type.indexOf("Expression") > -1) {
          return "{" + type + "}";
        }
        return "";
      }).join("");
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/TaggedTemplateExpression.js
var require_TaggedTemplateExpression = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/TaggedTemplateExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = extractValueFromTaggedTemplateExpression;
    var _TemplateLiteral = require_TemplateLiteral();
    var _TemplateLiteral2 = _interopRequireDefault(_TemplateLiteral);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function extractValueFromTaggedTemplateExpression(value) {
      return (0, _TemplateLiteral2.default)(value.quasi);
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/FunctionExpression.js
var require_FunctionExpression = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/FunctionExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = extractValueFromFunctionExpression;
    function extractValueFromFunctionExpression(value) {
      return function() {
        return value;
      };
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/LogicalExpression.js
var require_LogicalExpression = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/LogicalExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = extractValueFromLogicalExpression;
    function extractValueFromLogicalExpression(value) {
      var getValue = require_expressions().default;
      var operator = value.operator, left = value.left, right = value.right;
      var leftVal = getValue(left);
      var rightVal = getValue(right);
      if (operator === "&&") {
        return leftVal && rightVal;
      }
      if (operator === "??") {
        return leftVal === null || typeof leftVal === "undefined" ? rightVal : leftVal;
      }
      return leftVal || rightVal;
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/MemberExpression.js
var require_MemberExpression = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/MemberExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = extractValueFromMemberExpression;
    function extractValueFromMemberExpression(value) {
      var getValue = require_expressions().default;
      return "" + getValue(value.object) + (value.optional ? "?." : ".") + getValue(value.property);
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/ChainExpression.js
var require_ChainExpression = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/ChainExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = extractValueFromChainExpression;
    function extractValueFromChainExpression(value) {
      var getValue = require_expressions().default;
      return getValue(value.expression || value);
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/OptionalCallExpression.js
var require_OptionalCallExpression = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/OptionalCallExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = extractValueFromOptionalCallExpression;
    function extractValueFromOptionalCallExpression(value) {
      var getValue = require_expressions().default;
      return getValue(value.callee) + "?.(" + value.arguments.map(function(x) {
        return getValue(x);
      }).join(", ") + ")";
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/OptionalMemberExpression.js
var require_OptionalMemberExpression = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/OptionalMemberExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = extractValueFromOptionalMemberExpression;
    function extractValueFromOptionalMemberExpression(value) {
      var getValue = require_expressions().default;
      return getValue(value.object) + "?." + getValue(value.property);
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/CallExpression.js
var require_CallExpression = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/CallExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = extractValueFromCallExpression;
    function extractValueFromCallExpression(value) {
      var getValue = require_expressions().default;
      var args = Array.isArray(value.arguments) ? value.arguments.map(function(x) {
        return getValue(x);
      }).join(", ") : "";
      return "" + getValue(value.callee) + (value.optional ? "?." : "") + "(" + args + ")";
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/UnaryExpression.js
var require_UnaryExpression = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/UnaryExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = extractValueFromUnaryExpression;
    function extractValueFromUnaryExpression(value) {
      var getValue = require_expressions().default;
      var operator = value.operator, argument = value.argument;
      switch (operator) {
        case "-":
          return -getValue(argument);
        case "+":
          return +getValue(argument);
        case "!":
          return !getValue(argument);
        case "~":
          return ~getValue(argument);
        case "delete":
          return true;
        case "typeof":
        case "void":
        default:
          return void 0;
      }
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/ThisExpression.js
var require_ThisExpression = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/ThisExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = extractValueFromThisExpression;
    function extractValueFromThisExpression() {
      return "this";
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/ConditionalExpression.js
var require_ConditionalExpression = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/ConditionalExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = extractValueFromConditionalExpression;
    function extractValueFromConditionalExpression(value) {
      var getValue = require_expressions().default;
      var test = value.test, alternate = value.alternate, consequent = value.consequent;
      return getValue(test) ? getValue(consequent) : getValue(alternate);
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/BinaryExpression.js
var require_BinaryExpression = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/BinaryExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = extractValueFromBinaryExpression;
    function extractValueFromBinaryExpression(value) {
      var getValue = require_expressions().default;
      var operator = value.operator, left = value.left, right = value.right;
      var leftVal = getValue(left);
      var rightVal = getValue(right);
      switch (operator) {
        case "==":
          return leftVal == rightVal;
        case "!=":
          return leftVal != rightVal;
        case "===":
          return leftVal === rightVal;
        case "!==":
          return leftVal !== rightVal;
        case "<":
          return leftVal < rightVal;
        case "<=":
          return leftVal <= rightVal;
        case ">":
          return leftVal > rightVal;
        case ">=":
          return leftVal >= rightVal;
        case "<<":
          return leftVal << rightVal;
        case ">>":
          return leftVal >> rightVal;
        case ">>>":
          return leftVal >>> rightVal;
        case "+":
          return leftVal + rightVal;
        case "-":
          return leftVal - rightVal;
        case "*":
          return leftVal * rightVal;
        case "/":
          return leftVal / rightVal;
        case "%":
          return leftVal % rightVal;
        case "|":
          return leftVal | rightVal;
        case "^":
          return leftVal ^ rightVal;
        case "&":
          return leftVal & rightVal;
        case "in":
          try {
            return leftVal in rightVal;
          } catch (err) {
            return false;
          }
        case "instanceof":
          if (typeof rightVal !== "function") {
            return false;
          }
          return leftVal instanceof rightVal;
        default:
          return void 0;
      }
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.assign@4.1.5/node_modules/object.assign/implementation.js
var require_implementation19 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.assign@4.1.5/node_modules/object.assign/implementation.js"(exports, module) {
    "use strict";
    var objectKeys = require_object_keys();
    var hasSymbols = require_shams()();
    var callBound = require_callBound();
    var toObject = Object;
    var $push = callBound("Array.prototype.push");
    var $propIsEnumerable = callBound("Object.prototype.propertyIsEnumerable");
    var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;
    module.exports = function assign(target, source1) {
      if (target == null) {
        throw new TypeError("target must be an object");
      }
      var to = toObject(target);
      if (arguments.length === 1) {
        return to;
      }
      for (var s = 1; s < arguments.length; ++s) {
        var from = toObject(arguments[s]);
        var keys = objectKeys(from);
        var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
        if (getSymbols) {
          var syms = getSymbols(from);
          for (var j = 0; j < syms.length; ++j) {
            var key = syms[j];
            if ($propIsEnumerable(from, key)) {
              $push(keys, key);
            }
          }
        }
        for (var i = 0; i < keys.length; ++i) {
          var nextKey = keys[i];
          if ($propIsEnumerable(from, nextKey)) {
            var propValue = from[nextKey];
            to[nextKey] = propValue;
          }
        }
      }
      return to;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.assign@4.1.5/node_modules/object.assign/polyfill.js
var require_polyfill17 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.assign@4.1.5/node_modules/object.assign/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation19();
    var lacksProperEnumerationOrder = function() {
      if (!Object.assign) {
        return false;
      }
      var str = "abcdefghijklmnopqrst";
      var letters = str.split("");
      var map = {};
      for (var i = 0; i < letters.length; ++i) {
        map[letters[i]] = letters[i];
      }
      var obj = Object.assign({}, map);
      var actual = "";
      for (var k in obj) {
        actual += k;
      }
      return str !== actual;
    };
    var assignHasPendingExceptions = function() {
      if (!Object.assign || !Object.preventExtensions) {
        return false;
      }
      var thrower = Object.preventExtensions({ 1: 2 });
      try {
        Object.assign(thrower, "xy");
      } catch (e) {
        return thrower[1] === "y";
      }
      return false;
    };
    module.exports = function getPolyfill() {
      if (!Object.assign) {
        return implementation;
      }
      if (lacksProperEnumerationOrder()) {
        return implementation;
      }
      if (assignHasPendingExceptions()) {
        return implementation;
      }
      return Object.assign;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.assign@4.1.5/node_modules/object.assign/shim.js
var require_shim17 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.assign@4.1.5/node_modules/object.assign/shim.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var getPolyfill = require_polyfill17();
    module.exports = function shimAssign() {
      var polyfill = getPolyfill();
      define(
        Object,
        { assign: polyfill },
        { assign: function() {
          return Object.assign !== polyfill;
        } }
      );
      return polyfill;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.assign@4.1.5/node_modules/object.assign/index.js
var require_object4 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.assign@4.1.5/node_modules/object.assign/index.js"(exports, module) {
    "use strict";
    var defineProperties = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation19();
    var getPolyfill = require_polyfill17();
    var shim = require_shim17();
    var polyfill = callBind.apply(getPolyfill());
    var bound = function assign(target, source1) {
      return polyfill(Object, arguments);
    };
    defineProperties(bound, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = bound;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/ObjectExpression.js
var require_ObjectExpression = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/ObjectExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = extractValueFromObjectExpression;
    var _object = require_object4();
    var _object2 = _interopRequireDefault(_object);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function extractValueFromObjectExpression(value) {
      var getValue = require_expressions().default;
      return value.properties.reduce(function(obj, property) {
        if (/^(?:Experimental)?Spread(?:Property|Element)$/.test(property.type)) {
          if (property.argument.type === "ObjectExpression") {
            return (0, _object2.default)({}, obj, extractValueFromObjectExpression(property.argument));
          }
        } else {
          return (0, _object2.default)({}, obj, _defineProperty({}, getValue(property.key), getValue(property.value)));
        }
        return obj;
      }, {});
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/NewExpression.js
var require_NewExpression = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/NewExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = extractValueFromNewExpression;
    function extractValueFromNewExpression() {
      return new Object();
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/UpdateExpression.js
var require_UpdateExpression = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/UpdateExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = extractValueFromUpdateExpression;
    function extractValueFromUpdateExpression(value) {
      var getValue = require_expressions().default;
      var operator = value.operator, argument = value.argument, prefix = value.prefix;
      var val = getValue(argument);
      switch (operator) {
        case "++":
          return prefix ? ++val : val++;
        case "--":
          return prefix ? --val : val--;
        default:
          return void 0;
      }
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/ArrayExpression.js
var require_ArrayExpression = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/ArrayExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = extractValueFromArrayExpression;
    function extractValueFromArrayExpression(value) {
      var getValue = require_expressions().default;
      return value.elements.map(function(element) {
        if (element === null)
          return void 0;
        return getValue(element);
      });
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/BindExpression.js
var require_BindExpression = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/BindExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = extractValueFromBindExpression;
    function extractValueFromBindExpression(value) {
      var getValue = require_expressions().default;
      var callee = getValue(value.callee);
      var object = value.object === null ? getValue(value.callee.object) : getValue(value.object);
      if (value.object && value.object.property) {
        return object + "." + callee + ".bind(" + object + ")";
      }
      return callee + ".bind(" + object + ")";
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/SpreadElement.js
var require_SpreadElement = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/SpreadElement.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = extractValueFromSpreadElement;
    function extractValueFromSpreadElement() {
      return void 0;
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/TypeCastExpression.js
var require_TypeCastExpression = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/TypeCastExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = extractValueFromTypeCastExpression;
    function extractValueFromTypeCastExpression(value) {
      var getValue = require_expressions().default;
      return getValue(value.expression);
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/SequenceExpression.js
var require_SequenceExpression = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/SequenceExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = extractValueFromSequenceExpression;
    function extractValueFromSequenceExpression(value) {
      var getValue = require_expressions().default;
      return value.expressions.map(function(element) {
        return getValue(element);
      });
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/TSNonNullExpression.js
var require_TSNonNullExpression = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/TSNonNullExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = extractValueFromTSNonNullExpression;
    var extractValueFromThisExpression = require_ThisExpression().default;
    var extractValueFromCallExpression = require_CallExpression().default;
    function navigate(obj, prop, value) {
      if (value.computed) {
        return value.optional ? obj + "?.[" + prop + "]" : obj + "[" + prop + "]";
      }
      return value.optional ? obj + "?." + prop : obj + "." + prop;
    }
    function extractValueFromTSNonNullExpression(value) {
      var errorMessage = "The prop value with an expression type of TSNonNullExpression could not be resolved. Please file an issue ( https://github.com/jsx-eslint/jsx-ast-utils/issues/new ) to get this fixed immediately.";
      if (value.type === "Identifier") {
        var name = value.name;
        return name;
      }
      if (value.type === "Literal") {
        return value.value;
      }
      if (value.type === "TSAsExpression") {
        return extractValueFromTSNonNullExpression(value.expression);
      }
      if (value.type === "CallExpression") {
        return extractValueFromCallExpression(value);
      }
      if (value.type === "ThisExpression") {
        return extractValueFromThisExpression();
      }
      if (value.type === "TSNonNullExpression" && (!value.extra || value.extra.parenthesized === false)) {
        var expression = value.expression;
        return extractValueFromTSNonNullExpression(expression) + "!";
      }
      if (value.type === "TSNonNullExpression" && value.extra && value.extra.parenthesized === true) {
        var _expression = value.expression;
        return "(" + extractValueFromTSNonNullExpression(_expression) + "!)";
      }
      if (value.type === "MemberExpression") {
        if (!value.extra || value.extra.parenthesized === false) {
          return navigate(extractValueFromTSNonNullExpression(value.object), extractValueFromTSNonNullExpression(value.property), value);
        }
        if (value.extra && value.extra.parenthesized === true) {
          var result = navigate(extractValueFromTSNonNullExpression(value.object), extractValueFromTSNonNullExpression(value.property), value);
          return "(" + result + ")";
        }
      }
      if (value.expression) {
        var _expression2 = value.expression;
        while (_expression2) {
          if (_expression2.type === "Identifier") {
            console.error(errorMessage);
            return _expression2.name;
          }
          var _expression3 = _expression2;
          _expression2 = _expression3.expression;
        }
      }
      console.error(errorMessage);
      return "";
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/AssignmentExpression.js
var require_AssignmentExpression = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/AssignmentExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = extractValueFromAssignmentExpression;
    function extractValueFromAssignmentExpression(value) {
      var getValue = require_expressions().default;
      return getValue(value.left) + " " + value.operator + " " + getValue(value.right);
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/index.js
var require_expressions = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/expressions/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    exports.default = extract;
    exports.extractLiteral = extractLiteral;
    var _Literal = require_Literal();
    var _Literal2 = _interopRequireDefault(_Literal);
    var _JSXElement = require_JSXElement();
    var _JSXElement2 = _interopRequireDefault(_JSXElement);
    var _JSXFragment = require_JSXFragment();
    var _JSXFragment2 = _interopRequireDefault(_JSXFragment);
    var _JSXText = require_JSXText();
    var _JSXText2 = _interopRequireDefault(_JSXText);
    var _Identifier = require_Identifier();
    var _Identifier2 = _interopRequireDefault(_Identifier);
    var _TaggedTemplateExpression = require_TaggedTemplateExpression();
    var _TaggedTemplateExpression2 = _interopRequireDefault(_TaggedTemplateExpression);
    var _TemplateLiteral = require_TemplateLiteral();
    var _TemplateLiteral2 = _interopRequireDefault(_TemplateLiteral);
    var _FunctionExpression = require_FunctionExpression();
    var _FunctionExpression2 = _interopRequireDefault(_FunctionExpression);
    var _LogicalExpression = require_LogicalExpression();
    var _LogicalExpression2 = _interopRequireDefault(_LogicalExpression);
    var _MemberExpression = require_MemberExpression();
    var _MemberExpression2 = _interopRequireDefault(_MemberExpression);
    var _ChainExpression = require_ChainExpression();
    var _ChainExpression2 = _interopRequireDefault(_ChainExpression);
    var _OptionalCallExpression = require_OptionalCallExpression();
    var _OptionalCallExpression2 = _interopRequireDefault(_OptionalCallExpression);
    var _OptionalMemberExpression = require_OptionalMemberExpression();
    var _OptionalMemberExpression2 = _interopRequireDefault(_OptionalMemberExpression);
    var _CallExpression = require_CallExpression();
    var _CallExpression2 = _interopRequireDefault(_CallExpression);
    var _UnaryExpression = require_UnaryExpression();
    var _UnaryExpression2 = _interopRequireDefault(_UnaryExpression);
    var _ThisExpression = require_ThisExpression();
    var _ThisExpression2 = _interopRequireDefault(_ThisExpression);
    var _ConditionalExpression = require_ConditionalExpression();
    var _ConditionalExpression2 = _interopRequireDefault(_ConditionalExpression);
    var _BinaryExpression = require_BinaryExpression();
    var _BinaryExpression2 = _interopRequireDefault(_BinaryExpression);
    var _ObjectExpression = require_ObjectExpression();
    var _ObjectExpression2 = _interopRequireDefault(_ObjectExpression);
    var _NewExpression = require_NewExpression();
    var _NewExpression2 = _interopRequireDefault(_NewExpression);
    var _UpdateExpression = require_UpdateExpression();
    var _UpdateExpression2 = _interopRequireDefault(_UpdateExpression);
    var _ArrayExpression = require_ArrayExpression();
    var _ArrayExpression2 = _interopRequireDefault(_ArrayExpression);
    var _BindExpression = require_BindExpression();
    var _BindExpression2 = _interopRequireDefault(_BindExpression);
    var _SpreadElement = require_SpreadElement();
    var _SpreadElement2 = _interopRequireDefault(_SpreadElement);
    var _TypeCastExpression = require_TypeCastExpression();
    var _TypeCastExpression2 = _interopRequireDefault(_TypeCastExpression);
    var _SequenceExpression = require_SequenceExpression();
    var _SequenceExpression2 = _interopRequireDefault(_SequenceExpression);
    var _TSNonNullExpression = require_TSNonNullExpression();
    var _TSNonNullExpression2 = _interopRequireDefault(_TSNonNullExpression);
    var _AssignmentExpression = require_AssignmentExpression();
    var _AssignmentExpression2 = _interopRequireDefault(_AssignmentExpression);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var TYPES = {
      Identifier: _Identifier2.default,
      Literal: _Literal2.default,
      JSXElement: _JSXElement2.default,
      JSXFragment: _JSXFragment2.default,
      JSXText: _JSXText2.default,
      TaggedTemplateExpression: _TaggedTemplateExpression2.default,
      TemplateLiteral: _TemplateLiteral2.default,
      ArrowFunctionExpression: _FunctionExpression2.default,
      FunctionExpression: _FunctionExpression2.default,
      LogicalExpression: _LogicalExpression2.default,
      MemberExpression: _MemberExpression2.default,
      ChainExpression: _ChainExpression2.default,
      OptionalCallExpression: _OptionalCallExpression2.default,
      OptionalMemberExpression: _OptionalMemberExpression2.default,
      CallExpression: _CallExpression2.default,
      UnaryExpression: _UnaryExpression2.default,
      ThisExpression: _ThisExpression2.default,
      ConditionalExpression: _ConditionalExpression2.default,
      BinaryExpression: _BinaryExpression2.default,
      ObjectExpression: _ObjectExpression2.default,
      NewExpression: _NewExpression2.default,
      UpdateExpression: _UpdateExpression2.default,
      ArrayExpression: _ArrayExpression2.default,
      BindExpression: _BindExpression2.default,
      SpreadElement: _SpreadElement2.default,
      TypeCastExpression: _TypeCastExpression2.default,
      SequenceExpression: _SequenceExpression2.default,
      TSNonNullExpression: _TSNonNullExpression2.default,
      AssignmentExpression: _AssignmentExpression2.default
    };
    var noop = function noop2() {
      return null;
    };
    var errorMessage = function errorMessage2(expression) {
      return "The prop value with an expression type of " + expression + " could not be resolved. Please file an issue ( https://github.com/jsx-eslint/jsx-ast-utils/issues/new ) to get this fixed immediately.";
    };
    function extract(value) {
      var expression = void 0;
      if (typeof value.expression !== "boolean" && value.expression) {
        expression = value.expression;
      } else {
        expression = value;
      }
      var _expression = expression, type = _expression.type;
      if (expression.object && expression.object.type === "TSNonNullExpression") {
        type = "TSNonNullExpression";
      }
      while (type === "TSAsExpression") {
        var _expression2 = expression;
        type = _expression2.type;
        if (expression.expression) {
          var _expression3 = expression;
          expression = _expression3.expression;
        }
      }
      if (TYPES[type] === void 0) {
        console.error(errorMessage(type));
        return null;
      }
      return TYPES[type](expression);
    }
    var LITERAL_TYPES = _extends({}, TYPES, {
      Literal: function Literal(value) {
        var extractedVal = TYPES.Literal.call(void 0, value);
        var isNull = extractedVal === null;
        return isNull ? "null" : extractedVal;
      },
      Identifier: function Identifier(value) {
        var isUndefined = TYPES.Identifier.call(void 0, value) === void 0;
        return isUndefined ? void 0 : null;
      },
      JSXElement: noop,
      JSXFragment: noop,
      JSXText: noop,
      ArrowFunctionExpression: noop,
      FunctionExpression: noop,
      LogicalExpression: noop,
      MemberExpression: noop,
      OptionalCallExpression: noop,
      OptionalMemberExpression: noop,
      CallExpression: noop,
      UnaryExpression: function UnaryExpression(value) {
        var extractedVal = TYPES.UnaryExpression.call(void 0, value);
        return extractedVal === void 0 ? null : extractedVal;
      },
      UpdateExpression: function UpdateExpression(value) {
        var extractedVal = TYPES.UpdateExpression.call(void 0, value);
        return extractedVal === void 0 ? null : extractedVal;
      },
      ThisExpression: noop,
      ConditionalExpression: noop,
      BinaryExpression: noop,
      ObjectExpression: noop,
      NewExpression: noop,
      ArrayExpression: function ArrayExpression(value) {
        var extractedVal = TYPES.ArrayExpression.call(void 0, value);
        return extractedVal.filter(function(val) {
          return val !== null;
        });
      },
      BindExpression: noop,
      SpreadElement: noop,
      TSNonNullExpression: noop,
      TSAsExpression: noop,
      TypeCastExpression: noop,
      SequenceExpression: noop,
      ChainExpression: noop
    });
    function extractLiteral(value) {
      var expression = value.expression || value;
      var type = expression.type;
      if (LITERAL_TYPES[type] === void 0) {
        console.error(errorMessage(type));
        return null;
      }
      return LITERAL_TYPES[type](expression);
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/index.js
var require_values = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/values/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    exports.default = getValue;
    exports.getLiteralValue = getLiteralValue;
    var _Literal = require_Literal();
    var _Literal2 = _interopRequireDefault(_Literal);
    var _JSXElement = require_JSXElement();
    var _JSXElement2 = _interopRequireDefault(_JSXElement);
    var _JSXText = require_JSXText();
    var _JSXText2 = _interopRequireDefault(_JSXText);
    var _JSXFragment = require_JSXFragment();
    var _JSXFragment2 = _interopRequireDefault(_JSXFragment);
    var _expressions = require_expressions();
    var _expressions2 = _interopRequireDefault(_expressions);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var TYPES = {
      Literal: _Literal2.default,
      JSXElement: _JSXElement2.default,
      JSXExpressionContainer: _expressions2.default,
      JSXText: _JSXText2.default,
      JSXFragment: _JSXFragment2.default
    };
    var LITERAL_TYPES = _extends({}, TYPES, {
      JSXElement: function JSXElement() {
        return null;
      },
      JSXExpressionContainer: _expressions.extractLiteral
    });
    function getValue(value) {
      if (!TYPES[value.type])
        console.log(value.type);
      return TYPES[value.type](value);
    }
    function getLiteralValue(value) {
      return LITERAL_TYPES[value.type](value);
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/getPropValue.js
var require_getPropValue = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/getPropValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = getPropValue;
    exports.getLiteralPropValue = getLiteralPropValue;
    var _values = require_values();
    var _values2 = _interopRequireDefault(_values);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var extractValue = function extractValue2(attribute, extractor) {
      if (attribute && attribute.type === "JSXAttribute") {
        if (attribute.value === null) {
          return true;
        }
        return extractor(attribute.value);
      }
      return void 0;
    };
    function getPropValue(attribute) {
      return extractValue(attribute, _values2.default);
    }
    function getLiteralPropValue(attribute) {
      return extractValue(attribute, _values.getLiteralValue);
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/index.js
var require_lib = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/lib/index.js"(exports, module) {
    "use strict";
    var _hasProp = require_hasProp();
    var _hasProp2 = _interopRequireDefault(_hasProp);
    var _elementType = require_elementType();
    var _elementType2 = _interopRequireDefault(_elementType);
    var _eventHandlers = require_eventHandlers();
    var _eventHandlers2 = _interopRequireDefault(_eventHandlers);
    var _getProp = require_getProp();
    var _getProp2 = _interopRequireDefault(_getProp);
    var _getPropValue = require_getPropValue();
    var _getPropValue2 = _interopRequireDefault(_getPropValue);
    var _propName = require_propName();
    var _propName2 = _interopRequireDefault(_propName);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    module.exports = {
      hasProp: _hasProp2.default,
      hasAnyProp: _hasProp.hasAnyProp,
      hasEveryProp: _hasProp.hasEveryProp,
      elementType: _elementType2.default,
      eventHandlers: _eventHandlers2.default,
      eventHandlersByType: _eventHandlers.eventHandlersByType,
      getProp: _getProp2.default,
      getPropValue: _getPropValue2.default,
      getLiteralPropValue: _getPropValue.getLiteralPropValue,
      propName: _propName2.default
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/elementType.js
var require_elementType2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/elementType.js"(exports, module) {
    module.exports = require_lib().elementType;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/isDestructuredFromPragmaImport.js
var require_isDestructuredFromPragmaImport = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/isDestructuredFromPragmaImport.js"(exports, module) {
    "use strict";
    var pragmaUtil = require_pragma();
    var variableUtil = require_variable();
    module.exports = function isDestructuredFromPragmaImport(context, node, variable) {
      const pragma = pragmaUtil.getFromContext(context);
      const variables = variableUtil.variablesInScope(context, node);
      const variableInScope = variableUtil.getVariable(variables, variable);
      if (variableInScope) {
        const latestDef = variableUtil.getLatestVariableDefinition(variableInScope);
        if (latestDef) {
          if (latestDef.node.type === "VariableDeclarator" && latestDef.node.init) {
            if (latestDef.node.init.type === "MemberExpression" && latestDef.node.init.object.type === "Identifier" && latestDef.node.init.object.name === pragma) {
              return true;
            }
            if (latestDef.node.init.type === "Identifier" && latestDef.node.init.name === pragma) {
              return true;
            }
            let requireExpression = null;
            if (latestDef.node.init.type === "CallExpression") {
              requireExpression = latestDef.node.init;
            }
            if (!requireExpression && latestDef.node.init.type === "MemberExpression" && latestDef.node.init.object.type === "CallExpression") {
              requireExpression = latestDef.node.init.object;
            }
            if (requireExpression && requireExpression.callee && requireExpression.callee.name === "require" && requireExpression.arguments[0] && requireExpression.arguments[0].value === pragma.toLocaleLowerCase()) {
              return true;
            }
            return false;
          }
          if (latestDef.parent && latestDef.parent.type === "ImportDeclaration" && latestDef.parent.source.value === pragma.toLocaleLowerCase()) {
            return true;
          }
        }
      }
      return false;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/isCreateElement.js
var require_isCreateElement = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/isCreateElement.js"(exports, module) {
    "use strict";
    var pragmaUtil = require_pragma();
    var isDestructuredFromPragmaImport = require_isDestructuredFromPragmaImport();
    module.exports = function isCreateElement(context, node) {
      if (node.callee && node.callee.type === "MemberExpression" && node.callee.property.name === "createElement" && node.callee.object && node.callee.object.name === pragmaUtil.getFromContext(context)) {
        return true;
      }
      if (node && node.callee && node.callee.name === "createElement" && isDestructuredFromPragmaImport(context, node, "createElement")) {
        return true;
      }
      return false;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/jsx.js
var require_jsx = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/jsx.js"(exports, module) {
    "use strict";
    var elementType = require_elementType2();
    var astUtil = require_ast();
    var isCreateElement = require_isCreateElement();
    var variableUtil = require_variable();
    var COMPAT_TAG_REGEX = /^[a-z]/;
    function isDOMComponent(node) {
      const name = elementType(node);
      return COMPAT_TAG_REGEX.test(name);
    }
    function isFragment(node, reactPragma, fragmentPragma) {
      const name = node.openingElement.name;
      if (name.type === "JSXIdentifier" && name.name === fragmentPragma) {
        return true;
      }
      if (name.type === "JSXMemberExpression" && name.object.type === "JSXIdentifier" && name.object.name === reactPragma && name.property.type === "JSXIdentifier" && name.property.name === fragmentPragma) {
        return true;
      }
      return false;
    }
    function isJSX(node) {
      return node && ["JSXElement", "JSXFragment"].indexOf(node.type) >= 0;
    }
    function isJSXAttributeKey(node) {
      return node.type === "JSXAttribute" && node.name && node.name.type === "JSXIdentifier" && node.name.name === "key";
    }
    function isWhiteSpaces(value) {
      return typeof value === "string" ? /^\s*$/.test(value) : false;
    }
    function isReturningJSX(context, ASTnode, strict, ignoreNull) {
      const isJSXValue = (node) => {
        if (!node) {
          return false;
        }
        switch (node.type) {
          case "ConditionalExpression":
            if (strict) {
              return isJSXValue(node.consequent) && isJSXValue(node.alternate);
            }
            return isJSXValue(node.consequent) || isJSXValue(node.alternate);
          case "LogicalExpression":
            if (strict) {
              return isJSXValue(node.left) && isJSXValue(node.right);
            }
            return isJSXValue(node.left) || isJSXValue(node.right);
          case "SequenceExpression":
            return isJSXValue(node.expressions[node.expressions.length - 1]);
          case "JSXElement":
          case "JSXFragment":
            return true;
          case "CallExpression":
            return isCreateElement(context, node);
          case "Literal":
            if (!ignoreNull && node.value === null) {
              return true;
            }
            return false;
          case "Identifier": {
            const variable = variableUtil.findVariableByName(context, node, node.name);
            return isJSX(variable);
          }
          default:
            return false;
        }
      };
      let found = false;
      astUtil.traverseReturns(ASTnode, context, (node, breakTraverse) => {
        if (isJSXValue(node)) {
          found = true;
          breakTraverse();
        }
      });
      return found;
    }
    function isReturningOnlyNull(ASTnode, context) {
      let found = false;
      let foundSomethingElse = false;
      astUtil.traverseReturns(ASTnode, context, (node) => {
        astUtil.traverse(node, {
          enter(childNode) {
            const setFound = () => {
              found = true;
              this.skip();
            };
            const setFoundSomethingElse = () => {
              foundSomethingElse = true;
              this.skip();
            };
            switch (childNode.type) {
              case "ReturnStatement":
                break;
              case "ConditionalExpression":
                if (childNode.consequent.value === null && childNode.alternate.value === null) {
                  setFound();
                }
                break;
              case "Literal":
                if (childNode.value === null) {
                  setFound();
                }
                break;
              default:
                setFoundSomethingElse();
            }
          }
        });
      });
      return found && !foundSomethingElse;
    }
    module.exports = {
      isDOMComponent,
      isFragment,
      isJSX,
      isJSXAttributeKey,
      isWhiteSpaces,
      isReturningJSX,
      isReturningOnlyNull
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/usedPropTypes.js
var require_usedPropTypes = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/usedPropTypes.js"(exports, module) {
    "use strict";
    var values = require_object3();
    var astUtil = require_ast();
    var componentUtil = require_componentUtil();
    var testReactVersion = require_version().testReactVersion;
    var ast = require_ast();
    var eslintUtil = require_eslint();
    var getScope = eslintUtil.getScope;
    var getSourceCode = eslintUtil.getSourceCode;
    var LIFE_CYCLE_METHODS = ["componentWillReceiveProps", "shouldComponentUpdate", "componentWillUpdate", "componentDidUpdate"];
    var ASYNC_SAFE_LIFE_CYCLE_METHODS = ["getDerivedStateFromProps", "getSnapshotBeforeUpdate", "UNSAFE_componentWillReceiveProps", "UNSAFE_componentWillUpdate"];
    function createPropVariables() {
      let propVariables = /* @__PURE__ */ new Map();
      let hasBeenWritten = false;
      const stack = [{ propVariables, hasBeenWritten }];
      return {
        pushScope() {
          stack.push({ propVariables, hasBeenWritten: false });
        },
        popScope() {
          stack.pop();
          propVariables = stack[stack.length - 1].propVariables;
          hasBeenWritten = stack[stack.length - 1].hasBeenWritten;
        },
        /**
         * Add a variable name to the current scope
         * @param {string} name
         * @param {string[]} allNames Example: `props.a.b` should be formatted as `['a', 'b']`
         * @returns {Map<string, string[]>}
         */
        set(name, allNames) {
          if (!hasBeenWritten) {
            propVariables = new Map(propVariables);
            Object.assign(stack[stack.length - 1], { propVariables, hasBeenWritten: true });
            stack[stack.length - 1].hasBeenWritten = true;
          }
          return propVariables.set(name, allNames);
        },
        /**
         * Get the definition of a variable.
         * @param {string} name
         * @returns {string[]} Example: `props.a.b` is represented by `['a', 'b']`
         */
        get(name) {
          return propVariables.get(name);
        }
      };
    }
    function isCommonVariableNameForProps(name) {
      return name === "props" || name === "nextProps" || name === "prevProps";
    }
    function mustBeValidated(component) {
      return !!(component && !component.ignorePropsValidation);
    }
    function inLifeCycleMethod(context, node, checkAsyncSafeLifeCycles) {
      let scope = getScope(context, node);
      while (scope) {
        if (scope.block && scope.block.parent && scope.block.parent.key) {
          const name = scope.block.parent.key.name;
          if (LIFE_CYCLE_METHODS.indexOf(name) >= 0) {
            return true;
          }
          if (checkAsyncSafeLifeCycles && ASYNC_SAFE_LIFE_CYCLE_METHODS.indexOf(name) >= 0) {
            return true;
          }
        }
        scope = scope.upper;
      }
      return false;
    }
    function isNodeALifeCycleMethod(node, checkAsyncSafeLifeCycles) {
      const nodeKeyName = (node.key || /** @type {ASTNode} */
      {}).name;
      if (node.kind === "constructor") {
        return true;
      }
      if (LIFE_CYCLE_METHODS.indexOf(nodeKeyName) >= 0) {
        return true;
      }
      if (checkAsyncSafeLifeCycles && ASYNC_SAFE_LIFE_CYCLE_METHODS.indexOf(nodeKeyName) >= 0) {
        return true;
      }
      return false;
    }
    function isInLifeCycleMethod(node, checkAsyncSafeLifeCycles) {
      if ((node.type === "MethodDefinition" || node.type === "Property") && isNodeALifeCycleMethod(node, checkAsyncSafeLifeCycles)) {
        return true;
      }
      if (node.parent) {
        return isInLifeCycleMethod(node.parent, checkAsyncSafeLifeCycles);
      }
      return false;
    }
    function isSetStateUpdater(node) {
      const unwrappedParentCalleeNode = node.parent && node.parent.type === "CallExpression" && ast.unwrapTSAsExpression(node.parent.callee);
      return unwrappedParentCalleeNode && unwrappedParentCalleeNode.property && unwrappedParentCalleeNode.property.name === "setState" && node.parent.arguments[0] === node;
    }
    function isPropArgumentInSetStateUpdater(context, node, name) {
      if (typeof name !== "string") {
        return;
      }
      let scope = getScope(context, node);
      while (scope) {
        const unwrappedParentCalleeNode = scope.block && scope.block.parent && scope.block.parent.type === "CallExpression" && ast.unwrapTSAsExpression(scope.block.parent.callee);
        if (unwrappedParentCalleeNode && unwrappedParentCalleeNode.property && unwrappedParentCalleeNode.property.name === "setState" && scope.block.parent.arguments[0].range[0] === scope.block.range[0] && scope.block.parent.arguments[0].params && scope.block.parent.arguments[0].params.length > 1) {
          return scope.block.parent.arguments[0].params[1].name === name;
        }
        scope = scope.upper;
      }
      return false;
    }
    function isInClassComponent(context, node) {
      return !!(componentUtil.getParentES6Component(context, node) || componentUtil.getParentES5Component(context, node));
    }
    function isThisDotProps(node) {
      return !!node && node.type === "MemberExpression" && ast.unwrapTSAsExpression(node.object).type === "ThisExpression" && node.property.name === "props";
    }
    function hasSpreadOperator(context, node) {
      const tokens = getSourceCode(context).getTokens(node);
      return tokens.length && tokens[0].value === "...";
    }
    function isPropTypesUsageByMemberExpression(context, node, utils, checkAsyncSafeLifeCycles) {
      const unwrappedObjectNode = ast.unwrapTSAsExpression(node.object);
      if (isInClassComponent(context, node)) {
        if (isThisDotProps(unwrappedObjectNode)) {
          return true;
        }
        if (isCommonVariableNameForProps(unwrappedObjectNode.name) && (inLifeCycleMethod(context, node, checkAsyncSafeLifeCycles) || astUtil.inConstructor(context, node))) {
          return true;
        }
        if (isPropArgumentInSetStateUpdater(context, node, unwrappedObjectNode.name)) {
          return true;
        }
        return false;
      }
      return unwrappedObjectNode.name === "props" && !ast.isAssignmentLHS(node);
    }
    function getPropertyName(context, node, utils, checkAsyncSafeLifeCycles) {
      const property = node.property;
      if (property) {
        switch (property.type) {
          case "Identifier":
            if (node.computed) {
              return "__COMPUTED_PROP__";
            }
            return property.name;
          case "MemberExpression":
            return;
          case "Literal":
            if (typeof property.value === "string") {
              return property.value;
            }
            if (typeof property.value === "number") {
              if (isPropTypesUsageByMemberExpression(context, node, utils, checkAsyncSafeLifeCycles)) {
                return property.raw;
              }
            }
          default:
            if (node.computed) {
              return "__COMPUTED_PROP__";
            }
            break;
        }
      }
    }
    module.exports = function usedPropTypesInstructions(context, components, utils) {
      const checkAsyncSafeLifeCycles = testReactVersion(context, ">= 16.3.0");
      const propVariables = createPropVariables();
      const pushScope = propVariables.pushScope;
      const popScope = propVariables.popScope;
      function markPropTypesAsUsed(node, parentNames) {
        parentNames = parentNames || [];
        let type;
        let name;
        let allNames;
        let properties;
        switch (node.type) {
          case "OptionalMemberExpression":
          case "MemberExpression":
            name = getPropertyName(context, node, utils, checkAsyncSafeLifeCycles);
            if (name) {
              allNames = parentNames.concat(name);
              if (
                // Match props.foo.bar, don't match bar[props.foo]
                node.parent.type === "MemberExpression" && node.parent.object === node
              ) {
                markPropTypesAsUsed(node.parent, allNames);
              }
              if (node.parent.type === "VariableDeclarator" && node.parent.id.type === "ObjectPattern") {
                node.parent.id.parent = node.parent;
                markPropTypesAsUsed(node.parent.id, allNames);
              }
              if (node.parent.type === "VariableDeclarator" && node.parent.id.type === "Identifier") {
                propVariables.set(node.parent.id.name, allNames);
              }
              type = name !== "__COMPUTED_PROP__" ? "direct" : null;
            }
            break;
          case "ArrowFunctionExpression":
          case "FunctionDeclaration":
          case "FunctionExpression": {
            if (node.params.length === 0) {
              break;
            }
            type = "destructuring";
            const propParam = isSetStateUpdater(node) ? node.params[1] : node.params[0];
            properties = propParam.type === "AssignmentPattern" ? propParam.left.properties : propParam.properties;
            break;
          }
          case "ObjectPattern":
            type = "destructuring";
            properties = node.properties;
            break;
          case "TSEmptyBodyFunctionExpression":
            break;
          default:
            throw new Error(`${node.type} ASTNodes are not handled by markPropTypesAsUsed`);
        }
        const component = components.get(utils.getParentComponent(node));
        const usedPropTypes = component && component.usedPropTypes || [];
        let ignoreUnusedPropTypesValidation = component && component.ignoreUnusedPropTypesValidation || false;
        switch (type) {
          case "direct": {
            if (name in Object.prototype) {
              break;
            }
            const reportedNode = node.property;
            usedPropTypes.push({
              name,
              allNames,
              node: reportedNode
            });
            break;
          }
          case "destructuring": {
            for (let k = 0, l = (properties || []).length; k < l; k++) {
              if (hasSpreadOperator(context, properties[k]) || properties[k].computed) {
                ignoreUnusedPropTypesValidation = true;
                break;
              }
              const propName = ast.getKeyValue(context, properties[k]);
              if (!propName || properties[k].type !== "Property") {
                break;
              }
              usedPropTypes.push({
                allNames: parentNames.concat([propName]),
                name: propName,
                node: properties[k]
              });
              if (properties[k].value.type === "ObjectPattern") {
                markPropTypesAsUsed(properties[k].value, parentNames.concat([propName]));
              } else if (properties[k].value.type === "Identifier") {
                propVariables.set(properties[k].value.name, parentNames.concat(propName));
              }
            }
            break;
          }
          default:
            break;
        }
        components.set(component ? component.node : node, {
          usedPropTypes,
          ignoreUnusedPropTypesValidation
        });
      }
      function markDestructuredFunctionArgumentsAsUsed(node) {
        const param = node.params && isSetStateUpdater(node) ? node.params[1] : node.params[0];
        const destructuring = param && (param.type === "ObjectPattern" || param.type === "AssignmentPattern" && param.left.type === "ObjectPattern");
        if (destructuring && (components.get(node) || components.get(node.parent))) {
          markPropTypesAsUsed(node);
        }
      }
      function handleSetStateUpdater(node) {
        if (!node.params || node.params.length < 2 || !isSetStateUpdater(node)) {
          return;
        }
        markPropTypesAsUsed(node);
      }
      function handleFunctionLikeExpressions(node) {
        pushScope();
        handleSetStateUpdater(node);
        markDestructuredFunctionArgumentsAsUsed(node);
      }
      function handleCustomValidators(component) {
        const propTypes = component.declaredPropTypes;
        if (!propTypes) {
          return;
        }
        Object.keys(propTypes).forEach((key) => {
          const node = propTypes[key].node;
          if (node && node.value && astUtil.isFunctionLikeExpression(node.value)) {
            markPropTypesAsUsed(node.value);
          }
        });
      }
      return {
        VariableDeclarator(node) {
          const unwrappedInitNode = ast.unwrapTSAsExpression(node.init);
          if (isThisDotProps(unwrappedInitNode) && isInClassComponent(context, node) && node.id.type === "Identifier") {
            propVariables.set(node.id.name, []);
          }
          if (node.id.type !== "ObjectPattern" || !unwrappedInitNode) {
            return;
          }
          const propsProperty = node.id.properties.find((property) => property.key && (property.key.name === "props" || property.key.value === "props"));
          if (unwrappedInitNode.type === "ThisExpression" && propsProperty && propsProperty.value.type === "ObjectPattern") {
            markPropTypesAsUsed(propsProperty.value);
            return;
          }
          if (unwrappedInitNode.type === "ThisExpression" && propsProperty && propsProperty.value.name === "props") {
            propVariables.set("props", []);
            return;
          }
          if (isCommonVariableNameForProps(unwrappedInitNode.name) && (utils.getParentStatelessComponent(node) || isInLifeCycleMethod(node, checkAsyncSafeLifeCycles))) {
            markPropTypesAsUsed(node.id);
            return;
          }
          if (isThisDotProps(unwrappedInitNode) && isInClassComponent(context, node)) {
            markPropTypesAsUsed(node.id);
            return;
          }
          if (propVariables.get(unwrappedInitNode.name)) {
            markPropTypesAsUsed(node.id, propVariables.get(unwrappedInitNode.name));
          }
        },
        FunctionDeclaration: handleFunctionLikeExpressions,
        ArrowFunctionExpression: handleFunctionLikeExpressions,
        FunctionExpression: handleFunctionLikeExpressions,
        "FunctionDeclaration:exit": popScope,
        "ArrowFunctionExpression:exit": popScope,
        "FunctionExpression:exit": popScope,
        JSXSpreadAttribute(node) {
          const component = components.get(utils.getParentComponent(node));
          components.set(component ? component.node : node, {
            ignoreUnusedPropTypesValidation: node.argument.type !== "ObjectExpression"
          });
        },
        "MemberExpression, OptionalMemberExpression"(node) {
          if (isPropTypesUsageByMemberExpression(context, node, utils, checkAsyncSafeLifeCycles)) {
            markPropTypesAsUsed(node);
            return;
          }
          const propVariable = propVariables.get(ast.unwrapTSAsExpression(node.object).name);
          if (propVariable) {
            markPropTypesAsUsed(node, propVariable);
          }
        },
        ObjectPattern(node) {
          if (isNodeALifeCycleMethod(node.parent.parent, checkAsyncSafeLifeCycles) && node.properties.length > 0) {
            markPropTypesAsUsed(node.parent);
          }
        },
        "Program:exit"() {
          values(components.list()).filter((component) => mustBeValidated(component)).forEach((component) => {
            handleCustomValidators(component);
          });
        }
      };
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/defaultProps.js
var require_defaultProps = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/defaultProps.js"(exports, module) {
    "use strict";
    var fromEntries = require_object();
    var astUtil = require_ast();
    var componentUtil = require_componentUtil();
    var propsUtil = require_props();
    var variableUtil = require_variable();
    var propWrapperUtil = require_propWrapper();
    var getText = require_eslint().getText;
    var QUOTES_REGEX = /^["']|["']$/g;
    module.exports = function defaultPropsInstructions(context, components, utils) {
      function resolveNodeValue(node) {
        if (node.type === "Identifier") {
          return variableUtil.findVariableByName(context, node, node.name);
        }
        if (node.type === "CallExpression" && propWrapperUtil.isPropWrapperFunction(context, node.callee.name) && node.arguments && node.arguments[0]) {
          return resolveNodeValue(node.arguments[0]);
        }
        return node;
      }
      function getDefaultPropsFromObjectExpression(objectExpression) {
        const hasSpread = objectExpression.properties.find((property) => property.type === "ExperimentalSpreadProperty" || property.type === "SpreadElement");
        if (hasSpread) {
          return "unresolved";
        }
        return objectExpression.properties.map((defaultProp) => ({
          name: getText(context, defaultProp.key).replace(QUOTES_REGEX, ""),
          node: defaultProp
        }));
      }
      function markDefaultPropsAsUnresolved(component) {
        components.set(component.node, {
          defaultProps: "unresolved"
        });
      }
      function addDefaultPropsToComponent(component, defaultProps) {
        if (component.defaultProps === "unresolved") {
          return;
        }
        if (defaultProps === "unresolved") {
          markDefaultPropsAsUnresolved(component);
          return;
        }
        const defaults = component.defaultProps || {};
        const newDefaultProps = Object.assign(
          {},
          defaults,
          fromEntries(defaultProps.map((prop) => [prop.name, prop]))
        );
        components.set(component.node, {
          defaultProps: newDefaultProps
        });
      }
      return {
        MemberExpression(node) {
          const isDefaultProp = propsUtil.isDefaultPropsDeclaration(node);
          if (!isDefaultProp) {
            return;
          }
          const component = utils.getRelatedComponent(node);
          if (!component) {
            return;
          }
          if (node.parent.type === "AssignmentExpression") {
            const expression = resolveNodeValue(node.parent.right);
            if (!expression || expression.type !== "ObjectExpression") {
              if (isDefaultProp) {
                markDefaultPropsAsUnresolved(component);
              }
              return;
            }
            addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(expression));
            return;
          }
          if (node.parent.type === "MemberExpression" && node.parent.parent && node.parent.parent.type === "AssignmentExpression") {
            addDefaultPropsToComponent(component, [{
              name: node.parent.property.name,
              node: node.parent.parent
            }]);
          }
        },
        // e.g.:
        // class Hello extends React.Component {
        //   static get defaultProps() {
        //     return {
        //       name: 'Dean'
        //     };
        //   }
        //   render() {
        //     return <div>Hello {this.props.name}</div>;
        //   }
        // }
        MethodDefinition(node) {
          if (!node.static || node.kind !== "get") {
            return;
          }
          if (!propsUtil.isDefaultPropsDeclaration(node)) {
            return;
          }
          const component = components.get(componentUtil.getParentES6Component(context, node));
          if (!component) {
            return;
          }
          const returnStatement = utils.findReturnStatement(node);
          if (!returnStatement) {
            return;
          }
          const expression = resolveNodeValue(returnStatement.argument);
          if (!expression || expression.type !== "ObjectExpression") {
            return;
          }
          addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(expression));
        },
        // e.g.:
        // class Greeting extends React.Component {
        //   render() {
        //     return (
        //       <h1>Hello, {this.props.foo} {this.props.bar}</h1>
        //     );
        //   }
        //   static defaultProps = {
        //     foo: 'bar',
        //     bar: 'baz'
        //   };
        // }
        "ClassProperty, PropertyDefinition"(node) {
          if (!(node.static && node.value)) {
            return;
          }
          const propName = astUtil.getPropertyName(node);
          const isDefaultProp = propName === "defaultProps" || propName === "getDefaultProps";
          if (!isDefaultProp) {
            return;
          }
          const component = components.get(componentUtil.getParentES6Component(context, node));
          if (!component) {
            return;
          }
          const expression = resolveNodeValue(node.value);
          if (!expression || expression.type !== "ObjectExpression") {
            return;
          }
          addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(expression));
        },
        // e.g.:
        // React.createClass({
        //   render: function() {
        //     return <div>{this.props.foo}</div>;
        //   },
        //   getDefaultProps: function() {
        //     return {
        //       foo: 'default'
        //     };
        //   }
        // });
        ObjectExpression(node) {
          const component = componentUtil.isES5Component(node, context) && components.get(node);
          if (!component) {
            return;
          }
          node.properties.forEach((property) => {
            if (property.type === "ExperimentalSpreadProperty" || property.type === "SpreadElement") {
              return;
            }
            const isDefaultProp = propsUtil.isDefaultPropsDeclaration(property);
            if (isDefaultProp && property.value.type === "FunctionExpression") {
              const returnStatement = utils.findReturnStatement(property);
              if (!returnStatement || returnStatement.argument.type !== "ObjectExpression") {
                return;
              }
              addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(returnStatement.argument));
            }
          });
        }
      };
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/Components.js
var require_Components = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/Components.js"(exports, module) {
    "use strict";
    var arrayIncludes = require_array_includes();
    var fromEntries = require_object();
    var values = require_object3();
    var iterFrom = require_Iterator2();
    var map = require_Iterator_prototype();
    var variableUtil = require_variable();
    var pragmaUtil = require_pragma();
    var astUtil = require_ast();
    var componentUtil = require_componentUtil();
    var propTypesUtil = require_propTypes();
    var jsxUtil = require_jsx();
    var usedPropTypesUtil = require_usedPropTypes();
    var defaultPropsUtil = require_defaultProps();
    var isFirstLetterCapitalized = require_isFirstLetterCapitalized();
    var isDestructuredFromPragmaImport = require_isDestructuredFromPragmaImport();
    var eslintUtil = require_eslint();
    var getScope = eslintUtil.getScope;
    var getText = eslintUtil.getText;
    function getId(node) {
      return node ? `${node.range[0]}:${node.range[1]}` : "";
    }
    function usedPropTypesAreEquivalent(propA, propB) {
      if (propA.name === propB.name) {
        if (!propA.allNames && !propB.allNames) {
          return true;
        }
        if (Array.isArray(propA.allNames) && Array.isArray(propB.allNames) && propA.allNames.join("") === propB.allNames.join("")) {
          return true;
        }
        return false;
      }
      return false;
    }
    function mergeUsedPropTypes(propsList, newPropsList) {
      const propsToAdd = newPropsList.filter((newProp) => {
        const newPropIsAlreadyInTheList = propsList.some((prop) => usedPropTypesAreEquivalent(prop, newProp));
        return !newPropIsAlreadyInTheList;
      });
      return propsList.concat(propsToAdd);
    }
    var USE_HOOK_PREFIX_REGEX = /^use[A-Z]/;
    var Lists = /* @__PURE__ */ new WeakMap();
    var ReactImports = /* @__PURE__ */ new WeakMap();
    var Components = class {
      constructor() {
        Lists.set(this, {});
        ReactImports.set(this, {});
      }
      /**
       * Add a node to the components list, or update it if it's already in the list
       *
       * @param {ASTNode} node The AST node being added.
       * @param {Number} confidence Confidence in the component detection (0=banned, 1=maybe, 2=yes)
       * @returns {Object} Added component object
       */
      add(node, confidence) {
        const id = getId(node);
        const list = Lists.get(this);
        if (list[id]) {
          if (confidence === 0 || list[id].confidence === 0) {
            list[id].confidence = 0;
          } else {
            list[id].confidence = Math.max(list[id].confidence, confidence);
          }
          return list[id];
        }
        list[id] = {
          node,
          confidence
        };
        return list[id];
      }
      /**
       * Find a component in the list using its node
       *
       * @param {ASTNode} node The AST node being searched.
       * @returns {Object} Component object, undefined if the component is not found or has confidence value of 0.
       */
      get(node) {
        const id = getId(node);
        const item = Lists.get(this)[id];
        if (item && item.confidence >= 1) {
          return item;
        }
        return null;
      }
      /**
       * Update a component in the list
       *
       * @param {ASTNode} node The AST node being updated.
       * @param {Object} props Additional properties to add to the component.
       */
      set(node, props) {
        const list = Lists.get(this);
        let component = list[getId(node)];
        while (!component || component.confidence < 1) {
          node = node.parent;
          if (!node) {
            return;
          }
          component = list[getId(node)];
        }
        Object.assign(
          component,
          props,
          {
            usedPropTypes: mergeUsedPropTypes(
              component.usedPropTypes || [],
              props.usedPropTypes || []
            )
          }
        );
      }
      /**
       * Return the components list
       * Components for which we are not confident are not returned
       *
       * @returns {Object} Components list
       */
      list() {
        const thisList = Lists.get(this);
        const list = {};
        const usedPropTypes = {};
        Object.keys(thisList).filter((i) => thisList[i].confidence < 2).forEach((i) => {
          let component = null;
          let node = null;
          node = thisList[i].node;
          while (!component && node.parent) {
            node = node.parent;
            if (node.type === "Decorator") {
              break;
            }
            component = this.get(node);
          }
          if (component) {
            const newUsedProps = (thisList[i].usedPropTypes || []).filter((propType) => !propType.node || propType.node.kind !== "init");
            const componentId = getId(component.node);
            usedPropTypes[componentId] = mergeUsedPropTypes(usedPropTypes[componentId] || [], newUsedProps);
          }
        });
        Object.keys(thisList).filter((j) => thisList[j].confidence >= 2).forEach((j) => {
          const id = getId(thisList[j].node);
          list[j] = thisList[j];
          if (usedPropTypes[id]) {
            list[j].usedPropTypes = mergeUsedPropTypes(list[j].usedPropTypes || [], usedPropTypes[id]);
          }
        });
        return list;
      }
      /**
       * Return the length of the components list
       * Components for which we are not confident are not counted
       *
       * @returns {Number} Components list length
       */
      length() {
        const list = Lists.get(this);
        return values(list).filter((component) => component.confidence >= 2).length;
      }
      /**
       * Return the node naming the default React import
       * It can be used to determine the local name of import, even if it's imported
       * with an unusual name.
       *
       * @returns {ASTNode} React default import node
       */
      getDefaultReactImports() {
        return ReactImports.get(this).defaultReactImports;
      }
      /**
       * Return the nodes of all React named imports
       *
       * @returns {Object} The list of React named imports
       */
      getNamedReactImports() {
        return ReactImports.get(this).namedReactImports;
      }
      /**
       * Add the default React import specifier to the scope
       *
       * @param {ASTNode} specifier The AST Node of the default React import
       * @returns {void}
       */
      addDefaultReactImport(specifier) {
        const info = ReactImports.get(this);
        ReactImports.set(this, Object.assign({}, info, {
          defaultReactImports: (info.defaultReactImports || []).concat(specifier)
        }));
      }
      /**
       * Add a named React import specifier to the scope
       *
       * @param {ASTNode} specifier The AST Node of a named React import
       * @returns {void}
       */
      addNamedReactImport(specifier) {
        const info = ReactImports.get(this);
        ReactImports.set(this, Object.assign({}, info, {
          namedReactImports: (info.namedReactImports || []).concat(specifier)
        }));
      }
    };
    function getWrapperFunctions(context, pragma) {
      const componentWrapperFunctions = context.settings.componentWrapperFunctions || [];
      return componentWrapperFunctions.map((wrapperFunction) => {
        return typeof wrapperFunction === "string" ? { property: wrapperFunction } : Object.assign({}, wrapperFunction, {
          object: wrapperFunction.object === "<pragma>" ? pragma : wrapperFunction.object
        });
      }).concat([
        { property: "forwardRef", object: pragma },
        { property: "memo", object: pragma }
      ]);
    }
    function mergeRules(rules2) {
      const handlersByKey = /* @__PURE__ */ new Map();
      rules2.forEach((rule) => {
        Object.keys(rule).forEach((key) => {
          const fns = handlersByKey.get(key);
          if (!fns) {
            handlersByKey.set(key, [rule[key]]);
          } else {
            fns.push(rule[key]);
          }
        });
      });
      return fromEntries(map(iterFrom(handlersByKey), (entry) => [
        entry[0],
        function mergedHandler(node) {
          entry[1].forEach((fn) => {
            fn(node);
          });
        }
      ]));
    }
    function componentRule(rule, context) {
      const pragma = pragmaUtil.getFromContext(context);
      const components = new Components();
      const wrapperFunctions = getWrapperFunctions(context, pragma);
      const utils = {
        /**
         * Check if variable is destructured from pragma import
         *
         * @param {ASTNode} node The AST node to check
         * @param {string} variable The variable name to check
         * @returns {boolean} True if createElement is destructured from the pragma
         */
        isDestructuredFromPragmaImport(node, variable) {
          return isDestructuredFromPragmaImport(context, node, variable);
        },
        /**
         * @param {ASTNode} ASTNode
         * @param {boolean=} strict
         * @returns {boolean}
         */
        isReturningJSX(ASTNode, strict) {
          return jsxUtil.isReturningJSX(context, ASTNode, strict, true);
        },
        isReturningJSXOrNull(ASTNode, strict) {
          return jsxUtil.isReturningJSX(context, ASTNode, strict);
        },
        isReturningOnlyNull(ASTNode) {
          return jsxUtil.isReturningOnlyNull(ASTNode, context);
        },
        getPragmaComponentWrapper(node) {
          let isPragmaComponentWrapper;
          let currentNode = node;
          let prevNode;
          do {
            currentNode = currentNode.parent;
            isPragmaComponentWrapper = this.isPragmaComponentWrapper(currentNode);
            if (isPragmaComponentWrapper) {
              prevNode = currentNode;
            }
          } while (isPragmaComponentWrapper);
          return prevNode;
        },
        getComponentNameFromJSXElement(node) {
          if (node.type !== "JSXElement") {
            return null;
          }
          if (node.openingElement && node.openingElement.name && node.openingElement.name.name) {
            return node.openingElement.name.name;
          }
          return null;
        },
        /**
         * Getting the first JSX element's name.
         * @param {object} node
         * @returns {string | null}
         */
        getNameOfWrappedComponent(node) {
          if (node.length < 1) {
            return null;
          }
          const body = node[0].body;
          if (!body) {
            return null;
          }
          if (body.type === "JSXElement") {
            return this.getComponentNameFromJSXElement(body);
          }
          if (body.type === "BlockStatement") {
            const jsxElement = body.body.find((item) => item.type === "ReturnStatement");
            return jsxElement && jsxElement.argument && this.getComponentNameFromJSXElement(jsxElement.argument);
          }
          return null;
        },
        /**
         * Get the list of names of components created till now
         * @returns {string | boolean}
         */
        getDetectedComponents() {
          const list = components.list();
          return values(list).filter((val) => {
            if (val.node.type === "ClassDeclaration") {
              return true;
            }
            if (val.node.type === "ArrowFunctionExpression" && val.node.parent && val.node.parent.type === "VariableDeclarator" && val.node.parent.id) {
              return true;
            }
            return false;
          }).map((val) => {
            if (val.node.type === "ArrowFunctionExpression")
              return val.node.parent.id.name;
            return val.node.id && val.node.id.name;
          });
        },
        /**
         * It will check whether memo/forwardRef is wrapping existing component or
         * creating a new one.
         * @param {object} node
         * @returns {boolean}
         */
        nodeWrapsComponent(node) {
          const childComponent = this.getNameOfWrappedComponent(node.arguments);
          const componentList = this.getDetectedComponents();
          return !!childComponent && arrayIncludes(componentList, childComponent);
        },
        isPragmaComponentWrapper(node) {
          if (!node || node.type !== "CallExpression") {
            return false;
          }
          return wrapperFunctions.some((wrapperFunction) => {
            if (node.callee.type === "MemberExpression") {
              return wrapperFunction.object && wrapperFunction.object === node.callee.object.name && wrapperFunction.property === node.callee.property.name && !this.nodeWrapsComponent(node);
            }
            return wrapperFunction.property === node.callee.name && (!wrapperFunction.object || wrapperFunction.object === pragma && this.isDestructuredFromPragmaImport(node, node.callee.name));
          });
        },
        /**
         * Find a return statement in the current node
         *
         * @param {ASTNode} node The AST node being checked
         */
        findReturnStatement: astUtil.findReturnStatement,
        /**
         * Get the parent component node from the current scope
         * @param {ASTNode} node
         *
         * @returns {ASTNode} component node, null if we are not in a component
         */
        getParentComponent(node) {
          return componentUtil.getParentES6Component(context, node) || componentUtil.getParentES5Component(context, node) || utils.getParentStatelessComponent(node);
        },
        /**
         * @param {ASTNode} node
         * @returns {boolean}
         */
        isInAllowedPositionForComponent(node) {
          switch (node.parent.type) {
            case "VariableDeclarator":
            case "AssignmentExpression":
            case "Property":
            case "ReturnStatement":
            case "ExportDefaultDeclaration":
            case "ArrowFunctionExpression": {
              return true;
            }
            case "SequenceExpression": {
              return utils.isInAllowedPositionForComponent(node.parent) && node === node.parent.expressions[node.parent.expressions.length - 1];
            }
            default:
              return false;
          }
        },
        /**
         * Get node if node is a stateless component, or node.parent in cases like
         * `React.memo` or `React.forwardRef`. Otherwise returns `undefined`.
         * @param {ASTNode} node
         * @returns {ASTNode | undefined}
         */
        getStatelessComponent(node) {
          const parent = node.parent;
          if (node.type === "FunctionDeclaration" && (!node.id || isFirstLetterCapitalized(node.id.name)) && utils.isReturningJSXOrNull(node)) {
            return node;
          }
          if (node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression") {
            const isPropertyAssignment = parent.type === "AssignmentExpression" && parent.left.type === "MemberExpression";
            const isModuleExportsAssignment = isPropertyAssignment && parent.left.object.name === "module" && parent.left.property.name === "exports";
            if (node.parent.type === "ExportDefaultDeclaration") {
              if (utils.isReturningJSX(node)) {
                return node;
              }
              return void 0;
            }
            if (node.parent.type === "VariableDeclarator" && utils.isReturningJSXOrNull(node)) {
              if (isFirstLetterCapitalized(node.parent.id.name)) {
                return node;
              }
              return void 0;
            }
            if ((node.parent.type === "ReturnStatement" || node.parent.type === "ArrowFunctionExpression" && node.parent.expression) && !utils.isReturningJSX(node)) {
              return void 0;
            }
            if (node.parent.type === "AssignmentExpression" && !isPropertyAssignment && utils.isReturningJSXOrNull(node)) {
              if (isFirstLetterCapitalized(node.parent.left.name)) {
                return node;
              }
              return void 0;
            }
            if (node.parent.type === "ArrowFunctionExpression" && node.parent.parent.type === "AssignmentExpression" && !isPropertyAssignment && utils.isReturningJSXOrNull(node)) {
              if (isFirstLetterCapitalized(node.parent.parent.left.name)) {
                return node;
              }
              return void 0;
            }
            if (node.parent.type === "ArrowFunctionExpression" && node.parent.parent.type === "Property" && !isPropertyAssignment && utils.isReturningJSXOrNull(node)) {
              if (isFirstLetterCapitalized(node.parent.parent.key.name)) {
                return node;
              }
              return void 0;
            }
            if (node.parent.type === "ReturnStatement") {
              if (isFirstLetterCapitalized(node.id && node.id.name)) {
                return node;
              }
              const functionExpr = node.parent.parent.parent;
              if (functionExpr.parent.type === "AssignmentExpression" && !isPropertyAssignment && utils.isReturningJSXOrNull(node)) {
                if (isFirstLetterCapitalized(functionExpr.parent.left.name)) {
                  return node;
                }
                return void 0;
              }
            }
            if (node.parent.type === "ReturnStatement") {
              const functionExpr = node.parent.parent.parent;
              if (functionExpr.parent.type === "Property" && !isPropertyAssignment && utils.isReturningJSXOrNull(node)) {
                if (isFirstLetterCapitalized(functionExpr.parent.key.name)) {
                  return node;
                }
                return void 0;
              }
            }
            if (node.parent && node.parent.key && node.parent.key.type === "MemberExpression" && !utils.isReturningJSX(node) && !utils.isReturningOnlyNull(node)) {
              return void 0;
            }
            if (node.parent.type === "Property" && (node.parent.method && !node.parent.computed || !node.id && !node.parent.computed)) {
              if (isFirstLetterCapitalized(node.parent.key.name) && utils.isReturningJSX(node)) {
                return node;
              }
              return void 0;
            }
            const pragmaComponentWrapper = utils.getPragmaComponentWrapper(node);
            if (pragmaComponentWrapper && utils.isReturningJSXOrNull(node)) {
              return pragmaComponentWrapper;
            }
            if (!(utils.isInAllowedPositionForComponent(node) && utils.isReturningJSXOrNull(node))) {
              return void 0;
            }
            if (utils.isParentComponentNotStatelessComponent(node)) {
              return void 0;
            }
            if (node.id) {
              return isFirstLetterCapitalized(node.id.name) ? node : void 0;
            }
            if (isPropertyAssignment && !isModuleExportsAssignment && !isFirstLetterCapitalized(parent.left.property.name)) {
              return void 0;
            }
            if (parent.type === "Property" && utils.isReturningOnlyNull(node)) {
              return void 0;
            }
            return node;
          }
          return void 0;
        },
        /**
         * Get the parent stateless component node from the current scope
         *
         * @param {ASTNode} node The AST node being checked
         * @returns {ASTNode} component node, null if we are not in a component
         */
        getParentStatelessComponent(node) {
          let scope = getScope(context, node);
          while (scope) {
            const statelessComponent = utils.getStatelessComponent(scope.block);
            if (statelessComponent) {
              return statelessComponent;
            }
            scope = scope.upper;
          }
          return null;
        },
        /**
         * Get the related component from a node
         *
         * @param {ASTNode} node The AST node being checked (must be a MemberExpression).
         * @returns {ASTNode} component node, null if we cannot find the component
         */
        getRelatedComponent(node) {
          let i;
          let j;
          let k;
          let l;
          let componentNode;
          const componentPath = [];
          let nodeTemp = node;
          while (nodeTemp) {
            if (nodeTemp.property && nodeTemp.property.type === "Identifier") {
              componentPath.push(nodeTemp.property.name);
            }
            if (nodeTemp.object && nodeTemp.object.type === "Identifier") {
              componentPath.push(nodeTemp.object.name);
            }
            nodeTemp = nodeTemp.object;
          }
          componentPath.reverse();
          const componentName = componentPath.slice(0, componentPath.length - 1).join(".");
          const variableName = componentPath.shift();
          if (!variableName) {
            return null;
          }
          let variableInScope;
          const variables = variableUtil.variablesInScope(context, node);
          for (i = 0, j = variables.length; i < j; i++) {
            if (variables[i].name === variableName) {
              variableInScope = variables[i];
              break;
            }
          }
          if (!variableInScope) {
            return null;
          }
          variableInScope.references.some((ref) => {
            let refId = ref.identifier;
            if (refId.parent && refId.parent.type === "MemberExpression") {
              refId = refId.parent;
            }
            if (getText(context, refId) !== componentName) {
              return false;
            }
            if (refId.type === "MemberExpression") {
              componentNode = refId.parent.right;
            } else if (refId.parent && refId.parent.type === "VariableDeclarator" && refId.parent.init && refId.parent.init.type !== "Identifier") {
              componentNode = refId.parent.init;
            }
            return true;
          });
          if (componentNode) {
            return components.add(componentNode, 1);
          }
          const defs = variableInScope.defs;
          const defInScope = defs.find((def) => def.type === "ClassName" || def.type === "FunctionName" || def.type === "Variable");
          if (!defInScope || !defInScope.node) {
            return null;
          }
          componentNode = defInScope.node.init || defInScope.node;
          for (i = 0, j = componentPath.length; i < j; i++) {
            if (!componentNode.properties) {
              continue;
            }
            for (k = 0, l = componentNode.properties.length; k < l; k++) {
              if (componentNode.properties[k].key && componentNode.properties[k].key.name === componentPath[i]) {
                componentNode = componentNode.properties[k];
                break;
              }
            }
            if (!componentNode || !componentNode.value) {
              return null;
            }
            componentNode = componentNode.value;
          }
          return components.add(componentNode, 1);
        },
        isParentComponentNotStatelessComponent(node) {
          return !!(node.parent && node.parent.key && node.parent.key.type === "Identifier" && node.parent.key.name.charAt(0) === node.parent.key.name.charAt(0).toLowerCase() && !!(node.params || []).length);
        },
        /**
         * Identify whether a node (CallExpression) is a call to a React hook
         *
         * @param {ASTNode} node The AST node being searched. (expects CallExpression)
         * @param {('useCallback'|'useContext'|'useDebugValue'|'useEffect'|'useImperativeHandle'|'useLayoutEffect'|'useMemo'|'useReducer'|'useRef'|'useState')[]} [expectedHookNames] React hook names to which search is limited.
         * @returns {Boolean} True if the node is a call to a React hook
         */
        isReactHookCall(node, expectedHookNames) {
          if (node.type !== "CallExpression") {
            return false;
          }
          const defaultReactImports = components.getDefaultReactImports();
          const namedReactImports = components.getNamedReactImports();
          const defaultReactImportName = defaultReactImports && defaultReactImports[0] && defaultReactImports[0].local.name;
          const reactHookImportSpecifiers = namedReactImports && namedReactImports.filter((specifier) => USE_HOOK_PREFIX_REGEX.test(specifier.imported.name));
          const reactHookImportNames = reactHookImportSpecifiers && fromEntries(reactHookImportSpecifiers.map((specifier) => [specifier.local.name, specifier.imported.name]));
          const isPotentialReactHookCall = defaultReactImportName && node.callee.type === "MemberExpression" && node.callee.object.type === "Identifier" && node.callee.object.name === defaultReactImportName && node.callee.property.type === "Identifier" && node.callee.property.name.match(USE_HOOK_PREFIX_REGEX);
          const isPotentialHookCall = reactHookImportNames && node.callee.type === "Identifier" && node.callee.name.match(USE_HOOK_PREFIX_REGEX);
          const scope = (isPotentialReactHookCall || isPotentialHookCall) && getScope(context, node);
          const reactResolvedDefs = isPotentialReactHookCall && scope.references && scope.references.find(
            (reference) => reference.identifier.name === defaultReactImportName
          ).resolved.defs;
          const isReactShadowed = isPotentialReactHookCall && reactResolvedDefs && reactResolvedDefs.some((reactDef) => reactDef.type !== "ImportBinding");
          const potentialHookReference = isPotentialHookCall && scope.references && scope.references.find(
            (reference) => reactHookImportNames[reference.identifier.name]
          );
          const hookResolvedDefs = potentialHookReference && potentialHookReference.resolved.defs;
          const localHookName = isPotentialReactHookCall && node.callee.property.name || isPotentialHookCall && potentialHookReference && node.callee.name;
          const isHookShadowed = isPotentialHookCall && hookResolvedDefs && hookResolvedDefs.some(
            (hookDef) => hookDef.name.name === localHookName && hookDef.type !== "ImportBinding"
          );
          const isHookCall = isPotentialReactHookCall && !isReactShadowed || isPotentialHookCall && localHookName && !isHookShadowed;
          if (!isHookCall) {
            return false;
          }
          if (!expectedHookNames) {
            return true;
          }
          return arrayIncludes(
            expectedHookNames,
            reactHookImportNames && reactHookImportNames[localHookName] || localHookName
          );
        }
      };
      const detectionInstructions = {
        CallExpression(node) {
          if (!utils.isPragmaComponentWrapper(node)) {
            return;
          }
          if (node.arguments.length > 0 && astUtil.isFunctionLikeExpression(node.arguments[0])) {
            components.add(node, 2);
          }
        },
        ClassExpression(node) {
          if (!componentUtil.isES6Component(node, context)) {
            return;
          }
          components.add(node, 2);
        },
        ClassDeclaration(node) {
          if (!componentUtil.isES6Component(node, context)) {
            return;
          }
          components.add(node, 2);
        },
        ObjectExpression(node) {
          if (!componentUtil.isES5Component(node, context)) {
            return;
          }
          components.add(node, 2);
        },
        FunctionExpression(node) {
          if (node.async && node.generator) {
            components.add(node, 0);
            return;
          }
          const component = utils.getStatelessComponent(node);
          if (!component) {
            return;
          }
          components.add(component, 2);
        },
        FunctionDeclaration(node) {
          if (node.async && node.generator) {
            components.add(node, 0);
            return;
          }
          node = utils.getStatelessComponent(node);
          if (!node) {
            return;
          }
          components.add(node, 2);
        },
        ArrowFunctionExpression(node) {
          const component = utils.getStatelessComponent(node);
          if (!component) {
            return;
          }
          components.add(component, 2);
        },
        ThisExpression(node) {
          const component = utils.getParentStatelessComponent(node);
          if (!component || !/Function/.test(component.type) || !node.parent.property) {
            return;
          }
          components.add(node, 0);
        }
      };
      const reactImportInstructions = {
        ImportDeclaration(node) {
          const isReactImported = node.source.type === "Literal" && node.source.value === "react";
          if (!isReactImported) {
            return;
          }
          node.specifiers.forEach((specifier) => {
            if (specifier.type === "ImportDefaultSpecifier") {
              components.addDefaultReactImport(specifier);
            }
            if (specifier.type === "ImportSpecifier") {
              components.addNamedReactImport(specifier);
            }
          });
        }
      };
      const ruleInstructions = rule(context, components, utils);
      const propTypesInstructions = propTypesUtil(context, components, utils);
      const usedPropTypesInstructions = usedPropTypesUtil(context, components, utils);
      const defaultPropsInstructions = defaultPropsUtil(context, components, utils);
      const mergedRule = mergeRules([
        detectionInstructions,
        propTypesInstructions,
        usedPropTypesInstructions,
        defaultPropsInstructions,
        reactImportInstructions,
        ruleInstructions
      ]);
      return mergedRule;
    }
    module.exports = Object.assign(Components, {
      detect(rule) {
        return componentRule.bind(this, rule);
      }
    });
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/docsUrl.js
var require_docsUrl = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/docsUrl.js"(exports, module) {
    "use strict";
    function docsUrl(ruleName) {
      return `https://github.com/jsx-eslint/eslint-plugin-react/tree/master/docs/rules/${ruleName}.md`;
    }
    module.exports = docsUrl;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/eslint/package.json
var require_package2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/eslint/package.json"(exports, module) {
    module.exports = {
      name: "eslint",
      version: "9.4.0",
      author: "Nicholas C. Zakas <nicholas+npm@nczconsulting.com>",
      description: "An AST-based pattern checker for JavaScript.",
      bin: {
        eslint: "./bin/eslint.js"
      },
      main: "./lib/api.js",
      exports: {
        "./package.json": "./package.json",
        ".": "./lib/api.js",
        "./use-at-your-own-risk": "./lib/unsupported-api.js"
      },
      scripts: {
        "build:docs:update-links": "node tools/fetch-docs-links.js",
        "build:site": "node Makefile.js gensite",
        "build:webpack": "node Makefile.js webpack",
        "build:readme": "node tools/update-readme.js",
        "build:rules-index": "node Makefile.js generateRuleIndexPage",
        lint: "node Makefile.js lint",
        "lint:docs:js": "node Makefile.js lintDocsJS",
        "lint:docs:rule-examples": "node Makefile.js checkRuleExamples",
        "lint:fix": "node Makefile.js lint -- fix",
        "lint:fix:docs:js": "node Makefile.js lintDocsJS -- fix",
        "lint:unused": "knip",
        "release:generate:alpha": "node Makefile.js generatePrerelease -- alpha",
        "release:generate:beta": "node Makefile.js generatePrerelease -- beta",
        "release:generate:latest": "node Makefile.js generateRelease",
        "release:generate:rc": "node Makefile.js generatePrerelease -- rc",
        "release:publish": "node Makefile.js publishRelease",
        test: "node Makefile.js test",
        "test:browser": "node Makefile.js wdio",
        "test:cli": "mocha",
        "test:fuzz": "node Makefile.js fuzz",
        "test:performance": "node Makefile.js perf",
        "test:emfile": "node tools/check-emfile-handling.js"
      },
      gitHooks: {
        "pre-commit": "lint-staged"
      },
      "lint-staged": {
        "*.js": "eslint --fix",
        "*.md": "markdownlint --fix",
        "lib/rules/*.js": [
          "node tools/update-eslint-all.js",
          "git add packages/js/src/configs/eslint-all.js"
        ],
        "docs/src/rules/*.md": [
          "node tools/check-rule-examples.js",
          "node tools/fetch-docs-links.js",
          "git add docs/src/_data/further_reading_links.json"
        ],
        "docs/**/*.svg": "npx -y svgo -r --multipass"
      },
      files: [
        "LICENSE",
        "README.md",
        "bin",
        "conf",
        "lib",
        "messages"
      ],
      repository: "eslint/eslint",
      funding: "https://opencollective.com/eslint",
      homepage: "https://eslint.org",
      bugs: "https://github.com/eslint/eslint/issues/",
      dependencies: {
        "@eslint-community/eslint-utils": "^4.2.0",
        "@eslint-community/regexpp": "^4.6.1",
        "@eslint/config-array": "^0.15.1",
        "@eslint/eslintrc": "^3.1.0",
        "@eslint/js": "9.4.0",
        "@humanwhocodes/module-importer": "^1.0.1",
        "@humanwhocodes/retry": "^0.3.0",
        "@nodelib/fs.walk": "^1.2.8",
        ajv: "^6.12.4",
        chalk: "^4.0.0",
        "cross-spawn": "^7.0.2",
        debug: "^4.3.2",
        "escape-string-regexp": "^4.0.0",
        "eslint-scope": "^8.0.1",
        "eslint-visitor-keys": "^4.0.0",
        espree: "^10.0.1",
        esquery: "^1.4.2",
        esutils: "^2.0.2",
        "fast-deep-equal": "^3.1.3",
        "file-entry-cache": "^8.0.0",
        "find-up": "^5.0.0",
        "glob-parent": "^6.0.2",
        ignore: "^5.2.0",
        imurmurhash: "^0.1.4",
        "is-glob": "^4.0.0",
        "is-path-inside": "^3.0.3",
        "json-stable-stringify-without-jsonify": "^1.0.1",
        levn: "^0.4.1",
        "lodash.merge": "^4.6.2",
        minimatch: "^3.1.2",
        "natural-compare": "^1.4.0",
        optionator: "^0.9.3",
        "strip-ansi": "^6.0.1",
        "text-table": "^0.2.0"
      },
      devDependencies: {
        "@babel/core": "^7.4.3",
        "@babel/preset-env": "^7.4.3",
        "@eslint-community/eslint-plugin-eslint-comments": "^4.3.0",
        "@types/estree": "^1.0.5",
        "@types/node": "^20.11.5",
        "@wdio/browser-runner": "^8.14.6",
        "@wdio/cli": "^8.14.6",
        "@wdio/concise-reporter": "^8.14.0",
        "@wdio/globals": "^8.14.6",
        "@wdio/mocha-framework": "^8.14.0",
        "babel-loader": "^8.0.5",
        c8: "^7.12.0",
        chai: "^4.0.1",
        cheerio: "^0.22.0",
        "common-tags": "^1.8.0",
        "core-js": "^3.1.3",
        ejs: "^3.0.2",
        eslint: "file:.",
        "eslint-config-eslint": "file:packages/eslint-config-eslint",
        "eslint-plugin-eslint-plugin": "^6.0.0",
        "eslint-plugin-internal-rules": "file:tools/internal-rules",
        "eslint-plugin-jsdoc": "^48.2.3",
        "eslint-plugin-n": "^17.2.0",
        "eslint-plugin-unicorn": "^52.0.0",
        "eslint-release": "^3.2.2",
        eslump: "^3.0.0",
        esprima: "^4.0.1",
        "fast-glob": "^3.2.11",
        "fs-teardown": "^0.1.3",
        glob: "^10.0.0",
        globals: "^15.0.0",
        got: "^11.8.3",
        "gray-matter": "^4.0.3",
        "js-yaml": "^4.1.0",
        knip: "^5.8.0",
        "lint-staged": "^11.0.0",
        "load-perf": "^0.2.0",
        "markdown-it": "^12.2.0",
        "markdown-it-container": "^3.0.0",
        markdownlint: "^0.34.0",
        "markdownlint-cli": "^0.40.0",
        marked: "^4.0.8",
        metascraper: "^5.25.7",
        "metascraper-description": "^5.25.7",
        "metascraper-image": "^5.29.3",
        "metascraper-logo": "^5.25.7",
        "metascraper-logo-favicon": "^5.25.7",
        "metascraper-title": "^5.25.7",
        mocha: "^8.3.2",
        "node-polyfill-webpack-plugin": "^1.0.3",
        "npm-license": "^0.3.3",
        pirates: "^4.0.5",
        progress: "^2.0.3",
        proxyquire: "^2.0.1",
        recast: "^0.23.0",
        "regenerator-runtime": "^0.14.0",
        "rollup-plugin-node-polyfills": "^0.2.1",
        semver: "^7.5.3",
        shelljs: "^0.8.5",
        sinon: "^11.0.0",
        typescript: "^5.3.3",
        "vite-plugin-commonjs": "^0.10.0",
        webpack: "^5.23.0",
        "webpack-cli": "^4.5.0",
        yorkie: "^2.0.0"
      },
      keywords: [
        "ast",
        "lint",
        "javascript",
        "ecmascript",
        "espree"
      ],
      license: "MIT",
      engines: {
        node: "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/message.js
var require_message = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/message.js"(exports, module) {
    "use strict";
    var semver = require_semver();
    var eslintPkg = require_package2();
    module.exports = function getMessageData(messageId, message) {
      return messageId && semver.satisfies(eslintPkg.version, ">= 4.15") ? { messageId } : { message };
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/report.js
var require_report = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/report.js"(exports, module) {
    "use strict";
    var getMessageData = require_message();
    module.exports = function report(context, message, messageId, data) {
      context.report(
        Object.assign(
          getMessageData(messageId, message),
          data
        )
      );
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/boolean-prop-naming.js
var require_boolean_prop_naming = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/boolean-prop-naming.js"(exports, module) {
    "use strict";
    var flatMap = require_array_prototype();
    var values = require_object3();
    var Components = require_Components();
    var propsUtil = require_props();
    var docsUrl = require_docsUrl();
    var propWrapperUtil = require_propWrapper();
    var report = require_report();
    var eslintUtil = require_eslint();
    var getSourceCode = eslintUtil.getSourceCode;
    var getText = eslintUtil.getText;
    var messages = {
      patternMismatch: "Prop name `{{propName}}` doesn\u2019t match rule `{{pattern}}`"
    };
    module.exports = {
      meta: {
        docs: {
          category: "Stylistic Issues",
          description: "Enforces consistent naming for boolean props",
          recommended: false,
          url: docsUrl("boolean-prop-naming")
        },
        messages,
        schema: [{
          additionalProperties: false,
          properties: {
            propTypeNames: {
              items: {
                type: "string"
              },
              minItems: 1,
              type: "array",
              uniqueItems: true
            },
            rule: {
              default: "^(is|has)[A-Z]([A-Za-z0-9]?)+",
              minLength: 1,
              type: "string"
            },
            message: {
              minLength: 1,
              type: "string"
            },
            validateNested: {
              default: false,
              type: "boolean"
            }
          },
          type: "object"
        }]
      },
      create: Components.detect((context, components, utils) => {
        const config = context.options[0] || {};
        const rule = config.rule ? new RegExp(config.rule) : null;
        const propTypeNames = config.propTypeNames || ["bool"];
        const objectTypeAnnotations = /* @__PURE__ */ new Map();
        function getPropKey(node) {
          if (node.type === "ExperimentalSpreadProperty" || node.type === "SpreadElement") {
            return null;
          }
          if (node.value && node.value.property) {
            const name = node.value.property.name;
            if (name === "isRequired") {
              if (node.value.object && node.value.object.property) {
                return node.value.object.property.name;
              }
              return null;
            }
            return name;
          }
          if (node.value && node.value.type === "Identifier") {
            return node.value.name;
          }
          return null;
        }
        function getPropName(node) {
          if (node.type === "ObjectTypeProperty") {
            return getSourceCode(context).getFirstToken(node).value;
          }
          return node.key.name;
        }
        function flowCheck(prop) {
          return prop.type === "ObjectTypeProperty" && prop.value.type === "BooleanTypeAnnotation" && rule.test(getPropName(prop)) === false;
        }
        function regularCheck(prop) {
          const propKey = getPropKey(prop);
          return propKey && propTypeNames.indexOf(propKey) >= 0 && rule.test(getPropName(prop)) === false;
        }
        function tsCheck(prop) {
          if (prop.type !== "TSPropertySignature")
            return false;
          const typeAnnotation = (prop.typeAnnotation || {}).typeAnnotation;
          return typeAnnotation && typeAnnotation.type === "TSBooleanKeyword" && rule.test(getPropName(prop)) === false;
        }
        function nestedPropTypes(prop) {
          return prop.type === "Property" && prop.value.type === "CallExpression";
        }
        function runCheck(proptypes, addInvalidProp) {
          (proptypes || []).forEach((prop) => {
            if (config.validateNested && nestedPropTypes(prop)) {
              runCheck(prop.value.arguments[0].properties, addInvalidProp);
              return;
            }
            if (flowCheck(prop) || regularCheck(prop) || tsCheck(prop)) {
              addInvalidProp(prop);
            }
          });
        }
        function validatePropNaming(node, proptypes) {
          const component = components.get(node) || node;
          const invalidProps = component.invalidProps || [];
          runCheck(proptypes, (prop) => {
            invalidProps.push(prop);
          });
          components.set(node, {
            invalidProps
          });
        }
        function reportInvalidNaming(component) {
          component.invalidProps.forEach((propNode) => {
            const propName = getPropName(propNode);
            report(context, config.message || messages.patternMismatch, !config.message && "patternMismatch", {
              node: propNode,
              data: {
                component: propName,
                propName,
                pattern: config.rule
              }
            });
          });
        }
        function checkPropWrapperArguments(node, args) {
          if (!node || !Array.isArray(args)) {
            return;
          }
          args.filter((arg) => arg.type === "ObjectExpression").forEach((object) => validatePropNaming(node, object.properties));
        }
        function getComponentTypeAnnotation(component) {
          if ((component.node.type === "FunctionDeclaration" || component.node.type === "ArrowFunctionExpression") && component.node.params && component.node.params.length > 0 && component.node.params[0].typeAnnotation) {
            return component.node.params[0].typeAnnotation.typeAnnotation;
          }
          if (!component.node.parent || component.node.parent.type !== "VariableDeclarator" || !component.node.parent.id || component.node.parent.id.type !== "Identifier" || !component.node.parent.id.typeAnnotation || !component.node.parent.id.typeAnnotation.typeAnnotation) {
            return;
          }
          const annotationTypeParams = component.node.parent.id.typeAnnotation.typeAnnotation.typeParameters;
          if (annotationTypeParams && (annotationTypeParams.type === "TSTypeParameterInstantiation" || annotationTypeParams.type === "TypeParameterInstantiation")) {
            return annotationTypeParams.params.find(
              (param) => param.type === "TSTypeReference" || param.type === "GenericTypeAnnotation"
            );
          }
        }
        function findAllTypeAnnotations(identifier, node) {
          if (node.type === "TSTypeLiteral" || node.type === "ObjectTypeAnnotation" || node.type === "TSInterfaceBody") {
            const currentNode = [].concat(
              objectTypeAnnotations.get(identifier.name) || [],
              node
            );
            objectTypeAnnotations.set(identifier.name, currentNode);
          } else if (node.type === "TSParenthesizedType" && (node.typeAnnotation.type === "TSIntersectionType" || node.typeAnnotation.type === "TSUnionType")) {
            node.typeAnnotation.types.forEach((type) => {
              findAllTypeAnnotations(identifier, type);
            });
          } else if (node.type === "TSIntersectionType" || node.type === "TSUnionType" || node.type === "IntersectionTypeAnnotation" || node.type === "UnionTypeAnnotation") {
            node.types.forEach((type) => {
              findAllTypeAnnotations(identifier, type);
            });
          }
        }
        return {
          "ClassProperty, PropertyDefinition"(node) {
            if (!rule || !propsUtil.isPropTypesDeclaration(node)) {
              return;
            }
            if (node.value && node.value.type === "CallExpression" && propWrapperUtil.isPropWrapperFunction(
              context,
              getText(context, node.value.callee)
            )) {
              checkPropWrapperArguments(node, node.value.arguments);
            }
            if (node.value && node.value.properties) {
              validatePropNaming(node, node.value.properties);
            }
            if (node.typeAnnotation && node.typeAnnotation.typeAnnotation) {
              validatePropNaming(node, node.typeAnnotation.typeAnnotation.properties);
            }
          },
          MemberExpression(node) {
            if (!rule || !propsUtil.isPropTypesDeclaration(node)) {
              return;
            }
            const component = utils.getRelatedComponent(node);
            if (!component || !node.parent.right) {
              return;
            }
            const right = node.parent.right;
            if (right.type === "CallExpression" && propWrapperUtil.isPropWrapperFunction(
              context,
              getText(context, right.callee)
            )) {
              checkPropWrapperArguments(component.node, right.arguments);
              return;
            }
            validatePropNaming(component.node, node.parent.right.properties);
          },
          ObjectExpression(node) {
            if (!rule) {
              return;
            }
            node.properties.forEach((property) => {
              if (!propsUtil.isPropTypesDeclaration(property)) {
                return;
              }
              validatePropNaming(node, property.value.properties);
            });
          },
          TypeAlias(node) {
            findAllTypeAnnotations(node.id, node.right);
          },
          TSTypeAliasDeclaration(node) {
            findAllTypeAnnotations(node.id, node.typeAnnotation);
          },
          TSInterfaceDeclaration(node) {
            findAllTypeAnnotations(node.id, node.body);
          },
          // eslint-disable-next-line object-shorthand
          "Program:exit"() {
            if (!rule) {
              return;
            }
            values(components.list()).forEach((component) => {
              const annotation = getComponentTypeAnnotation(component);
              if (annotation) {
                let propType;
                if (annotation.type === "GenericTypeAnnotation") {
                  propType = objectTypeAnnotations.get(annotation.id.name);
                } else if (annotation.type === "ObjectTypeAnnotation" || annotation.type === "TSTypeLiteral") {
                  propType = annotation;
                } else if (annotation.type === "TSTypeReference") {
                  propType = objectTypeAnnotations.get(annotation.typeName.name);
                } else if (annotation.type === "TSIntersectionType") {
                  propType = flatMap(annotation.types, (type) => type.type === "TSTypeReference" ? objectTypeAnnotations.get(type.typeName.name) : type);
                }
                if (propType) {
                  [].concat(propType).forEach((prop) => {
                    validatePropNaming(
                      component.node,
                      prop.properties || prop.members || prop.body
                    );
                  });
                }
              }
              if (component.invalidProps && component.invalidProps.length > 0) {
                reportInvalidNaming(component);
              }
            });
            objectTypeAnnotations.clear();
          }
        };
      })
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/getProp.js
var require_getProp2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/getProp.js"(exports, module) {
    module.exports = require_lib().getProp;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/getLiteralPropValue.js
var require_getLiteralPropValue = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/getLiteralPropValue.js"(exports, module) {
    module.exports = require_lib().getLiteralPropValue;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/button-has-type.js
var require_button_has_type = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/button-has-type.js"(exports, module) {
    "use strict";
    var getProp = require_getProp2();
    var getLiteralPropValue = require_getLiteralPropValue();
    var docsUrl = require_docsUrl();
    var isCreateElement = require_isCreateElement();
    var report = require_report();
    var optionDefaults = {
      button: true,
      submit: true,
      reset: true
    };
    var messages = {
      missingType: "Missing an explicit type attribute for button",
      complexType: "The button type attribute must be specified by a static string or a trivial ternary expression",
      invalidValue: '"{{value}}" is an invalid value for button type attribute',
      forbiddenValue: '"{{value}}" is an invalid value for button type attribute'
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow usage of `button` elements without an explicit `type` attribute",
          category: "Possible Errors",
          recommended: false,
          url: docsUrl("button-has-type")
        },
        messages,
        schema: [{
          type: "object",
          properties: {
            button: {
              default: optionDefaults.button,
              type: "boolean"
            },
            submit: {
              default: optionDefaults.submit,
              type: "boolean"
            },
            reset: {
              default: optionDefaults.reset,
              type: "boolean"
            }
          },
          additionalProperties: false
        }]
      },
      create(context) {
        const configuration = Object.assign({}, optionDefaults, context.options[0]);
        function reportMissing(node) {
          report(context, messages.missingType, "missingType", {
            node
          });
        }
        function reportComplex(node) {
          report(context, messages.complexType, "complexType", {
            node
          });
        }
        function checkValue(node, value) {
          if (!(value in configuration)) {
            report(context, messages.invalidValue, "invalidValue", {
              node,
              data: {
                value
              }
            });
          } else if (!configuration[value]) {
            report(context, messages.forbiddenValue, "forbiddenValue", {
              node,
              data: {
                value
              }
            });
          }
        }
        function checkExpression(node, expression) {
          switch (expression.type) {
            case "Literal":
              checkValue(node, expression.value);
              return;
            case "TemplateLiteral":
              if (expression.expressions.length === 0) {
                checkValue(node, expression.quasis[0].value.raw);
              } else {
                reportComplex(expression);
              }
              return;
            case "ConditionalExpression":
              checkExpression(node, expression.consequent);
              checkExpression(node, expression.alternate);
              return;
            default:
              reportComplex(expression);
          }
        }
        return {
          JSXElement(node) {
            if (node.openingElement.name.name !== "button") {
              return;
            }
            const typeProp = getProp(node.openingElement.attributes, "type");
            if (!typeProp) {
              reportMissing(node);
              return;
            }
            if (typeProp.value && typeProp.value.type === "JSXExpressionContainer") {
              checkExpression(node, typeProp.value.expression);
              return;
            }
            const propValue = getLiteralPropValue(typeProp);
            checkValue(node, propValue);
          },
          CallExpression(node) {
            if (!isCreateElement(context, node) || node.arguments.length < 1) {
              return;
            }
            if (node.arguments[0].type !== "Literal" || node.arguments[0].value !== "button") {
              return;
            }
            if (!node.arguments[1] || node.arguments[1].type !== "ObjectExpression") {
              reportMissing(node);
              return;
            }
            const props = node.arguments[1].properties;
            const typeProp = props.find((prop) => prop.key && prop.key.name === "type");
            if (!typeProp) {
              reportMissing(node);
              return;
            }
            checkExpression(node, typeProp.value);
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/checked-requires-onchange-or-readonly.js
var require_checked_requires_onchange_or_readonly = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/checked-requires-onchange-or-readonly.js"(exports, module) {
    "use strict";
    var ASTUtils = require_lib();
    var flatMap = require_array_prototype();
    var isCreateElement = require_isCreateElement();
    var report = require_report();
    var docsUrl = require_docsUrl();
    var messages = {
      missingProperty: "`checked` should be used with either `onChange` or `readOnly`.",
      exclusiveCheckedAttribute: "Use either `checked` or `defaultChecked`, but not both."
    };
    var targetPropSet = /* @__PURE__ */ new Set(["checked", "onChange", "readOnly", "defaultChecked"]);
    var defaultOptions = {
      ignoreMissingProperties: false,
      ignoreExclusiveCheckedAttribute: false
    };
    function extractTargetProps(properties, keyName) {
      return new Set(
        flatMap(
          properties,
          (prop) => prop[keyName] && targetPropSet.has(prop[keyName].name) ? [prop[keyName].name] : []
        )
      );
    }
    module.exports = {
      meta: {
        docs: {
          description: "Enforce using `onChange` or `readonly` attribute when `checked` is used",
          category: "Best Practices",
          recommended: false,
          url: docsUrl("checked-requires-onchange-or-readonly")
        },
        messages,
        schema: [{
          additionalProperties: false,
          properties: {
            ignoreMissingProperties: {
              type: "boolean"
            },
            ignoreExclusiveCheckedAttribute: {
              type: "boolean"
            }
          }
        }]
      },
      create(context) {
        const options = Object.assign({}, defaultOptions, context.options[0]);
        function reportMissingProperty(node) {
          report(
            context,
            messages.missingProperty,
            "missingProperty",
            { node }
          );
        }
        function reportExclusiveCheckedAttribute(node) {
          report(
            context,
            messages.exclusiveCheckedAttribute,
            "exclusiveCheckedAttribute",
            { node }
          );
        }
        const checkAttributesAndReport = (node, propSet) => {
          if (!propSet.has("checked")) {
            return;
          }
          if (!options.ignoreExclusiveCheckedAttribute && propSet.has("defaultChecked")) {
            reportExclusiveCheckedAttribute(node);
          }
          if (!options.ignoreMissingProperties && !(propSet.has("onChange") || propSet.has("readOnly"))) {
            reportMissingProperty(node);
          }
        };
        return {
          JSXOpeningElement(node) {
            if (ASTUtils.elementType(node) !== "input") {
              return;
            }
            const propSet = extractTargetProps(node.attributes, "name");
            checkAttributesAndReport(node, propSet);
          },
          CallExpression(node) {
            if (!isCreateElement(context, node)) {
              return;
            }
            const firstArg = node.arguments[0];
            const secondArg = node.arguments[1];
            if (!firstArg || firstArg.type !== "Literal" || firstArg.value !== "input") {
              return;
            }
            if (!secondArg || secondArg.type !== "ObjectExpression") {
              return;
            }
            const propSet = extractTargetProps(secondArg.properties, "key");
            checkAttributesAndReport(node, propSet);
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/default-props-match-prop-types.js
var require_default_props_match_prop_types = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/default-props-match-prop-types.js"(exports, module) {
    "use strict";
    var values = require_object3();
    var Components = require_Components();
    var docsUrl = require_docsUrl();
    var report = require_report();
    var messages = {
      requiredHasDefault: 'defaultProp "{{name}}" defined for isRequired propType.',
      defaultHasNoType: 'defaultProp "{{name}}" has no corresponding propTypes declaration.'
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce all defaultProps have a corresponding non-required PropType",
          category: "Best Practices",
          url: docsUrl("default-props-match-prop-types")
        },
        messages,
        schema: [{
          type: "object",
          properties: {
            allowRequiredDefaults: {
              default: false,
              type: "boolean"
            }
          },
          additionalProperties: false
        }]
      },
      create: Components.detect((context, components) => {
        const configuration = context.options[0] || {};
        const allowRequiredDefaults = configuration.allowRequiredDefaults || false;
        function reportInvalidDefaultProps(propTypes, defaultProps) {
          if (defaultProps === "unresolved" || !propTypes || Object.keys(propTypes).length === 0) {
            return;
          }
          Object.keys(defaultProps).forEach((defaultPropName) => {
            const defaultProp = defaultProps[defaultPropName];
            const prop = propTypes[defaultPropName];
            if (prop && (allowRequiredDefaults || !prop.isRequired)) {
              return;
            }
            if (prop) {
              report(context, messages.requiredHasDefault, "requiredHasDefault", {
                node: defaultProp.node,
                data: {
                  name: defaultPropName
                }
              });
            } else {
              report(context, messages.defaultHasNoType, "defaultHasNoType", {
                node: defaultProp.node,
                data: {
                  name: defaultPropName
                }
              });
            }
          });
        }
        return {
          "Program:exit"() {
            values(components.list()).filter((component) => component.defaultProps).forEach((component) => {
              reportInvalidDefaultProps(
                component.declaredPropTypes,
                component.defaultProps || {}
              );
            });
          }
        };
      })
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/destructuring-assignment.js
var require_destructuring_assignment = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/destructuring-assignment.js"(exports, module) {
    "use strict";
    var Components = require_Components();
    var docsUrl = require_docsUrl();
    var eslintUtil = require_eslint();
    var isAssignmentLHS = require_ast().isAssignmentLHS;
    var report = require_report();
    var getScope = eslintUtil.getScope;
    var getText = eslintUtil.getText;
    var DEFAULT_OPTION = "always";
    function createSFCParams() {
      const queue = [];
      return {
        push(params) {
          queue.unshift(params);
        },
        pop() {
          queue.shift();
        },
        propsName() {
          const found = queue.find((params) => {
            const props = params[0];
            return props && !props.destructuring && props.name;
          });
          return found && found[0] && found[0].name;
        },
        contextName() {
          const found = queue.find((params) => {
            const context = params[1];
            return context && !context.destructuring && context.name;
          });
          return found && found[1] && found[1].name;
        }
      };
    }
    function evalParams(params) {
      return params.map((param) => ({
        destructuring: param.type === "ObjectPattern",
        name: param.type === "Identifier" && param.name
      }));
    }
    var messages = {
      noDestructPropsInSFCArg: "Must never use destructuring props assignment in SFC argument",
      noDestructContextInSFCArg: "Must never use destructuring context assignment in SFC argument",
      noDestructAssignment: "Must never use destructuring {{type}} assignment",
      useDestructAssignment: "Must use destructuring {{type}} assignment",
      destructureInSignature: "Must destructure props in the function signature."
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce consistent usage of destructuring assignment of props, state, and context",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("destructuring-assignment")
        },
        fixable: "code",
        messages,
        schema: [{
          type: "string",
          enum: [
            "always",
            "never"
          ]
        }, {
          type: "object",
          properties: {
            ignoreClassFields: {
              type: "boolean"
            },
            destructureInSignature: {
              type: "string",
              enum: [
                "always",
                "ignore"
              ]
            }
          },
          additionalProperties: false
        }]
      },
      create: Components.detect((context, components, utils) => {
        const configuration = context.options[0] || DEFAULT_OPTION;
        const ignoreClassFields = context.options[1] && context.options[1].ignoreClassFields === true || false;
        const destructureInSignature = context.options[1] && context.options[1].destructureInSignature || "ignore";
        const sfcParams = createSFCParams();
        function handleStatelessComponent(node) {
          const params = evalParams(node.params);
          const SFCComponent = components.get(getScope(context, node).block);
          if (!SFCComponent) {
            return;
          }
          sfcParams.push(params);
          if (params[0] && params[0].destructuring && components.get(node) && configuration === "never") {
            report(context, messages.noDestructPropsInSFCArg, "noDestructPropsInSFCArg", {
              node
            });
          } else if (params[1] && params[1].destructuring && components.get(node) && configuration === "never") {
            report(context, messages.noDestructContextInSFCArg, "noDestructContextInSFCArg", {
              node
            });
          }
        }
        function handleStatelessComponentExit(node) {
          const SFCComponent = components.get(getScope(context, node).block);
          if (SFCComponent) {
            sfcParams.pop();
          }
        }
        function handleSFCUsage(node) {
          const propsName = sfcParams.propsName();
          const contextName = sfcParams.contextName();
          const isPropUsed = (propsName && node.object.name === propsName || contextName && node.object.name === contextName) && !isAssignmentLHS(node);
          if (isPropUsed && configuration === "always" && !node.optional) {
            report(context, messages.useDestructAssignment, "useDestructAssignment", {
              node,
              data: {
                type: node.object.name
              }
            });
          }
        }
        function isInClassProperty(node) {
          let curNode = node.parent;
          while (curNode) {
            if (curNode.type === "ClassProperty" || curNode.type === "PropertyDefinition") {
              return true;
            }
            curNode = curNode.parent;
          }
          return false;
        }
        function handleClassUsage(node) {
          const isPropUsed = node.object.type === "MemberExpression" && node.object.object.type === "ThisExpression" && (node.object.property.name === "props" || node.object.property.name === "context" || node.object.property.name === "state") && !isAssignmentLHS(node);
          if (isPropUsed && configuration === "always" && !(ignoreClassFields && isInClassProperty(node))) {
            report(context, messages.useDestructAssignment, "useDestructAssignment", {
              node,
              data: {
                type: node.object.property.name
              }
            });
          }
        }
        return {
          FunctionDeclaration: handleStatelessComponent,
          ArrowFunctionExpression: handleStatelessComponent,
          FunctionExpression: handleStatelessComponent,
          "FunctionDeclaration:exit": handleStatelessComponentExit,
          "ArrowFunctionExpression:exit": handleStatelessComponentExit,
          "FunctionExpression:exit": handleStatelessComponentExit,
          MemberExpression(node) {
            let scope = getScope(context, node);
            let SFCComponent = components.get(scope.block);
            while (!SFCComponent && scope.upper && scope.upper !== scope) {
              SFCComponent = components.get(scope.upper.block);
              scope = scope.upper;
            }
            if (SFCComponent) {
              handleSFCUsage(node);
            }
            const classComponent = utils.getParentComponent(node);
            if (classComponent) {
              handleClassUsage(node);
            }
          },
          VariableDeclarator(node) {
            const classComponent = utils.getParentComponent(node);
            const SFCComponent = components.get(getScope(context, node).block);
            const destructuring = node.init && node.id && node.id.type === "ObjectPattern";
            const destructuringSFC = destructuring && (node.init.name === "props" || node.init.name === "context");
            const destructuringClass = destructuring && node.init.object && node.init.object.type === "ThisExpression" && (node.init.property.name === "props" || node.init.property.name === "context" || node.init.property.name === "state");
            if (SFCComponent && destructuringSFC && configuration === "never") {
              report(context, messages.noDestructAssignment, "noDestructAssignment", {
                node,
                data: {
                  type: node.init.name
                }
              });
            }
            if (classComponent && destructuringClass && configuration === "never" && !(ignoreClassFields && (node.parent.type === "ClassProperty" || node.parent.type === "PropertyDefinition"))) {
              report(context, messages.noDestructAssignment, "noDestructAssignment", {
                node,
                data: {
                  type: node.init.property.name
                }
              });
            }
            if (SFCComponent && destructuringSFC && configuration === "always" && destructureInSignature === "always" && node.init.name === "props") {
              const scopeSetProps = getScope(context, node).set.get("props");
              const propsRefs = scopeSetProps && scopeSetProps.references;
              if (!propsRefs) {
                return;
              }
              if (propsRefs.length > 1) {
                return;
              }
              report(context, messages.destructureInSignature, "destructureInSignature", {
                node,
                fix(fixer) {
                  const param = SFCComponent.node.params[0];
                  if (!param) {
                    return;
                  }
                  const replaceRange = [
                    param.range[0],
                    param.typeAnnotation ? param.typeAnnotation.range[0] : param.range[1]
                  ];
                  return [
                    fixer.replaceTextRange(replaceRange, getText(context, node.id)),
                    fixer.remove(node.parent)
                  ];
                }
              });
            }
          }
        };
      })
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.forEach/implementation.js
var require_implementation20 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.forEach/implementation.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var Call = require_Call();
    var GetIteratorDirect = require_GetIteratorDirect();
    var IsCallable = require_IsCallable();
    var IteratorClose = require_IteratorClose();
    var IteratorStepValue = require_IteratorStepValue();
    var ThrowCompletion = require_ThrowCompletion();
    var Type = require_Type2();
    module.exports = function forEach(fn) {
      if (this instanceof forEach) {
        throw new $TypeError("`forEach` is not a constructor");
      }
      var O = this;
      if (Type(O) !== "Object") {
        throw new $TypeError("`this` value must be an Object");
      }
      if (!IsCallable(fn)) {
        throw new $TypeError("`fn` must be a function");
      }
      var iterated = GetIteratorDirect(O);
      var counter = 0;
      while (true) {
        var value = IteratorStepValue(iterated);
        if (iterated["[[Done]]"]) {
          return void 0;
        }
        try {
          Call(fn, void 0, [value, counter]);
        } catch (e) {
          IteratorClose(
            iterated,
            ThrowCompletion(e)
          );
          throw e;
        } finally {
          counter += 1;
        }
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.forEach/polyfill.js
var require_polyfill18 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.forEach/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation20();
    module.exports = function getPolyfill() {
      return typeof Iterator === "function" && typeof Iterator.prototype.forEach === "function" ? Iterator.prototype.forEach : implementation;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.forEach/shim.js
var require_shim18 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.forEach/shim.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var getPolyfill = require_polyfill18();
    var $IteratorPrototype = require_implementation12();
    module.exports = function shimIteratorPrototypeForEach() {
      var polyfill = getPolyfill();
      define(
        $IteratorPrototype,
        { forEach: polyfill },
        { forEach: function() {
          return $IteratorPrototype.forEach !== polyfill;
        } }
      );
      return polyfill;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.forEach/index.js
var require_Iterator_prototype4 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.forEach/index.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation20();
    var getPolyfill = require_polyfill18();
    var shim = require_shim18();
    var polyfill = callBind(getPolyfill());
    define(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = polyfill;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/isCreateContext.js
var require_isCreateContext = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/isCreateContext.js"(exports, module) {
    "use strict";
    module.exports = function isCreateContext(node) {
      if (node.init && node.init.type === "CallExpression" && node.init.callee && node.init.callee.name === "createContext") {
        return true;
      }
      if (node.init && node.init.callee && node.init.callee.type === "MemberExpression" && node.init.callee.property && node.init.callee.property.name === "createContext") {
        return true;
      }
      if (node.expression && node.expression.type === "AssignmentExpression" && node.expression.operator === "=" && node.expression.right.type === "CallExpression" && node.expression.right.callee && node.expression.right.callee.name === "createContext") {
        return true;
      }
      if (node.expression && node.expression.type === "AssignmentExpression" && node.expression.operator === "=" && node.expression.right.type === "CallExpression" && node.expression.right.callee && node.expression.right.callee.type === "MemberExpression" && node.expression.right.callee.property && node.expression.right.callee.property.name === "createContext") {
        return true;
      }
      return false;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/display-name.js
var require_display_name = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/display-name.js"(exports, module) {
    "use strict";
    var values = require_object3();
    var filter = require_Iterator_prototype2();
    var forEach = require_Iterator_prototype4();
    var Components = require_Components();
    var isCreateContext = require_isCreateContext();
    var astUtil = require_ast();
    var componentUtil = require_componentUtil();
    var docsUrl = require_docsUrl();
    var testReactVersion = require_version().testReactVersion;
    var propsUtil = require_props();
    var report = require_report();
    var messages = {
      noDisplayName: "Component definition is missing display name",
      noContextDisplayName: "Context definition is missing display name"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow missing displayName in a React component definition",
          category: "Best Practices",
          recommended: true,
          url: docsUrl("display-name")
        },
        messages,
        schema: [{
          type: "object",
          properties: {
            ignoreTranspilerName: {
              type: "boolean"
            },
            checkContextObjects: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }]
      },
      create: Components.detect((context, components, utils) => {
        const config = context.options[0] || {};
        const ignoreTranspilerName = config.ignoreTranspilerName || false;
        const checkContextObjects = (config.checkContextObjects || false) && testReactVersion(context, ">= 16.3.0");
        const contextObjects = /* @__PURE__ */ new Map();
        function markDisplayNameAsDeclared(node) {
          components.set(node, {
            hasDisplayName: true
          });
        }
        function isNestedMemo(node) {
          const argumentIsCallExpression = node.arguments && node.arguments[0] && node.arguments[0].type === "CallExpression";
          return node.type === "CallExpression" && argumentIsCallExpression && utils.isPragmaComponentWrapper(node);
        }
        function reportMissingDisplayName(component) {
          if (testReactVersion(context, "^0.14.10 || ^15.7.0 || >= 16.12.0") && isNestedMemo(component.node)) {
            return;
          }
          report(context, messages.noDisplayName, "noDisplayName", {
            node: component.node
          });
        }
        function reportMissingContextDisplayName(contextObj) {
          report(context, messages.noContextDisplayName, "noContextDisplayName", {
            node: contextObj.node
          });
        }
        function hasTranspilerName(node) {
          const namedObjectAssignment = node.type === "ObjectExpression" && node.parent && node.parent.parent && node.parent.parent.type === "AssignmentExpression" && (!node.parent.parent.left.object || node.parent.parent.left.object.name !== "module" || node.parent.parent.left.property.name !== "exports");
          const namedObjectDeclaration = node.type === "ObjectExpression" && node.parent && node.parent.parent && node.parent.parent.type === "VariableDeclarator";
          const namedClass = (node.type === "ClassDeclaration" || node.type === "ClassExpression") && node.id && !!node.id.name;
          const namedFunctionDeclaration = (node.type === "FunctionDeclaration" || node.type === "FunctionExpression") && node.id && !!node.id.name;
          const namedFunctionExpression = astUtil.isFunctionLikeExpression(node) && node.parent && (node.parent.type === "VariableDeclarator" || node.parent.type === "Property" || node.parent.method === true) && (!node.parent.parent || !componentUtil.isES5Component(node.parent.parent, context));
          if (namedObjectAssignment || namedObjectDeclaration || namedClass || namedFunctionDeclaration || namedFunctionExpression) {
            return true;
          }
          return false;
        }
        return {
          ExpressionStatement(node) {
            if (checkContextObjects && isCreateContext(node)) {
              contextObjects.set(node.expression.left.name, { node, hasDisplayName: false });
            }
          },
          VariableDeclarator(node) {
            if (checkContextObjects && isCreateContext(node)) {
              contextObjects.set(node.id.name, { node, hasDisplayName: false });
            }
          },
          "ClassProperty, PropertyDefinition"(node) {
            if (!propsUtil.isDisplayNameDeclaration(node)) {
              return;
            }
            markDisplayNameAsDeclared(node);
          },
          MemberExpression(node) {
            if (!propsUtil.isDisplayNameDeclaration(node.property)) {
              return;
            }
            if (checkContextObjects && node.object && node.object.name && contextObjects.has(node.object.name)) {
              contextObjects.get(node.object.name).hasDisplayName = true;
            }
            const component = utils.getRelatedComponent(node);
            if (!component) {
              return;
            }
            markDisplayNameAsDeclared(component.node.type === "TSAsExpression" ? component.node.expression : component.node);
          },
          "FunctionExpression, FunctionDeclaration, ArrowFunctionExpression"(node) {
            if (ignoreTranspilerName || !hasTranspilerName(node)) {
              return;
            }
            if (components.get(node)) {
              markDisplayNameAsDeclared(node);
            }
          },
          MethodDefinition(node) {
            if (!propsUtil.isDisplayNameDeclaration(node.key)) {
              return;
            }
            markDisplayNameAsDeclared(node);
          },
          "ClassExpression, ClassDeclaration"(node) {
            if (ignoreTranspilerName || !hasTranspilerName(node)) {
              return;
            }
            markDisplayNameAsDeclared(node);
          },
          ObjectExpression(node) {
            if (!componentUtil.isES5Component(node, context)) {
              return;
            }
            if (ignoreTranspilerName || !hasTranspilerName(node)) {
              node.properties.forEach((property) => {
                if (!property.key || !propsUtil.isDisplayNameDeclaration(property.key)) {
                  return;
                }
                markDisplayNameAsDeclared(node);
              });
              return;
            }
            markDisplayNameAsDeclared(node);
          },
          CallExpression(node) {
            if (!utils.isPragmaComponentWrapper(node)) {
              return;
            }
            if (node.arguments.length > 0 && astUtil.isFunctionLikeExpression(node.arguments[0])) {
              const isWrappedInAnotherPragma = utils.getPragmaComponentWrapper(node);
              if (!isWrappedInAnotherPragma && (ignoreTranspilerName || !hasTranspilerName(node.arguments[0]))) {
                return;
              }
              if (components.get(node)) {
                markDisplayNameAsDeclared(node);
              }
            }
          },
          "Program:exit"() {
            const list = components.list();
            values(list).filter((component) => !component.hasDisplayName).forEach((component) => {
              reportMissingDisplayName(component);
            });
            if (checkContextObjects) {
              forEach(
                filter(contextObjects.values(), (v) => !v.hasDisplayName),
                (contextObj) => reportMissingContextDisplayName(contextObj)
              );
            }
          }
        };
      })
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/forbid-component-props.js
var require_forbid_component_props = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/forbid-component-props.js"(exports, module) {
    "use strict";
    var docsUrl = require_docsUrl();
    var report = require_report();
    var DEFAULTS = ["className", "style"];
    var messages = {
      propIsForbidden: 'Prop "{{prop}}" is forbidden on Components'
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow certain props on components",
          category: "Best Practices",
          recommended: false,
          url: docsUrl("forbid-component-props")
        },
        messages,
        schema: [{
          type: "object",
          properties: {
            forbid: {
              type: "array",
              items: {
                anyOf: [
                  { type: "string" },
                  {
                    type: "object",
                    properties: {
                      propName: { type: "string" },
                      allowedFor: {
                        type: "array",
                        uniqueItems: true,
                        items: { type: "string" }
                      },
                      message: { type: "string" }
                    },
                    additionalProperties: false
                  },
                  {
                    type: "object",
                    properties: {
                      propName: { type: "string" },
                      disallowedFor: {
                        type: "array",
                        uniqueItems: true,
                        minItems: 1,
                        items: { type: "string" }
                      },
                      message: { type: "string" }
                    },
                    required: ["disallowedFor"],
                    additionalProperties: false
                  }
                ]
              }
            }
          }
        }]
      },
      create(context) {
        const configuration = context.options[0] || {};
        const forbid = new Map((configuration.forbid || DEFAULTS).map((value) => {
          const propName = typeof value === "string" ? value : value.propName;
          const options = {
            allowList: typeof value === "string" ? [] : value.allowedFor || [],
            disallowList: typeof value === "string" ? [] : value.disallowedFor || [],
            message: typeof value === "string" ? null : value.message
          };
          return [propName, options];
        }));
        function isForbidden(prop, tagName) {
          const options = forbid.get(prop);
          if (!options) {
            return false;
          }
          const isTagForbidden = options.disallowList.length > 0 ? options.disallowList.indexOf(tagName) !== -1 : options.allowList.indexOf(tagName) === -1;
          return typeof tagName === "undefined" || isTagForbidden;
        }
        return {
          JSXAttribute(node) {
            const parentName = node.parent.name;
            const tag = parentName.name || `${parentName.object.name}.${parentName.property.name}`;
            const componentName = parentName.name || parentName.property.name;
            if (componentName && typeof componentName[0] === "string" && componentName[0] !== componentName[0].toUpperCase()) {
              return;
            }
            const prop = node.name.name;
            if (!isForbidden(prop, tag)) {
              return;
            }
            const customMessage = forbid.get(prop).message;
            report(context, customMessage || messages.propIsForbidden, !customMessage && "propIsForbidden", {
              node,
              data: {
                prop
              }
            });
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/forbid-dom-props.js
var require_forbid_dom_props = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/forbid-dom-props.js"(exports, module) {
    "use strict";
    var docsUrl = require_docsUrl();
    var report = require_report();
    var DEFAULTS = [];
    function isForbidden(forbidMap, prop, tagName) {
      const options = forbidMap.get(prop);
      return options && (typeof tagName === "undefined" || !options.disallowList || options.disallowList.indexOf(tagName) !== -1);
    }
    var messages = {
      propIsForbidden: 'Prop "{{prop}}" is forbidden on DOM Nodes'
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow certain props on DOM Nodes",
          category: "Best Practices",
          recommended: false,
          url: docsUrl("forbid-dom-props")
        },
        messages,
        schema: [{
          type: "object",
          properties: {
            forbid: {
              type: "array",
              items: {
                anyOf: [{
                  type: "string"
                }, {
                  type: "object",
                  properties: {
                    propName: {
                      type: "string"
                    },
                    disallowedFor: {
                      type: "array",
                      uniqueItems: true,
                      items: {
                        type: "string"
                      }
                    },
                    message: {
                      type: "string"
                    }
                  }
                }],
                minLength: 1
              },
              uniqueItems: true
            }
          },
          additionalProperties: false
        }]
      },
      create(context) {
        const configuration = context.options[0] || {};
        const forbid = new Map((configuration.forbid || DEFAULTS).map((value) => {
          const propName = typeof value === "string" ? value : value.propName;
          return [propName, {
            disallowList: typeof value === "string" ? null : value.disallowedFor || null,
            message: typeof value === "string" ? null : value.message
          }];
        }));
        return {
          JSXAttribute(node) {
            const tag = node.parent.name.name;
            if (!(tag && typeof tag === "string" && tag[0] !== tag[0].toUpperCase())) {
              return;
            }
            const prop = node.name.name;
            if (!isForbidden(forbid, prop, tag)) {
              return;
            }
            const customMessage = forbid.get(prop).message;
            report(context, customMessage || messages.propIsForbidden, !customMessage && "propIsForbidden", {
              node,
              data: {
                prop
              }
            });
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/HasOwnProperty.js
var require_HasOwnProperty2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/HasOwnProperty.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var hasOwn = require_hasown();
    var IsPropertyKey = require_IsPropertyKey();
    var Type = require_Type2();
    module.exports = function HasOwnProperty(O, P) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: `O` must be an Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: `P` must be a Property Key");
      }
      return hasOwn(O, P);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.hasown@1.1.4/node_modules/object.hasown/implementation.js
var require_implementation21 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.hasown@1.1.4/node_modules/object.hasown/implementation.js"(exports, module) {
    "use strict";
    var ToObject = require_ToObject();
    var ToPropertyKey = require_ToPropertyKey();
    var HasOwnProperty = require_HasOwnProperty2();
    module.exports = function hasOwn(O, P) {
      var obj = ToObject(O);
      var key = ToPropertyKey(P);
      return HasOwnProperty(obj, key);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.hasown@1.1.4/node_modules/object.hasown/polyfill.js
var require_polyfill19 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object.hasown@1.1.4/node_modules/object.hasown/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation21();
    module.exports = function getPolyfill() {
      return Object.hasOwn || implementation;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/forbid-elements.js
var require_forbid_elements = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/forbid-elements.js"(exports, module) {
    "use strict";
    var has = require_polyfill19()();
    var docsUrl = require_docsUrl();
    var getText = require_eslint().getText;
    var isCreateElement = require_isCreateElement();
    var report = require_report();
    var messages = {
      forbiddenElement: "<{{element}}> is forbidden",
      forbiddenElement_message: "<{{element}}> is forbidden, {{message}}"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow certain elements",
          category: "Best Practices",
          recommended: false,
          url: docsUrl("forbid-elements")
        },
        messages,
        schema: [{
          type: "object",
          properties: {
            forbid: {
              type: "array",
              items: {
                anyOf: [
                  { type: "string" },
                  {
                    type: "object",
                    properties: {
                      element: { type: "string" },
                      message: { type: "string" }
                    },
                    required: ["element"],
                    additionalProperties: false
                  }
                ]
              }
            }
          },
          additionalProperties: false
        }]
      },
      create(context) {
        const configuration = context.options[0] || {};
        const forbidConfiguration = configuration.forbid || [];
        const indexedForbidConfigs = {};
        forbidConfiguration.forEach((item) => {
          if (typeof item === "string") {
            indexedForbidConfigs[item] = { element: item };
          } else {
            indexedForbidConfigs[item.element] = item;
          }
        });
        function reportIfForbidden(element, node) {
          if (has(indexedForbidConfigs, element)) {
            const message = indexedForbidConfigs[element].message;
            report(
              context,
              message ? messages.forbiddenElement_message : messages.forbiddenElement,
              message ? "forbiddenElement_message" : "forbiddenElement",
              {
                node,
                data: {
                  element,
                  message
                }
              }
            );
          }
        }
        return {
          JSXOpeningElement(node) {
            reportIfForbidden(getText(context, node.name), node.name);
          },
          CallExpression(node) {
            if (!isCreateElement(context, node)) {
              return;
            }
            const argument = node.arguments[0];
            if (!argument) {
              return;
            }
            const argType = argument.type;
            if (argType === "Identifier" && /^[A-Z_]/.test(argument.name)) {
              reportIfForbidden(argument.name, argument);
            } else if (argType === "Literal" && /^[a-z][^.]*$/.test(argument.value)) {
              reportIfForbidden(argument.value, argument);
            } else if (argType === "MemberExpression") {
              reportIfForbidden(getText(context, argument), argument);
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/forbid-foreign-prop-types.js
var require_forbid_foreign_prop_types = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/forbid-foreign-prop-types.js"(exports, module) {
    "use strict";
    var docsUrl = require_docsUrl();
    var ast = require_ast();
    var report = require_report();
    var messages = {
      forbiddenPropType: "Using propTypes from another component is not safe because they may be removed in production builds"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow using another component's propTypes",
          category: "Best Practices",
          recommended: false,
          url: docsUrl("forbid-foreign-prop-types")
        },
        messages,
        schema: [
          {
            type: "object",
            properties: {
              allowInPropTypes: {
                type: "boolean"
              }
            },
            additionalProperties: false
          }
        ]
      },
      create(context) {
        const config = context.options[0] || {};
        const allowInPropTypes = config.allowInPropTypes || false;
        function findParentAssignmentExpression(node) {
          let parent = node.parent;
          while (parent && parent.type !== "Program") {
            if (parent.type === "AssignmentExpression") {
              return parent;
            }
            parent = parent.parent;
          }
          return null;
        }
        function findParentClassProperty(node) {
          let parent = node.parent;
          while (parent && parent.type !== "Program") {
            if (parent.type === "ClassProperty" || parent.type === "PropertyDefinition") {
              return parent;
            }
            parent = parent.parent;
          }
          return null;
        }
        function isAllowedAssignment(node) {
          if (!allowInPropTypes) {
            return false;
          }
          const assignmentExpression = findParentAssignmentExpression(node);
          if (assignmentExpression && assignmentExpression.left && assignmentExpression.left.property && assignmentExpression.left.property.name === "propTypes") {
            return true;
          }
          const classProperty = findParentClassProperty(node);
          if (classProperty && classProperty.key && classProperty.key.name === "propTypes") {
            return true;
          }
          return false;
        }
        return {
          MemberExpression(node) {
            if (node.property && (!node.computed && node.property.type === "Identifier" && node.property.name === "propTypes" && !ast.isAssignmentLHS(node) && !isAllowedAssignment(node)) || (node.property.type === "Literal" || node.property.type === "JSXText") && node.property.value === "propTypes" && !ast.isAssignmentLHS(node) && !isAllowedAssignment(node)) {
              report(context, messages.forbiddenPropType, "forbiddenPropType", {
                node: node.property
              });
            }
          },
          ObjectPattern(node) {
            const propTypesNode = node.properties.find((property) => property.type === "Property" && property.key.name === "propTypes");
            if (propTypesNode) {
              report(context, messages.forbiddenPropType, "forbiddenPropType", {
                node: propTypesNode
              });
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/forbid-prop-types.js
var require_forbid_prop_types = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/forbid-prop-types.js"(exports, module) {
    "use strict";
    var variableUtil = require_variable();
    var propsUtil = require_props();
    var astUtil = require_ast();
    var docsUrl = require_docsUrl();
    var propWrapperUtil = require_propWrapper();
    var report = require_report();
    var getText = require_eslint().getText;
    var DEFAULTS = ["any", "array", "object"];
    var messages = {
      forbiddenPropType: 'Prop type "{{target}}" is forbidden'
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow certain propTypes",
          category: "Best Practices",
          recommended: false,
          url: docsUrl("forbid-prop-types")
        },
        messages,
        schema: [{
          type: "object",
          properties: {
            forbid: {
              type: "array",
              items: {
                type: "string"
              }
            },
            checkContextTypes: {
              type: "boolean"
            },
            checkChildContextTypes: {
              type: "boolean"
            }
          },
          additionalProperties: true
        }]
      },
      create(context) {
        const configuration = context.options[0] || {};
        const checkContextTypes = configuration.checkContextTypes || false;
        const checkChildContextTypes = configuration.checkChildContextTypes || false;
        let propTypesPackageName = null;
        let reactPackageName = null;
        let isForeignPropTypesPackage = false;
        function isPropTypesPackage(node) {
          return node.type === "Identifier" && (node.name === null || node.name === propTypesPackageName || !isForeignPropTypesPackage) || node.type === "MemberExpression" && (node.object.name === null || node.object.name === reactPackageName || !isForeignPropTypesPackage);
        }
        function isForbidden(type) {
          const forbid = configuration.forbid || DEFAULTS;
          return forbid.indexOf(type) >= 0;
        }
        function reportIfForbidden(type, declaration, target) {
          if (isForbidden(type)) {
            report(context, messages.forbiddenPropType, "forbiddenPropType", {
              node: declaration,
              data: {
                target
              }
            });
          }
        }
        function shouldCheckContextTypes(node) {
          if (checkContextTypes && propsUtil.isContextTypesDeclaration(node)) {
            return true;
          }
          return false;
        }
        function shouldCheckChildContextTypes(node) {
          if (checkChildContextTypes && propsUtil.isChildContextTypesDeclaration(node)) {
            return true;
          }
          return false;
        }
        function checkProperties(declarations) {
          if (declarations) {
            declarations.forEach((declaration) => {
              if (declaration.type !== "Property") {
                return;
              }
              let target;
              let value = declaration.value;
              if (value.type === "MemberExpression" && value.property && value.property.name && value.property.name === "isRequired") {
                value = value.object;
              }
              if (value.type === "CallExpression") {
                if (!isPropTypesPackage(value.callee)) {
                  return;
                }
                value.arguments.forEach((arg) => {
                  const name = arg.type === "MemberExpression" ? arg.property.name : arg.name;
                  reportIfForbidden(name, declaration, name);
                });
                value = value.callee;
              }
              if (!isPropTypesPackage(value)) {
                return;
              }
              if (value.property) {
                target = value.property.name;
              } else if (value.type === "Identifier") {
                target = value.name;
              }
              reportIfForbidden(target, declaration, target);
            });
          }
        }
        function checkNode(node) {
          switch (node && node.type) {
            case "ObjectExpression":
              checkProperties(node.properties);
              break;
            case "Identifier": {
              const propTypesObject = variableUtil.findVariableByName(context, node, node.name);
              if (propTypesObject && propTypesObject.properties) {
                checkProperties(propTypesObject.properties);
              }
              break;
            }
            case "CallExpression": {
              const innerNode = node.arguments && node.arguments[0];
              if (propWrapperUtil.isPropWrapperFunction(context, getText(context, node.callee)) && innerNode) {
                checkNode(innerNode);
              }
              break;
            }
            default:
              break;
          }
        }
        return {
          ImportDeclaration(node) {
            if (node.source && node.source.value === "prop-types") {
              if (node.specifiers.length > 0) {
                propTypesPackageName = node.specifiers[0].local.name;
              }
            } else if (node.source && node.source.value === "react") {
              if (node.specifiers.length > 0) {
                reactPackageName = node.specifiers[0].local.name;
              }
              if (node.specifiers.length >= 1) {
                const propTypesSpecifier = node.specifiers.find((specifier) => specifier.imported && specifier.imported.name === "PropTypes");
                if (propTypesSpecifier) {
                  propTypesPackageName = propTypesSpecifier.local.name;
                }
              }
            } else {
              if (node.specifiers.some((x) => x.local.name === "PropTypes")) {
                isForeignPropTypesPackage = true;
              }
            }
          },
          "ClassProperty, PropertyDefinition"(node) {
            if (!propsUtil.isPropTypesDeclaration(node) && !isPropTypesPackage(node) && !shouldCheckContextTypes(node) && !shouldCheckChildContextTypes(node)) {
              return;
            }
            checkNode(node.value);
          },
          MemberExpression(node) {
            if (!propsUtil.isPropTypesDeclaration(node) && !isPropTypesPackage(node) && !shouldCheckContextTypes(node) && !shouldCheckChildContextTypes(node)) {
              return;
            }
            checkNode(node.parent.right);
          },
          CallExpression(node) {
            if (node.callee.object && !isPropTypesPackage(node.callee.object) && !propsUtil.isPropTypesDeclaration(node.callee)) {
              return;
            }
            if (node.arguments.length > 0 && (node.callee.name === "shape" || astUtil.getPropertyName(node.callee) === "shape")) {
              checkProperties(node.arguments[0].properties);
            }
          },
          MethodDefinition(node) {
            if (!propsUtil.isPropTypesDeclaration(node) && !isPropTypesPackage(node) && !shouldCheckContextTypes(node) && !shouldCheckChildContextTypes(node)) {
              return;
            }
            const returnStatement = astUtil.findReturnStatement(node);
            if (returnStatement && returnStatement.argument) {
              checkNode(returnStatement.argument);
            }
          },
          ObjectExpression(node) {
            node.properties.forEach((property) => {
              if (!property.key) {
                return;
              }
              if (!propsUtil.isPropTypesDeclaration(property) && !isPropTypesPackage(property) && !shouldCheckContextTypes(property) && !shouldCheckChildContextTypes(property)) {
                return;
              }
              if (property.value.type === "ObjectExpression") {
                checkProperties(property.value.properties);
              }
            });
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/function-component-definition.js
var require_function_component_definition = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/function-component-definition.js"(exports, module) {
    "use strict";
    var arrayIncludes = require_array_includes();
    var Components = require_Components();
    var docsUrl = require_docsUrl();
    var reportC = require_report();
    var getText = require_eslint().getText;
    function buildFunction(template, parts) {
      return Object.keys(parts).reduce(
        (acc, key) => acc.replace(`{${key}}`, () => parts[key] || ""),
        template
      );
    }
    var NAMED_FUNCTION_TEMPLATES = {
      "function-declaration": "function {name}{typeParams}({params}){returnType} {body}",
      "arrow-function": "{varType} {name}{typeAnnotation} = {typeParams}({params}){returnType} => {body}",
      "function-expression": "{varType} {name}{typeAnnotation} = function{typeParams}({params}){returnType} {body}"
    };
    var UNNAMED_FUNCTION_TEMPLATES = {
      "function-expression": "function{typeParams}({params}){returnType} {body}",
      "arrow-function": "{typeParams}({params}){returnType} => {body}"
    };
    function hasOneUnconstrainedTypeParam(node) {
      const nodeTypeParams = node.typeParameters;
      return nodeTypeParams && nodeTypeParams.params && nodeTypeParams.params.length === 1 && !nodeTypeParams.params[0].constraint;
    }
    function hasName(node) {
      return node.type === "FunctionDeclaration" || node.parent.type === "VariableDeclarator";
    }
    function getNodeText(prop, source) {
      if (!prop)
        return null;
      return source.slice(prop.range[0], prop.range[1]);
    }
    function getName(node) {
      if (node.type === "FunctionDeclaration") {
        return node.id.name;
      }
      if (node.type === "ArrowFunctionExpression" || node.type === "FunctionExpression") {
        return hasName(node) && node.parent.id.name;
      }
    }
    function getParams(node, source) {
      if (node.params.length === 0)
        return null;
      return source.slice(
        node.params[0].range[0],
        node.params[node.params.length - 1].range[1]
      );
    }
    function getBody(node, source) {
      const range = node.body.range;
      if (node.body.type !== "BlockStatement") {
        return ["{", `  return ${source.slice(range[0], range[1])}`, "}"].join("\n");
      }
      return source.slice(range[0], range[1]);
    }
    function getTypeAnnotation(node, source) {
      if (!hasName(node) || node.type === "FunctionDeclaration")
        return;
      if (node.type === "ArrowFunctionExpression" || node.type === "FunctionExpression") {
        return getNodeText(node.parent.id.typeAnnotation, source);
      }
    }
    function isUnfixableBecauseOfExport(node) {
      return node.type === "FunctionDeclaration" && node.parent && node.parent.type === "ExportDefaultDeclaration";
    }
    function isFunctionExpressionWithName(node) {
      return node.type === "FunctionExpression" && node.id && node.id.name;
    }
    var messages = {
      "function-declaration": "Function component is not a function declaration",
      "function-expression": "Function component is not a function expression",
      "arrow-function": "Function component is not an arrow function"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce a specific function type for function components",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("function-component-definition")
        },
        fixable: "code",
        messages,
        schema: [
          {
            type: "object",
            properties: {
              namedComponents: {
                anyOf: [
                  {
                    enum: [
                      "function-declaration",
                      "arrow-function",
                      "function-expression"
                    ]
                  },
                  {
                    type: "array",
                    items: {
                      type: "string",
                      enum: [
                        "function-declaration",
                        "arrow-function",
                        "function-expression"
                      ]
                    }
                  }
                ]
              },
              unnamedComponents: {
                anyOf: [
                  { enum: ["arrow-function", "function-expression"] },
                  {
                    type: "array",
                    items: {
                      type: "string",
                      enum: ["arrow-function", "function-expression"]
                    }
                  }
                ]
              }
            }
          }
        ]
      },
      create: Components.detect((context, components) => {
        const configuration = context.options[0] || {};
        let fileVarType = "var";
        const namedConfig = [].concat(
          configuration.namedComponents || "function-declaration"
        );
        const unnamedConfig = [].concat(
          configuration.unnamedComponents || "function-expression"
        );
        function getFixer(node, options) {
          const source = getText(context);
          const typeAnnotation = getTypeAnnotation(node, source);
          if (options.type === "function-declaration" && typeAnnotation) {
            return;
          }
          if (options.type === "arrow-function" && hasOneUnconstrainedTypeParam(node)) {
            return;
          }
          if (isUnfixableBecauseOfExport(node))
            return;
          if (isFunctionExpressionWithName(node))
            return;
          let varType = fileVarType;
          if ((node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression") && node.parent.type === "VariableDeclarator") {
            varType = node.parent.parent.kind;
          }
          return (fixer) => fixer.replaceTextRange(
            options.range,
            buildFunction(options.template, {
              typeAnnotation,
              typeParams: getNodeText(node.typeParameters, source),
              params: getParams(node, source),
              returnType: getNodeText(node.returnType, source),
              body: getBody(node, source),
              name: getName(node),
              varType
            })
          );
        }
        function report(node, options) {
          reportC(context, messages[options.messageId], options.messageId, {
            node,
            fix: getFixer(node, options.fixerOptions)
          });
        }
        function validate(node, functionType) {
          if (!components.get(node))
            return;
          if (node.parent && node.parent.type === "Property")
            return;
          if (hasName(node) && !arrayIncludes(namedConfig, functionType)) {
            report(node, {
              messageId: namedConfig[0],
              fixerOptions: {
                type: namedConfig[0],
                template: NAMED_FUNCTION_TEMPLATES[namedConfig[0]],
                range: node.type === "FunctionDeclaration" ? node.range : node.parent.parent.range
              }
            });
          }
          if (!hasName(node) && !arrayIncludes(unnamedConfig, functionType)) {
            report(node, {
              messageId: unnamedConfig[0],
              fixerOptions: {
                type: unnamedConfig[0],
                template: UNNAMED_FUNCTION_TEMPLATES[unnamedConfig[0]],
                range: node.range
              }
            });
          }
        }
        const validatePairs = [];
        let hasES6OrJsx = false;
        return {
          FunctionDeclaration(node) {
            validatePairs.push([node, "function-declaration"]);
          },
          ArrowFunctionExpression(node) {
            validatePairs.push([node, "arrow-function"]);
          },
          FunctionExpression(node) {
            validatePairs.push([node, "function-expression"]);
          },
          VariableDeclaration(node) {
            hasES6OrJsx = hasES6OrJsx || node.kind === "const" || node.kind === "let";
          },
          "Program:exit"() {
            if (hasES6OrJsx)
              fileVarType = "const";
            validatePairs.forEach((pair) => validate(pair[0], pair[1]));
          },
          "ImportDeclaration, ExportNamedDeclaration, ExportDefaultDeclaration, ExportAllDeclaration, ExportSpecifier, ExportDefaultSpecifier, JSXElement, TSExportAssignment, TSImportEqualsDeclaration"() {
            hasES6OrJsx = true;
          }
        };
      })
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/hook-use-state.js
var require_hook_use_state = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/hook-use-state.js"(exports, module) {
    "use strict";
    var Components = require_Components();
    var docsUrl = require_docsUrl();
    var report = require_report();
    var getMessageData = require_message();
    var getText = require_eslint().getText;
    function isNodeDestructuring(node) {
      return node && (node.type === "ArrayPattern" || node.type === "ObjectPattern");
    }
    var messages = {
      useStateErrorMessage: "useState call is not destructured into value + setter pair",
      useStateErrorMessageOrAddOption: 'useState call is not destructured into value + setter pair (you can allow destructuring by enabling "allowDestructuredState" option)',
      suggestPair: "Destructure useState call into value + setter pair",
      suggestMemo: "Replace useState call with useMemo"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Ensure destructuring and symmetric naming of useState hook value and setter variables",
          category: "Best Practices",
          recommended: false,
          url: docsUrl("hook-use-state")
        },
        messages,
        schema: [{
          type: "object",
          properties: {
            allowDestructuredState: {
              default: false,
              type: "boolean"
            }
          },
          additionalProperties: false
        }],
        type: "suggestion",
        hasSuggestions: true
      },
      create: Components.detect((context, components, util) => {
        const configuration = context.options[0] || {};
        const allowDestructuredState = configuration.allowDestructuredState || false;
        return {
          CallExpression(node) {
            const isImmediateReturn = node.parent && node.parent.type === "ReturnStatement";
            if (isImmediateReturn || !util.isReactHookCall(node, ["useState"])) {
              return;
            }
            const isDestructuringDeclarator = node.parent && node.parent.type === "VariableDeclarator" && node.parent.id.type === "ArrayPattern";
            if (!isDestructuringDeclarator) {
              report(
                context,
                messages.useStateErrorMessage,
                "useStateErrorMessage",
                {
                  node,
                  suggest: false
                }
              );
              return;
            }
            const variableNodes = node.parent.id.elements;
            const valueVariable = variableNodes[0];
            const setterVariable = variableNodes[1];
            const isOnlyValueDestructuring = isNodeDestructuring(valueVariable) && !isNodeDestructuring(setterVariable);
            if (allowDestructuredState && isOnlyValueDestructuring) {
              return;
            }
            const valueVariableName = valueVariable ? valueVariable.name : void 0;
            const setterVariableName = setterVariable ? setterVariable.name : void 0;
            const caseCandidateMatch = valueVariableName ? valueVariableName.match(/(^[a-z]+)(.*)/) : void 0;
            const upperCaseCandidatePrefix = caseCandidateMatch ? caseCandidateMatch[1] : void 0;
            const caseCandidateSuffix = caseCandidateMatch ? caseCandidateMatch[2] : void 0;
            const expectedSetterVariableNames = upperCaseCandidatePrefix ? [
              `set${upperCaseCandidatePrefix.charAt(0).toUpperCase()}${upperCaseCandidatePrefix.slice(1)}${caseCandidateSuffix}`,
              `set${upperCaseCandidatePrefix.toUpperCase()}${caseCandidateSuffix}`
            ] : [];
            const isSymmetricGetterSetterPair = valueVariable && setterVariable && expectedSetterVariableNames.indexOf(setterVariableName) !== -1 && variableNodes.length === 2;
            if (!isSymmetricGetterSetterPair) {
              const suggestions = [
                Object.assign(
                  getMessageData("suggestPair", messages.suggestPair),
                  {
                    fix(fixer) {
                      if (expectedSetterVariableNames.length > 0) {
                        return fixer.replaceTextRange(
                          node.parent.id.range,
                          `[${valueVariableName}, ${expectedSetterVariableNames[0]}]`
                        );
                      }
                    }
                  }
                )
              ];
              const defaultReactImports = components.getDefaultReactImports();
              const defaultReactImportSpecifier = defaultReactImports ? defaultReactImports[0] : void 0;
              const defaultReactImportName = defaultReactImportSpecifier ? defaultReactImportSpecifier.local.name : void 0;
              const namedReactImports = components.getNamedReactImports();
              const useStateReactImportSpecifier = namedReactImports ? namedReactImports.find((specifier) => specifier.imported.name === "useState") : void 0;
              const isSingleGetter = valueVariable && variableNodes.length === 1;
              const isUseStateCalledWithSingleArgument = node.arguments.length === 1;
              if (isSingleGetter && isUseStateCalledWithSingleArgument) {
                const useMemoReactImportSpecifier = namedReactImports && namedReactImports.find((specifier) => specifier.imported.name === "useMemo");
                let useMemoCode;
                if (useMemoReactImportSpecifier) {
                  useMemoCode = useMemoReactImportSpecifier.local.name;
                } else if (defaultReactImportName) {
                  useMemoCode = `${defaultReactImportName}.useMemo`;
                } else {
                  useMemoCode = "useMemo";
                }
                suggestions.unshift(Object.assign(
                  getMessageData("suggestMemo", messages.suggestMemo),
                  {
                    fix: (fixer) => [
                      // Add useMemo import, if necessary
                      useStateReactImportSpecifier && (!useMemoReactImportSpecifier || defaultReactImportName) && fixer.insertTextAfter(useStateReactImportSpecifier, ", useMemo"),
                      // Convert single-value destructure to simple assignment
                      fixer.replaceTextRange(node.parent.id.range, valueVariableName),
                      // Convert useState call to useMemo + arrow function + dependency array
                      fixer.replaceTextRange(
                        node.range,
                        `${useMemoCode}(() => ${getText(context, node.arguments[0])}, [])`
                      )
                    ].filter(Boolean)
                  }
                ));
              }
              if (isOnlyValueDestructuring) {
                report(
                  context,
                  messages.useStateErrorMessageOrAddOption,
                  "useStateErrorMessageOrAddOption",
                  {
                    node: node.parent.id,
                    suggest: false
                  }
                );
                return;
              }
              report(
                context,
                messages.useStateErrorMessage,
                "useStateErrorMessage",
                {
                  node: node.parent.id,
                  suggest: suggestions
                }
              );
            }
          }
        };
      })
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/iframe-missing-sandbox.js
var require_iframe_missing_sandbox = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/iframe-missing-sandbox.js"(exports, module) {
    "use strict";
    var docsUrl = require_docsUrl();
    var isCreateElement = require_isCreateElement();
    var report = require_report();
    var messages = {
      attributeMissing: "An iframe element is missing a sandbox attribute",
      invalidValue: 'An iframe element defines a sandbox attribute with invalid value "{{ value }}"',
      invalidCombination: "An iframe element defines a sandbox attribute with both allow-scripts and allow-same-origin which is invalid"
    };
    var ALLOWED_VALUES = [
      // From https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox
      "",
      "allow-downloads-without-user-activation",
      "allow-downloads",
      "allow-forms",
      "allow-modals",
      "allow-orientation-lock",
      "allow-pointer-lock",
      "allow-popups",
      "allow-popups-to-escape-sandbox",
      "allow-presentation",
      "allow-same-origin",
      "allow-scripts",
      "allow-storage-access-by-user-activation",
      "allow-top-navigation",
      "allow-top-navigation-by-user-activation"
    ];
    function validateSandboxAttribute(context, node, attribute) {
      if (typeof attribute !== "string") {
        return;
      }
      const values = attribute.split(" ");
      let allowScripts = false;
      let allowSameOrigin = false;
      values.forEach((attributeValue) => {
        const trimmedAttributeValue = attributeValue.trim();
        if (ALLOWED_VALUES.indexOf(trimmedAttributeValue) === -1) {
          report(context, messages.invalidValue, "invalidValue", {
            node,
            data: {
              value: trimmedAttributeValue
            }
          });
        }
        if (trimmedAttributeValue === "allow-scripts") {
          allowScripts = true;
        }
        if (trimmedAttributeValue === "allow-same-origin") {
          allowSameOrigin = true;
        }
      });
      if (allowScripts && allowSameOrigin) {
        report(context, messages.invalidCombination, "invalidCombination", {
          node
        });
      }
    }
    function checkAttributes(context, node) {
      let sandboxAttributeFound = false;
      node.attributes.forEach((attribute) => {
        if (attribute.type === "JSXAttribute" && attribute.name && attribute.name.type === "JSXIdentifier" && attribute.name.name === "sandbox") {
          sandboxAttributeFound = true;
          if (attribute.value && attribute.value.type === "Literal" && attribute.value.value) {
            validateSandboxAttribute(context, node, attribute.value.value);
          }
        }
      });
      if (!sandboxAttributeFound) {
        report(context, messages.attributeMissing, "attributeMissing", {
          node
        });
      }
    }
    function checkProps(context, node) {
      let sandboxAttributeFound = false;
      if (node.arguments.length > 1) {
        const props = node.arguments[1];
        const sandboxProp = props.properties && props.properties.find((x) => x.type === "Property" && x.key.name === "sandbox");
        if (sandboxProp) {
          sandboxAttributeFound = true;
          if (sandboxProp.value && sandboxProp.value.type === "Literal" && sandboxProp.value.value) {
            validateSandboxAttribute(context, node, sandboxProp.value.value);
          }
        }
      }
      if (!sandboxAttributeFound) {
        report(context, messages.attributeMissing, "attributeMissing", {
          node
        });
      }
    }
    module.exports = {
      meta: {
        docs: {
          description: "Enforce sandbox attribute on iframe elements",
          category: "Best Practices",
          recommended: false,
          url: docsUrl("iframe-missing-sandbox")
        },
        schema: [],
        messages
      },
      create(context) {
        return {
          'JSXOpeningElement[name.name="iframe"]'(node) {
            checkAttributes(context, node);
          },
          CallExpression(node) {
            if (isCreateElement(context, node) && node.arguments && node.arguments.length > 0) {
              const tag = node.arguments[0];
              if (tag.type === "Literal" && tag.value === "iframe") {
                checkProps(context, node);
              }
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-boolean-value.js
var require_jsx_boolean_value = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-boolean-value.js"(exports, module) {
    "use strict";
    var docsUrl = require_docsUrl();
    var report = require_report();
    var exceptionsSchema = {
      type: "array",
      items: { type: "string", minLength: 1 },
      uniqueItems: true
    };
    var ALWAYS = "always";
    var NEVER = "never";
    function isAlways(configuration, exceptions, propName) {
      const isException = exceptions.has(propName);
      if (configuration === ALWAYS) {
        return !isException;
      }
      return isException;
    }
    function isNever(configuration, exceptions, propName) {
      const isException = exceptions.has(propName);
      if (configuration === NEVER) {
        return !isException;
      }
      return isException;
    }
    var messages = {
      omitBoolean: "Value must be omitted for boolean attribute `{{propName}}`",
      setBoolean: "Value must be set for boolean attribute `{{propName}}`",
      omitPropAndBoolean: "Value must be omitted for `false` attribute: `{{propName}}`"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce boolean attributes notation in JSX",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("jsx-boolean-value")
        },
        fixable: "code",
        messages,
        schema: {
          anyOf: [{
            type: "array",
            items: [{ enum: [ALWAYS, NEVER] }],
            additionalItems: false
          }, {
            type: "array",
            items: [{
              enum: [ALWAYS]
            }, {
              type: "object",
              additionalProperties: false,
              properties: {
                [NEVER]: exceptionsSchema,
                assumeUndefinedIsFalse: {
                  type: "boolean"
                }
              }
            }],
            additionalItems: false
          }, {
            type: "array",
            items: [{
              enum: [NEVER]
            }, {
              type: "object",
              additionalProperties: false,
              properties: {
                [ALWAYS]: exceptionsSchema,
                assumeUndefinedIsFalse: {
                  type: "boolean"
                }
              }
            }],
            additionalItems: false
          }]
        }
      },
      create(context) {
        const configuration = context.options[0] || NEVER;
        const configObject = context.options[1] || {};
        const exceptions = new Set((configuration === ALWAYS ? configObject[NEVER] : configObject[ALWAYS]) || []);
        return {
          JSXAttribute(node) {
            const propName = node.name && node.name.name;
            const value = node.value;
            if (isAlways(configuration, exceptions, propName) && value === null) {
              const messageId = "setBoolean";
              const data = { propName };
              report(context, messages[messageId], messageId, {
                node,
                data,
                fix(fixer) {
                  return fixer.insertTextAfter(node, "={true}");
                }
              });
            }
            if (isNever(configuration, exceptions, propName) && !configObject.assumeUndefinedIsFalse && value && value.type === "JSXExpressionContainer" && value.expression.value === true) {
              const messageId = "omitBoolean";
              const data = { propName };
              report(context, messages[messageId], messageId, {
                node,
                data,
                fix(fixer) {
                  return fixer.removeRange([node.name.range[1], value.range[1]]);
                }
              });
            }
            if (isNever(configuration, exceptions, propName) && configObject.assumeUndefinedIsFalse && value && value.type === "JSXExpressionContainer" && value.expression.value === false) {
              const messageId = "omitPropAndBoolean";
              const data = { propName };
              report(context, messages[messageId], messageId, {
                node,
                data,
                fix(fixer) {
                  return fixer.removeRange([node.name.range[0], value.range[1]]);
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-child-element-spacing.js
var require_jsx_child_element_spacing = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-child-element-spacing.js"(exports, module) {
    "use strict";
    var docsUrl = require_docsUrl();
    var report = require_report();
    var INLINE_ELEMENTS = /* @__PURE__ */ new Set([
      "a",
      "abbr",
      "acronym",
      "b",
      "bdo",
      "big",
      "button",
      "cite",
      "code",
      "dfn",
      "em",
      "i",
      "img",
      "input",
      "kbd",
      "label",
      "map",
      "object",
      "q",
      "samp",
      "script",
      "select",
      "small",
      "span",
      "strong",
      "sub",
      "sup",
      "textarea",
      "tt",
      "var"
    ]);
    var messages = {
      spacingAfterPrev: "Ambiguous spacing after previous element {{element}}",
      spacingBeforeNext: "Ambiguous spacing before next element {{element}}"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce or disallow spaces inside of curly braces in JSX attributes and expressions",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("jsx-child-element-spacing")
        },
        fixable: null,
        messages,
        schema: []
      },
      create(context) {
        const TEXT_FOLLOWING_ELEMENT_PATTERN = /^\s*\n\s*\S/;
        const TEXT_PRECEDING_ELEMENT_PATTERN = /\S\s*\n\s*$/;
        const elementName = (node) => node.openingElement && node.openingElement.name && node.openingElement.name.type === "JSXIdentifier" && node.openingElement.name.name;
        const isInlineElement = (node) => node.type === "JSXElement" && INLINE_ELEMENTS.has(elementName(node));
        const handleJSX = (node) => {
          let lastChild = null;
          let child = null;
          node.children.concat([null]).forEach((nextChild) => {
            if ((lastChild || nextChild) && (!lastChild || isInlineElement(lastChild)) && (child && (child.type === "Literal" || child.type === "JSXText")) && (!nextChild || isInlineElement(nextChild)) && true) {
              if (lastChild && child.value.match(TEXT_FOLLOWING_ELEMENT_PATTERN)) {
                report(context, messages.spacingAfterPrev, "spacingAfterPrev", {
                  node: lastChild,
                  loc: lastChild.loc.end,
                  data: {
                    element: elementName(lastChild)
                  }
                });
              } else if (nextChild && child.value.match(TEXT_PRECEDING_ELEMENT_PATTERN)) {
                report(context, messages.spacingBeforeNext, "spacingBeforeNext", {
                  node: nextChild,
                  loc: nextChild.loc.start,
                  data: {
                    element: elementName(nextChild)
                  }
                });
              }
            }
            lastChild = child;
            child = nextChild;
          });
        };
        return {
          JSXElement: handleJSX,
          JSXFragment: handleJSX
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-closing-bracket-location.js
var require_jsx_closing_bracket_location = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-closing-bracket-location.js"(exports, module) {
    "use strict";
    var has = require_polyfill19()();
    var docsUrl = require_docsUrl();
    var getSourceCode = require_eslint().getSourceCode;
    var report = require_report();
    var messages = {
      bracketLocation: "The closing bracket must be {{location}}{{details}}"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce closing bracket location in JSX",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("jsx-closing-bracket-location")
        },
        fixable: "code",
        messages,
        schema: [{
          anyOf: [
            {
              enum: ["after-props", "props-aligned", "tag-aligned", "line-aligned"]
            },
            {
              type: "object",
              properties: {
                location: {
                  enum: ["after-props", "props-aligned", "tag-aligned", "line-aligned"]
                }
              },
              additionalProperties: false
            },
            {
              type: "object",
              properties: {
                nonEmpty: {
                  enum: ["after-props", "props-aligned", "tag-aligned", "line-aligned", false]
                },
                selfClosing: {
                  enum: ["after-props", "props-aligned", "tag-aligned", "line-aligned", false]
                }
              },
              additionalProperties: false
            }
          ]
        }]
      },
      create(context) {
        const MESSAGE_LOCATION = {
          "after-props": "placed after the last prop",
          "after-tag": "placed after the opening tag",
          "props-aligned": "aligned with the last prop",
          "tag-aligned": "aligned with the opening tag",
          "line-aligned": "aligned with the line containing the opening tag"
        };
        const DEFAULT_LOCATION = "tag-aligned";
        const config = context.options[0];
        const options = {
          nonEmpty: DEFAULT_LOCATION,
          selfClosing: DEFAULT_LOCATION
        };
        if (typeof config === "string") {
          options.nonEmpty = config;
          options.selfClosing = config;
        } else if (typeof config === "object") {
          if (has(config, "location")) {
            options.nonEmpty = config.location;
            options.selfClosing = config.location;
          }
          if (has(config, "nonEmpty")) {
            options.nonEmpty = config.nonEmpty;
          }
          if (has(config, "selfClosing")) {
            options.selfClosing = config.selfClosing;
          }
        }
        function getExpectedLocation(tokens) {
          let location;
          if (typeof tokens.lastProp === "undefined") {
            location = "after-tag";
          } else if (tokens.opening.line === tokens.lastProp.lastLine) {
            location = "after-props";
          } else {
            location = tokens.selfClosing ? options.selfClosing : options.nonEmpty;
          }
          return location;
        }
        function getCorrectColumn(tokens, expectedLocation) {
          switch (expectedLocation) {
            case "props-aligned":
              return tokens.lastProp.column;
            case "tag-aligned":
              return tokens.opening.column;
            case "line-aligned":
              return tokens.openingStartOfLine.column;
            default:
              return null;
          }
        }
        function hasCorrectLocation(tokens, expectedLocation) {
          switch (expectedLocation) {
            case "after-tag":
              return tokens.tag.line === tokens.closing.line;
            case "after-props":
              return tokens.lastProp.lastLine === tokens.closing.line;
            case "props-aligned":
            case "tag-aligned":
            case "line-aligned": {
              const correctColumn = getCorrectColumn(tokens, expectedLocation);
              return correctColumn === tokens.closing.column;
            }
            default:
              return true;
          }
        }
        function getIndentation(tokens, expectedLocation, correctColumn) {
          const newColumn = correctColumn || 0;
          let indentation;
          let spaces = [];
          switch (expectedLocation) {
            case "props-aligned":
              indentation = /^\s*/.exec(getSourceCode(context).lines[tokens.lastProp.firstLine - 1])[0];
              break;
            case "tag-aligned":
            case "line-aligned":
              indentation = /^\s*/.exec(getSourceCode(context).lines[tokens.opening.line - 1])[0];
              break;
            default:
              indentation = "";
          }
          if (indentation.length + 1 < newColumn) {
            spaces = new Array(+correctColumn + 1 - indentation.length);
          }
          return indentation + spaces.join(" ");
        }
        function getTokensLocations(node) {
          const sourceCode = getSourceCode(context);
          const opening = sourceCode.getFirstToken(node).loc.start;
          const closing = sourceCode.getLastTokens(node, node.selfClosing ? 2 : 1)[0].loc.start;
          const tag = sourceCode.getFirstToken(node.name).loc.start;
          let lastProp;
          if (node.attributes.length) {
            lastProp = node.attributes[node.attributes.length - 1];
            lastProp = {
              column: sourceCode.getFirstToken(lastProp).loc.start.column,
              firstLine: sourceCode.getFirstToken(lastProp).loc.start.line,
              lastLine: sourceCode.getLastToken(lastProp).loc.end.line
            };
          }
          const openingLine = sourceCode.lines[opening.line - 1];
          const closingLine = sourceCode.lines[closing.line - 1];
          const isTab = {
            openTab: /^\t/.test(openingLine),
            closeTab: /^\t/.test(closingLine)
          };
          const openingStartOfLine = {
            column: /^\s*/.exec(openingLine)[0].length,
            line: opening.line
          };
          return {
            isTab,
            tag,
            opening,
            closing,
            lastProp,
            selfClosing: node.selfClosing,
            openingStartOfLine
          };
        }
        function getOpeningElementId(node) {
          return node.range.join(":");
        }
        const lastAttributeNode = {};
        return {
          JSXAttribute(node) {
            lastAttributeNode[getOpeningElementId(node.parent)] = node;
          },
          JSXSpreadAttribute(node) {
            lastAttributeNode[getOpeningElementId(node.parent)] = node;
          },
          "JSXOpeningElement:exit"(node) {
            const attributeNode = lastAttributeNode[getOpeningElementId(node)];
            const cachedLastAttributeEndPos = attributeNode ? attributeNode.range[1] : null;
            let expectedNextLine;
            const tokens = getTokensLocations(node);
            const expectedLocation = getExpectedLocation(tokens);
            let usingSameIndentation = true;
            if (expectedLocation === "tag-aligned") {
              usingSameIndentation = tokens.isTab.openTab === tokens.isTab.closeTab;
            }
            if (hasCorrectLocation(tokens, expectedLocation) && usingSameIndentation) {
              return;
            }
            const data = {
              location: MESSAGE_LOCATION[expectedLocation],
              details: ""
            };
            const correctColumn = getCorrectColumn(tokens, expectedLocation);
            if (correctColumn !== null) {
              expectedNextLine = tokens.lastProp && tokens.lastProp.lastLine === tokens.closing.line;
              data.details = ` (expected column ${correctColumn + 1}${expectedNextLine ? " on the next line)" : ")"}`;
            }
            report(context, messages.bracketLocation, "bracketLocation", {
              node,
              loc: tokens.closing,
              data,
              fix(fixer) {
                const closingTag = tokens.selfClosing ? "/>" : ">";
                switch (expectedLocation) {
                  case "after-tag":
                    if (cachedLastAttributeEndPos) {
                      return fixer.replaceTextRange(
                        [cachedLastAttributeEndPos, node.range[1]],
                        (expectedNextLine ? "\n" : "") + closingTag
                      );
                    }
                    return fixer.replaceTextRange(
                      [node.name.range[1], node.range[1]],
                      (expectedNextLine ? "\n" : " ") + closingTag
                    );
                  case "after-props":
                    return fixer.replaceTextRange(
                      [cachedLastAttributeEndPos, node.range[1]],
                      (expectedNextLine ? "\n" : "") + closingTag
                    );
                  case "props-aligned":
                  case "tag-aligned":
                  case "line-aligned":
                    return fixer.replaceTextRange(
                      [cachedLastAttributeEndPos, node.range[1]],
                      `
${getIndentation(tokens, expectedLocation, correctColumn)}${closingTag}`
                    );
                  default:
                    return true;
                }
              }
            });
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-closing-tag-location.js
var require_jsx_closing_tag_location = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-closing-tag-location.js"(exports, module) {
    "use strict";
    var astUtil = require_ast();
    var docsUrl = require_docsUrl();
    var report = require_report();
    var messages = {
      onOwnLine: "Closing tag of a multiline JSX expression must be on its own line.",
      matchIndent: "Expected closing tag to match indentation of opening."
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce closing tag location for multiline JSX",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("jsx-closing-tag-location")
        },
        fixable: "whitespace",
        messages
      },
      create(context) {
        function handleClosingElement(node) {
          if (!node.parent) {
            return;
          }
          const opening = node.parent.openingElement || node.parent.openingFragment;
          if (opening.loc.start.line === node.loc.start.line) {
            return;
          }
          if (opening.loc.start.column === node.loc.start.column) {
            return;
          }
          const messageId = astUtil.isNodeFirstInLine(context, node) ? "matchIndent" : "onOwnLine";
          report(context, messages[messageId], messageId, {
            node,
            loc: node.loc,
            fix(fixer) {
              const indent = Array(opening.loc.start.column + 1).join(" ");
              if (astUtil.isNodeFirstInLine(context, node)) {
                return fixer.replaceTextRange(
                  [node.range[0] - node.loc.start.column, node.range[0]],
                  indent
                );
              }
              return fixer.insertTextBefore(node, `
${indent}`);
            }
          });
        }
        return {
          JSXClosingElement: handleClosingElement,
          JSXClosingFragment: handleClosingElement
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-curly-spacing.js
var require_jsx_curly_spacing = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-curly-spacing.js"(exports, module) {
    "use strict";
    var has = require_polyfill19()();
    var docsUrl = require_docsUrl();
    var getSourceCode = require_eslint().getSourceCode;
    var report = require_report();
    var SPACING = {
      always: "always",
      never: "never"
    };
    var SPACING_VALUES = [SPACING.always, SPACING.never];
    var messages = {
      noNewlineAfter: "There should be no newline after '{{token}}'",
      noNewlineBefore: "There should be no newline before '{{token}}'",
      noSpaceAfter: "There should be no space after '{{token}}'",
      noSpaceBefore: "There should be no space before '{{token}}'",
      spaceNeededAfter: "A space is required after '{{token}}'",
      spaceNeededBefore: "A space is required before '{{token}}'"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce or disallow spaces inside of curly braces in JSX attributes and expressions",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("jsx-curly-spacing")
        },
        fixable: "code",
        messages,
        schema: {
          definitions: {
            basicConfig: {
              type: "object",
              properties: {
                when: {
                  enum: SPACING_VALUES
                },
                allowMultiline: {
                  type: "boolean"
                },
                spacing: {
                  type: "object",
                  properties: {
                    objectLiterals: {
                      enum: SPACING_VALUES
                    }
                  }
                }
              }
            },
            basicConfigOrBoolean: {
              anyOf: [{
                $ref: "#/definitions/basicConfig"
              }, {
                type: "boolean"
              }]
            }
          },
          type: "array",
          items: [{
            anyOf: [{
              allOf: [{
                $ref: "#/definitions/basicConfig"
              }, {
                type: "object",
                properties: {
                  attributes: {
                    $ref: "#/definitions/basicConfigOrBoolean"
                  },
                  children: {
                    $ref: "#/definitions/basicConfigOrBoolean"
                  }
                }
              }]
            }, {
              enum: SPACING_VALUES
            }]
          }, {
            type: "object",
            properties: {
              allowMultiline: {
                type: "boolean"
              },
              spacing: {
                type: "object",
                properties: {
                  objectLiterals: {
                    enum: SPACING_VALUES
                  }
                }
              }
            },
            additionalProperties: false
          }]
        }
      },
      create(context) {
        function normalizeConfig(configOrTrue, defaults, lastPass) {
          const config = configOrTrue === true ? {} : configOrTrue;
          const when = config.when || defaults.when;
          const allowMultiline = has(config, "allowMultiline") ? config.allowMultiline : defaults.allowMultiline;
          const spacing = config.spacing || {};
          let objectLiteralSpaces = spacing.objectLiterals || defaults.objectLiteralSpaces;
          if (lastPass) {
            objectLiteralSpaces = objectLiteralSpaces || when;
          }
          return {
            when,
            allowMultiline,
            objectLiteralSpaces
          };
        }
        const DEFAULT_WHEN = SPACING.never;
        const DEFAULT_ALLOW_MULTILINE = true;
        const DEFAULT_ATTRIBUTES = true;
        const DEFAULT_CHILDREN = false;
        let originalConfig = context.options[0] || {};
        if (SPACING_VALUES.indexOf(originalConfig) !== -1) {
          originalConfig = Object.assign({ when: context.options[0] }, context.options[1]);
        }
        const defaultConfig = normalizeConfig(originalConfig, {
          when: DEFAULT_WHEN,
          allowMultiline: DEFAULT_ALLOW_MULTILINE
        });
        const attributes = has(originalConfig, "attributes") ? originalConfig.attributes : DEFAULT_ATTRIBUTES;
        const attributesConfig = attributes ? normalizeConfig(attributes, defaultConfig, true) : null;
        const children = has(originalConfig, "children") ? originalConfig.children : DEFAULT_CHILDREN;
        const childrenConfig = children ? normalizeConfig(children, defaultConfig, true) : null;
        function isMultiline(left, right) {
          return left.loc.end.line !== right.loc.start.line;
        }
        function fixByTrimmingWhitespace(fixer, fromLoc, toLoc, mode, spacing) {
          let replacementText = getSourceCode(context).text.slice(fromLoc, toLoc);
          if (mode === "start") {
            replacementText = replacementText.replace(/^\s+/gm, "");
          } else {
            replacementText = replacementText.replace(/\s+$/gm, "");
          }
          if (spacing === SPACING.always) {
            if (mode === "start") {
              replacementText += " ";
            } else {
              replacementText = ` ${replacementText}`;
            }
          }
          return fixer.replaceTextRange([fromLoc, toLoc], replacementText);
        }
        function reportNoBeginningNewline(node, token, spacing) {
          report(context, messages.noNewlineAfter, "noNewlineAfter", {
            node,
            loc: token.loc.start,
            data: {
              token: token.value
            },
            fix(fixer) {
              const nextToken = getSourceCode(context).getTokenAfter(token);
              return fixByTrimmingWhitespace(fixer, token.range[1], nextToken.range[0], "start", spacing);
            }
          });
        }
        function reportNoEndingNewline(node, token, spacing) {
          report(context, messages.noNewlineBefore, "noNewlineBefore", {
            node,
            loc: token.loc.start,
            data: {
              token: token.value
            },
            fix(fixer) {
              const previousToken = getSourceCode(context).getTokenBefore(token);
              return fixByTrimmingWhitespace(fixer, previousToken.range[1], token.range[0], "end", spacing);
            }
          });
        }
        function reportNoBeginningSpace(node, token) {
          report(context, messages.noSpaceAfter, "noSpaceAfter", {
            node,
            loc: token.loc.start,
            data: {
              token: token.value
            },
            fix(fixer) {
              const sourceCode = getSourceCode(context);
              const nextToken = sourceCode.getTokenAfter(token);
              let nextComment;
              if (sourceCode.getCommentsAfter) {
                nextComment = sourceCode.getCommentsAfter(token);
              } else {
                const potentialComment = sourceCode.getTokenAfter(token, { includeComments: true });
                nextComment = nextToken === potentialComment ? [] : [potentialComment];
              }
              if (nextComment.length > 0) {
                return fixByTrimmingWhitespace(fixer, token.range[1], Math.min(nextToken.range[0], nextComment[0].range[0]), "start");
              }
              return fixByTrimmingWhitespace(fixer, token.range[1], nextToken.range[0], "start");
            }
          });
        }
        function reportNoEndingSpace(node, token) {
          report(context, messages.noSpaceBefore, "noSpaceBefore", {
            node,
            loc: token.loc.start,
            data: {
              token: token.value
            },
            fix(fixer) {
              const sourceCode = getSourceCode(context);
              const previousToken = sourceCode.getTokenBefore(token);
              let previousComment;
              if (sourceCode.getCommentsBefore) {
                previousComment = sourceCode.getCommentsBefore(token);
              } else {
                const potentialComment = sourceCode.getTokenBefore(token, { includeComments: true });
                previousComment = previousToken === potentialComment ? [] : [potentialComment];
              }
              if (previousComment.length > 0) {
                return fixByTrimmingWhitespace(fixer, Math.max(previousToken.range[1], previousComment[0].range[1]), token.range[0], "end");
              }
              return fixByTrimmingWhitespace(fixer, previousToken.range[1], token.range[0], "end");
            }
          });
        }
        function reportRequiredBeginningSpace(node, token) {
          report(context, messages.spaceNeededAfter, "spaceNeededAfter", {
            node,
            loc: token.loc.start,
            data: {
              token: token.value
            },
            fix(fixer) {
              return fixer.insertTextAfter(token, " ");
            }
          });
        }
        function reportRequiredEndingSpace(node, token) {
          report(context, messages.spaceNeededBefore, "spaceNeededBefore", {
            node,
            loc: token.loc.start,
            data: {
              token: token.value
            },
            fix(fixer) {
              return fixer.insertTextBefore(token, " ");
            }
          });
        }
        function validateBraceSpacing(node) {
          let config;
          switch (node.parent.type) {
            case "JSXAttribute":
            case "JSXOpeningElement":
              config = attributesConfig;
              break;
            case "JSXElement":
            case "JSXFragment":
              config = childrenConfig;
              break;
            default:
              return;
          }
          if (config === null) {
            return;
          }
          const sourceCode = getSourceCode(context);
          const first = sourceCode.getFirstToken(node);
          const last = sourceCode.getLastToken(node);
          let second = sourceCode.getTokenAfter(first, { includeComments: true });
          let penultimate = sourceCode.getTokenBefore(last, { includeComments: true });
          if (!second) {
            second = sourceCode.getTokenAfter(first);
            const leadingComments = sourceCode.getNodeByRangeIndex(second.range[0]).leadingComments;
            second = leadingComments ? leadingComments[0] : second;
          }
          if (!penultimate) {
            penultimate = sourceCode.getTokenBefore(last);
            const trailingComments = sourceCode.getNodeByRangeIndex(penultimate.range[0]).trailingComments;
            penultimate = trailingComments ? trailingComments[trailingComments.length - 1] : penultimate;
          }
          const isObjectLiteral = first.value === second.value;
          const spacing = isObjectLiteral ? config.objectLiteralSpaces : config.when;
          if (spacing === SPACING.always) {
            if (!sourceCode.isSpaceBetweenTokens(first, second)) {
              reportRequiredBeginningSpace(node, first);
            } else if (!config.allowMultiline && isMultiline(first, second)) {
              reportNoBeginningNewline(node, first, spacing);
            }
            if (!sourceCode.isSpaceBetweenTokens(penultimate, last)) {
              reportRequiredEndingSpace(node, last);
            } else if (!config.allowMultiline && isMultiline(penultimate, last)) {
              reportNoEndingNewline(node, last, spacing);
            }
          } else if (spacing === SPACING.never) {
            if (isMultiline(first, second)) {
              if (!config.allowMultiline) {
                reportNoBeginningNewline(node, first, spacing);
              }
            } else if (sourceCode.isSpaceBetweenTokens(first, second)) {
              reportNoBeginningSpace(node, first);
            }
            if (isMultiline(penultimate, last)) {
              if (!config.allowMultiline) {
                reportNoEndingNewline(node, last, spacing);
              }
            } else if (sourceCode.isSpaceBetweenTokens(penultimate, last)) {
              reportNoEndingSpace(node, last);
            }
          }
        }
        return {
          JSXExpressionContainer: validateBraceSpacing,
          JSXSpreadAttribute: validateBraceSpacing
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-curly-newline.js
var require_jsx_curly_newline = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-curly-newline.js"(exports, module) {
    "use strict";
    var docsUrl = require_docsUrl();
    var eslintUtil = require_eslint();
    var report = require_report();
    var getSourceCode = eslintUtil.getSourceCode;
    var getText = eslintUtil.getText;
    function getNormalizedOption(context) {
      const rawOption = context.options[0] || "consistent";
      if (rawOption === "consistent") {
        return {
          multiline: "consistent",
          singleline: "consistent"
        };
      }
      if (rawOption === "never") {
        return {
          multiline: "forbid",
          singleline: "forbid"
        };
      }
      return {
        multiline: rawOption.multiline || "consistent",
        singleline: rawOption.singleline || "consistent"
      };
    }
    var messages = {
      expectedBefore: "Expected newline before '}'.",
      expectedAfter: "Expected newline after '{'.",
      unexpectedBefore: "Unexpected newline before '}'.",
      unexpectedAfter: "Unexpected newline after '{'."
    };
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce consistent linebreaks in curly braces in JSX attributes and expressions",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("jsx-curly-newline")
        },
        fixable: "whitespace",
        schema: [
          {
            anyOf: [
              {
                enum: ["consistent", "never"]
              },
              {
                type: "object",
                properties: {
                  singleline: { enum: ["consistent", "require", "forbid"] },
                  multiline: { enum: ["consistent", "require", "forbid"] }
                },
                additionalProperties: false
              }
            ]
          }
        ],
        messages
      },
      create(context) {
        const sourceCode = getSourceCode(context);
        const option = getNormalizedOption(context);
        function isTokenOnSameLine(left, right) {
          return left.loc.end.line === right.loc.start.line;
        }
        function shouldHaveNewlines(expression, hasLeftNewline) {
          const isMultiline = expression.loc.start.line !== expression.loc.end.line;
          switch (isMultiline ? option.multiline : option.singleline) {
            case "forbid":
              return false;
            case "require":
              return true;
            case "consistent":
            default:
              return hasLeftNewline;
          }
        }
        function validateCurlys(curlys, expression) {
          const leftCurly = curlys.leftCurly;
          const rightCurly = curlys.rightCurly;
          const tokenAfterLeftCurly = sourceCode.getTokenAfter(leftCurly);
          const tokenBeforeRightCurly = sourceCode.getTokenBefore(rightCurly);
          const hasLeftNewline = !isTokenOnSameLine(leftCurly, tokenAfterLeftCurly);
          const hasRightNewline = !isTokenOnSameLine(tokenBeforeRightCurly, rightCurly);
          const needsNewlines = shouldHaveNewlines(expression, hasLeftNewline);
          if (hasLeftNewline && !needsNewlines) {
            report(context, messages.unexpectedAfter, "unexpectedAfter", {
              node: leftCurly,
              fix(fixer) {
                return getText(context).slice(leftCurly.range[1], tokenAfterLeftCurly.range[0]).trim() ? null : fixer.removeRange([leftCurly.range[1], tokenAfterLeftCurly.range[0]]);
              }
            });
          } else if (!hasLeftNewline && needsNewlines) {
            report(context, messages.expectedAfter, "expectedAfter", {
              node: leftCurly,
              fix: (fixer) => fixer.insertTextAfter(leftCurly, "\n")
            });
          }
          if (hasRightNewline && !needsNewlines) {
            report(context, messages.unexpectedBefore, "unexpectedBefore", {
              node: rightCurly,
              fix(fixer) {
                return getText(context).slice(tokenBeforeRightCurly.range[1], rightCurly.range[0]).trim() ? null : fixer.removeRange([
                  tokenBeforeRightCurly.range[1],
                  rightCurly.range[0]
                ]);
              }
            });
          } else if (!hasRightNewline && needsNewlines) {
            report(context, messages.expectedBefore, "expectedBefore", {
              node: rightCurly,
              fix: (fixer) => fixer.insertTextBefore(rightCurly, "\n")
            });
          }
        }
        return {
          JSXExpressionContainer(node) {
            const curlyTokens = {
              leftCurly: sourceCode.getFirstToken(node),
              rightCurly: sourceCode.getLastToken(node)
            };
            validateCurlys(curlyTokens, node.expression);
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-equals-spacing.js
var require_jsx_equals_spacing = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-equals-spacing.js"(exports, module) {
    "use strict";
    var docsUrl = require_docsUrl();
    var getSourceCode = require_eslint().getSourceCode;
    var report = require_report();
    var messages = {
      noSpaceBefore: "There should be no space before '='",
      noSpaceAfter: "There should be no space after '='",
      needSpaceBefore: "A space is required before '='",
      needSpaceAfter: "A space is required after '='"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce or disallow spaces around equal signs in JSX attributes",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("jsx-equals-spacing")
        },
        fixable: "code",
        messages,
        schema: [{
          enum: ["always", "never"]
        }]
      },
      create(context) {
        const config = context.options[0] || "never";
        function hasEqual(attrNode) {
          return attrNode.type !== "JSXSpreadAttribute" && attrNode.value !== null;
        }
        return {
          JSXOpeningElement(node) {
            node.attributes.forEach((attrNode) => {
              if (!hasEqual(attrNode)) {
                return;
              }
              const sourceCode = getSourceCode(context);
              const equalToken = sourceCode.getTokenAfter(attrNode.name);
              const spacedBefore = sourceCode.isSpaceBetweenTokens(attrNode.name, equalToken);
              const spacedAfter = sourceCode.isSpaceBetweenTokens(equalToken, attrNode.value);
              if (config === "never") {
                if (spacedBefore) {
                  report(context, messages.noSpaceBefore, "noSpaceBefore", {
                    node: attrNode,
                    loc: equalToken.loc.start,
                    fix(fixer) {
                      return fixer.removeRange([attrNode.name.range[1], equalToken.range[0]]);
                    }
                  });
                }
                if (spacedAfter) {
                  report(context, messages.noSpaceAfter, "noSpaceAfter", {
                    node: attrNode,
                    loc: equalToken.loc.start,
                    fix(fixer) {
                      return fixer.removeRange([equalToken.range[1], attrNode.value.range[0]]);
                    }
                  });
                }
              } else if (config === "always") {
                if (!spacedBefore) {
                  report(context, messages.needSpaceBefore, "needSpaceBefore", {
                    node: attrNode,
                    loc: equalToken.loc.start,
                    fix(fixer) {
                      return fixer.insertTextBefore(equalToken, " ");
                    }
                  });
                }
                if (!spacedAfter) {
                  report(context, messages.needSpaceAfter, "needSpaceAfter", {
                    node: attrNode,
                    loc: equalToken.loc.start,
                    fix(fixer) {
                      return fixer.insertTextAfter(equalToken, " ");
                    }
                  });
                }
              }
            });
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-filename-extension.js
var require_jsx_filename_extension = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-filename-extension.js"(exports, module) {
    "use strict";
    var path = __require("path");
    var docsUrl = require_docsUrl();
    var report = require_report();
    var DEFAULTS = {
      allow: "always",
      extensions: [".jsx"],
      ignoreFilesWithoutCode: false
    };
    var messages = {
      noJSXWithExtension: "JSX not allowed in files with extension '{{ext}}'",
      extensionOnlyForJSX: "Only files containing JSX may use the extension '{{ext}}'"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow file extensions that may contain JSX",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("jsx-filename-extension")
        },
        messages,
        schema: [{
          type: "object",
          properties: {
            allow: {
              enum: ["always", "as-needed"]
            },
            extensions: {
              type: "array",
              items: {
                type: "string"
              }
            },
            ignoreFilesWithoutCode: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }]
      },
      create(context) {
        const filename = context.getFilename();
        let jsxNode;
        if (filename === "<text>") {
          return {};
        }
        const allow = context.options[0] && context.options[0].allow || DEFAULTS.allow;
        const allowedExtensions = context.options[0] && context.options[0].extensions || DEFAULTS.extensions;
        const ignoreFilesWithoutCode = context.options[0] && context.options[0].ignoreFilesWithoutCode || DEFAULTS.ignoreFilesWithoutCode;
        const isAllowedExtension = allowedExtensions.some((extension) => filename.slice(-extension.length) === extension);
        function handleJSX(node) {
          if (!jsxNode) {
            jsxNode = node;
          }
        }
        return {
          JSXElement: handleJSX,
          JSXFragment: handleJSX,
          "Program:exit"(node) {
            if (jsxNode) {
              if (!isAllowedExtension) {
                report(context, messages.noJSXWithExtension, "noJSXWithExtension", {
                  node: jsxNode,
                  data: {
                    ext: path.extname(filename)
                  }
                });
              }
              return;
            }
            if (isAllowedExtension && allow === "as-needed") {
              if (ignoreFilesWithoutCode && node.body.length === 0) {
                return;
              }
              report(context, messages.extensionOnlyForJSX, "extensionOnlyForJSX", {
                node,
                data: {
                  ext: path.extname(filename)
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-first-prop-new-line.js
var require_jsx_first_prop_new_line = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-first-prop-new-line.js"(exports, module) {
    "use strict";
    var docsUrl = require_docsUrl();
    var report = require_report();
    var messages = {
      propOnNewLine: "Property should be placed on a new line",
      propOnSameLine: "Property should be placed on the same line as the component declaration"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce proper position of the first property in JSX",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("jsx-first-prop-new-line")
        },
        fixable: "code",
        messages,
        schema: [{
          enum: ["always", "never", "multiline", "multiline-multiprop", "multiprop"]
        }]
      },
      create(context) {
        const configuration = context.options[0] || "multiline-multiprop";
        function isMultilineJSX(jsxNode) {
          return jsxNode.loc.start.line < jsxNode.loc.end.line;
        }
        return {
          JSXOpeningElement(node) {
            if (configuration === "multiline" && isMultilineJSX(node) || configuration === "multiline-multiprop" && isMultilineJSX(node) && node.attributes.length > 1 || configuration === "multiprop" && node.attributes.length > 1 || configuration === "always") {
              node.attributes.some((decl) => {
                if (decl.loc.start.line === node.loc.start.line) {
                  report(context, messages.propOnNewLine, "propOnNewLine", {
                    node: decl,
                    fix(fixer) {
                      return fixer.replaceTextRange([(node.typeParameters || node.name).range[1], decl.range[0]], "\n");
                    }
                  });
                }
                return true;
              });
            } else if (configuration === "never" && node.attributes.length > 0 || configuration === "multiprop" && isMultilineJSX(node) && node.attributes.length <= 1) {
              const firstNode = node.attributes[0];
              if (node.loc.start.line < firstNode.loc.start.line) {
                report(context, messages.propOnSameLine, "propOnSameLine", {
                  node: firstNode,
                  fix(fixer) {
                    return fixer.replaceTextRange([node.name.range[1], firstNode.range[0]], " ");
                  }
                });
              }
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-handler-names.js
var require_jsx_handler_names = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-handler-names.js"(exports, module) {
    "use strict";
    var docsUrl = require_docsUrl();
    var getText = require_eslint().getText;
    var report = require_report();
    var messages = {
      badHandlerName: "Handler function for {{propKey}} prop key must be a camelCase name beginning with '{{handlerPrefix}}' only",
      badPropKey: "Prop key for {{propValue}} must begin with '{{handlerPropPrefix}}'"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce event handler naming conventions in JSX",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("jsx-handler-names")
        },
        messages,
        schema: [{
          anyOf: [
            {
              type: "object",
              properties: {
                eventHandlerPrefix: { type: "string" },
                eventHandlerPropPrefix: { type: "string" },
                checkLocalVariables: { type: "boolean" },
                checkInlineFunction: { type: "boolean" }
              },
              additionalProperties: false
            },
            {
              type: "object",
              properties: {
                eventHandlerPrefix: { type: "string" },
                eventHandlerPropPrefix: {
                  type: "boolean",
                  enum: [false]
                },
                checkLocalVariables: { type: "boolean" },
                checkInlineFunction: { type: "boolean" }
              },
              additionalProperties: false
            },
            {
              type: "object",
              properties: {
                eventHandlerPrefix: {
                  type: "boolean",
                  enum: [false]
                },
                eventHandlerPropPrefix: { type: "string" },
                checkLocalVariables: { type: "boolean" },
                checkInlineFunction: { type: "boolean" }
              },
              additionalProperties: false
            },
            {
              type: "object",
              properties: {
                checkLocalVariables: { type: "boolean" }
              },
              additionalProperties: false
            },
            {
              type: "object",
              properties: {
                checkInlineFunction: { type: "boolean" }
              },
              additionalProperties: false
            }
          ]
        }]
      },
      create(context) {
        function isPrefixDisabled(prefix) {
          return prefix === false;
        }
        function isInlineHandler(node) {
          return node.value.expression.type === "ArrowFunctionExpression";
        }
        const configuration = context.options[0] || {};
        const eventHandlerPrefix = isPrefixDisabled(configuration.eventHandlerPrefix) ? null : configuration.eventHandlerPrefix || "handle";
        const eventHandlerPropPrefix = isPrefixDisabled(configuration.eventHandlerPropPrefix) ? null : configuration.eventHandlerPropPrefix || "on";
        const EVENT_HANDLER_REGEX = !eventHandlerPrefix ? null : new RegExp(`^((props\\.${eventHandlerPropPrefix || ""})|((.*\\.)?${eventHandlerPrefix}))[0-9]*[A-Z].*$`);
        const PROP_EVENT_HANDLER_REGEX = !eventHandlerPropPrefix ? null : new RegExp(`^(${eventHandlerPropPrefix}[A-Z].*|ref)$`);
        const checkLocal = !!configuration.checkLocalVariables;
        const checkInlineFunction = !!configuration.checkInlineFunction;
        return {
          JSXAttribute(node) {
            if (!node.value || !node.value.expression || !checkInlineFunction && isInlineHandler(node) || !checkLocal && (isInlineHandler(node) ? !node.value.expression.body.callee || !node.value.expression.body.callee.object : !node.value.expression.object)) {
              return;
            }
            const propKey = typeof node.name === "object" ? node.name.name : node.name;
            const expression = node.value.expression;
            const propValue = getText(
              context,
              checkInlineFunction && isInlineHandler(node) ? expression.body.callee : expression
            ).replace(/\s*/g, "").replace(/^this\.|.*::/, "");
            if (propKey === "ref") {
              return;
            }
            const propIsEventHandler = PROP_EVENT_HANDLER_REGEX && PROP_EVENT_HANDLER_REGEX.test(propKey);
            const propFnIsNamedCorrectly = EVENT_HANDLER_REGEX && EVENT_HANDLER_REGEX.test(propValue);
            if (propIsEventHandler && propFnIsNamedCorrectly !== null && !propFnIsNamedCorrectly) {
              report(context, messages.badHandlerName, "badHandlerName", {
                node,
                data: {
                  propKey,
                  handlerPrefix: eventHandlerPrefix
                }
              });
            } else if (propFnIsNamedCorrectly && propIsEventHandler !== null && !propIsEventHandler) {
              report(context, messages.badPropKey, "badPropKey", {
                node,
                data: {
                  propValue,
                  handlerPropPrefix: eventHandlerPropPrefix
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IsRegExp.js
var require_IsRegExp = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IsRegExp.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $match = GetIntrinsic("%Symbol.match%", true);
    var hasRegExpMatcher = require_is_regex();
    var ToBoolean = require_ToBoolean();
    module.exports = function IsRegExp(argument) {
      if (!argument || typeof argument !== "object") {
        return false;
      }
      if ($match) {
        var isRegExp = argument[$match];
        if (typeof isRegExp !== "undefined") {
          return ToBoolean(isRegExp);
        }
      }
      return hasRegExpMatcher(argument);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/regexp.prototype.flags@1.5.2/node_modules/regexp.prototype.flags/implementation.js
var require_implementation22 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/regexp.prototype.flags@1.5.2/node_modules/regexp.prototype.flags/implementation.js"(exports, module) {
    "use strict";
    var setFunctionName = require_set_function_name();
    var $TypeError = require_type();
    var $Object = Object;
    module.exports = setFunctionName(function flags() {
      if (this == null || this !== $Object(this)) {
        throw new $TypeError("RegExp.prototype.flags getter called on non-object");
      }
      var result = "";
      if (this.hasIndices) {
        result += "d";
      }
      if (this.global) {
        result += "g";
      }
      if (this.ignoreCase) {
        result += "i";
      }
      if (this.multiline) {
        result += "m";
      }
      if (this.dotAll) {
        result += "s";
      }
      if (this.unicode) {
        result += "u";
      }
      if (this.unicodeSets) {
        result += "v";
      }
      if (this.sticky) {
        result += "y";
      }
      return result;
    }, "get flags", true);
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/regexp.prototype.flags@1.5.2/node_modules/regexp.prototype.flags/polyfill.js
var require_polyfill20 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/regexp.prototype.flags@1.5.2/node_modules/regexp.prototype.flags/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation22();
    var supportsDescriptors = require_define_properties().supportsDescriptors;
    var $gOPD = Object.getOwnPropertyDescriptor;
    module.exports = function getPolyfill() {
      if (supportsDescriptors && /a/mig.flags === "gim") {
        var descriptor = $gOPD(RegExp.prototype, "flags");
        if (descriptor && typeof descriptor.get === "function" && typeof RegExp.prototype.dotAll === "boolean" && typeof RegExp.prototype.hasIndices === "boolean") {
          var calls = "";
          var o = {};
          Object.defineProperty(o, "hasIndices", {
            get: function() {
              calls += "d";
            }
          });
          Object.defineProperty(o, "sticky", {
            get: function() {
              calls += "y";
            }
          });
          if (calls === "dy") {
            return descriptor.get;
          }
        }
      }
      return implementation;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/regexp.prototype.flags@1.5.2/node_modules/regexp.prototype.flags/shim.js
var require_shim19 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/regexp.prototype.flags@1.5.2/node_modules/regexp.prototype.flags/shim.js"(exports, module) {
    "use strict";
    var supportsDescriptors = require_define_properties().supportsDescriptors;
    var getPolyfill = require_polyfill20();
    var gOPD = Object.getOwnPropertyDescriptor;
    var defineProperty = Object.defineProperty;
    var TypeErr = TypeError;
    var getProto = Object.getPrototypeOf;
    var regex = /a/;
    module.exports = function shimFlags() {
      if (!supportsDescriptors || !getProto) {
        throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
      }
      var polyfill = getPolyfill();
      var proto = getProto(regex);
      var descriptor = gOPD(proto, "flags");
      if (!descriptor || descriptor.get !== polyfill) {
        defineProperty(proto, "flags", {
          configurable: true,
          enumerable: false,
          get: polyfill
        });
      }
      return polyfill;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/regexp.prototype.flags@1.5.2/node_modules/regexp.prototype.flags/index.js
var require_regexp_prototype = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/regexp.prototype.flags@1.5.2/node_modules/regexp.prototype.flags/index.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation22();
    var getPolyfill = require_polyfill20();
    var shim = require_shim19();
    var flagsBound = callBind(getPolyfill());
    define(flagsBound, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = flagsBound;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/DefinePropertyOrThrow.js
var require_DefinePropertyOrThrow2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/DefinePropertyOrThrow.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var isPropertyDescriptor = require_property_descriptor();
    var DefineOwnProperty = require_DefineOwnProperty();
    var FromPropertyDescriptor = require_FromPropertyDescriptor();
    var IsDataDescriptor = require_IsDataDescriptor();
    var IsPropertyKey = require_IsPropertyKey();
    var SameValue = require_SameValue();
    var ToPropertyDescriptor = require_ToPropertyDescriptor();
    var Type = require_Type2();
    module.exports = function DefinePropertyOrThrow(O, P, desc) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var Desc = isPropertyDescriptor(desc) ? desc : ToPropertyDescriptor(desc);
      if (!isPropertyDescriptor(Desc)) {
        throw new $TypeError("Assertion failed: Desc is not a valid Property Descriptor");
      }
      return DefineOwnProperty(
        IsDataDescriptor,
        SameValue,
        FromPropertyDescriptor,
        O,
        P,
        Desc
      );
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/DefineMethodProperty.js
var require_DefineMethodProperty = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/DefineMethodProperty.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var DefinePropertyOrThrow = require_DefinePropertyOrThrow2();
    var IsExtensible = require_IsExtensible();
    var IsPropertyKey = require_IsPropertyKey();
    var Type = require_Type2();
    module.exports = function DefineMethodProperty(homeObject, key, closure, enumerable) {
      if (Type(homeObject) !== "Object") {
        throw new $TypeError("Assertion failed: `homeObject` is not an Object");
      }
      if (!IsPropertyKey(key)) {
        throw new $TypeError("Assertion failed: `key` is not a Property Key or a Private Name");
      }
      if (typeof closure !== "function") {
        throw new $TypeError("Assertion failed: `closure` is not a function");
      }
      if (typeof enumerable !== "boolean") {
        throw new $TypeError("Assertion failed: `enumerable` is not a Boolean");
      }
      if (!IsExtensible(homeObject)) {
        throw new $TypeError("Assertion failed: `homeObject` is not an ordinary, extensible object, with no non-configurable properties");
      }
      var desc = {
        // step 3.a
        "[[Value]]": closure,
        "[[Writable]]": true,
        "[[Enumerable]]": enumerable,
        "[[Configurable]]": true
      };
      DefinePropertyOrThrow(homeObject, key, desc);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/RegExpExec.js
var require_RegExpExec = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/RegExpExec.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var regexExec = require_callBound()("RegExp.prototype.exec");
    var Call = require_Call();
    var Get = require_Get();
    var IsCallable = require_IsCallable();
    var Type = require_Type2();
    module.exports = function RegExpExec(R, S) {
      if (Type(R) !== "Object") {
        throw new $TypeError("Assertion failed: `R` must be an Object");
      }
      if (typeof S !== "string") {
        throw new $TypeError("Assertion failed: `S` must be a String");
      }
      var exec = Get(R, "exec");
      if (IsCallable(exec)) {
        var result = Call(exec, R, [S]);
        if (typeof result === "object") {
          return result;
        }
        throw new $TypeError('"exec" method must return `null` or an Object');
      }
      return regexExec(R, S);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/Set.js
var require_Set = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/Set.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var IsPropertyKey = require_IsPropertyKey();
    var SameValue = require_SameValue();
    var Type = require_Type2();
    var noThrowOnStrictViolation = function() {
      try {
        delete [].length;
        return true;
      } catch (e) {
        return false;
      }
    }();
    module.exports = function Set2(O, P, V, Throw) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: `O` must be an Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: `P` must be a Property Key");
      }
      if (typeof Throw !== "boolean") {
        throw new $TypeError("Assertion failed: `Throw` must be a Boolean");
      }
      if (Throw) {
        O[P] = V;
        if (noThrowOnStrictViolation && !SameValue(O[P], V)) {
          throw new $TypeError("Attempted to assign to readonly property.");
        }
        return true;
      }
      try {
        O[P] = V;
        return noThrowOnStrictViolation ? SameValue(O[P], V) : true;
      } catch (e) {
        return false;
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/CreateRegExpStringIterator.js
var require_CreateRegExpStringIterator = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/CreateRegExpStringIterator.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var hasSymbols = require_has_symbols()();
    var $TypeError = require_type();
    var IteratorPrototype = GetIntrinsic("%IteratorPrototype%", true);
    var AdvanceStringIndex = require_AdvanceStringIndex();
    var CreateIterResultObject = require_CreateIterResultObject();
    var DefineMethodProperty = require_DefineMethodProperty();
    var Get = require_Get();
    var OrdinaryObjectCreate = require_OrdinaryObjectCreate();
    var RegExpExec = require_RegExpExec();
    var Set2 = require_Set();
    var ToLength = require_ToLength2();
    var ToString = require_ToString();
    var Type = require_Type2();
    var SLOT = require_internal_slot();
    var setToStringTag = require_es_set_tostringtag();
    var RegExpStringIterator = function RegExpStringIterator2(R, S, global2, fullUnicode) {
      if (typeof S !== "string") {
        throw new $TypeError("`S` must be a string");
      }
      if (typeof global2 !== "boolean") {
        throw new $TypeError("`global` must be a boolean");
      }
      if (typeof fullUnicode !== "boolean") {
        throw new $TypeError("`fullUnicode` must be a boolean");
      }
      SLOT.set(this, "[[IteratingRegExp]]", R);
      SLOT.set(this, "[[IteratedString]]", S);
      SLOT.set(this, "[[Global]]", global2);
      SLOT.set(this, "[[Unicode]]", fullUnicode);
      SLOT.set(this, "[[Done]]", false);
    };
    if (IteratorPrototype) {
      RegExpStringIterator.prototype = OrdinaryObjectCreate(IteratorPrototype);
    }
    var RegExpStringIteratorNext = function next() {
      var O = this;
      if (Type(O) !== "Object") {
        throw new $TypeError("receiver must be an object");
      }
      if (!(O instanceof RegExpStringIterator) || !SLOT.has(O, "[[IteratingRegExp]]") || !SLOT.has(O, "[[IteratedString]]") || !SLOT.has(O, "[[Global]]") || !SLOT.has(O, "[[Unicode]]") || !SLOT.has(O, "[[Done]]")) {
        throw new $TypeError('"this" value must be a RegExpStringIterator instance');
      }
      if (SLOT.get(O, "[[Done]]")) {
        return CreateIterResultObject(void 0, true);
      }
      var R = SLOT.get(O, "[[IteratingRegExp]]");
      var S = SLOT.get(O, "[[IteratedString]]");
      var global2 = SLOT.get(O, "[[Global]]");
      var fullUnicode = SLOT.get(O, "[[Unicode]]");
      var match = RegExpExec(R, S);
      if (match === null) {
        SLOT.set(O, "[[Done]]", true);
        return CreateIterResultObject(void 0, true);
      }
      if (global2) {
        var matchStr = ToString(Get(match, "0"));
        if (matchStr === "") {
          var thisIndex = ToLength(Get(R, "lastIndex"));
          var nextIndex = AdvanceStringIndex(S, thisIndex, fullUnicode);
          Set2(R, "lastIndex", nextIndex, true);
        }
        return CreateIterResultObject(match, false);
      }
      SLOT.set(O, "[[Done]]", true);
      return CreateIterResultObject(match, false);
    };
    DefineMethodProperty(RegExpStringIterator.prototype, "next", RegExpStringIteratorNext, false);
    if (hasSymbols) {
      setToStringTag(RegExpStringIterator.prototype, "RegExp String Iterator");
      if (Symbol.iterator && typeof RegExpStringIterator.prototype[Symbol.iterator] !== "function") {
        iteratorFn = function SymbolIterator() {
          return this;
        };
        DefineMethodProperty(RegExpStringIterator.prototype, Symbol.iterator, iteratorFn, false);
      }
    }
    var iteratorFn;
    module.exports = function CreateRegExpStringIterator(R, S, global2, fullUnicode) {
      return new RegExpStringIterator(R, S, global2, fullUnicode);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IsConstructor.js
var require_IsConstructor2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IsConstructor.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic();
    var $construct = GetIntrinsic("%Reflect.construct%", true);
    var DefinePropertyOrThrow = require_DefinePropertyOrThrow2();
    try {
      DefinePropertyOrThrow({}, "", { "[[Get]]": function() {
      } });
    } catch (e) {
      DefinePropertyOrThrow = null;
    }
    if (DefinePropertyOrThrow && $construct) {
      isConstructorMarker = {};
      badArrayLike = {};
      DefinePropertyOrThrow(badArrayLike, "length", {
        "[[Get]]": function() {
          throw isConstructorMarker;
        },
        "[[Enumerable]]": true
      });
      module.exports = function IsConstructor(argument) {
        try {
          $construct(argument, badArrayLike);
        } catch (err) {
          return err === isConstructorMarker;
        }
      };
    } else {
      module.exports = function IsConstructor(argument) {
        return typeof argument === "function" && !!argument.prototype;
      };
    }
    var isConstructorMarker;
    var badArrayLike;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/SpeciesConstructor.js
var require_SpeciesConstructor = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/SpeciesConstructor.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $species = GetIntrinsic("%Symbol.species%", true);
    var $TypeError = require_type();
    var IsConstructor = require_IsConstructor2();
    var Type = require_Type2();
    module.exports = function SpeciesConstructor(O, defaultConstructor) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      var C = O.constructor;
      if (typeof C === "undefined") {
        return defaultConstructor;
      }
      if (Type(C) !== "Object") {
        throw new $TypeError("O.constructor is not an Object");
      }
      var S = $species ? C[$species] : void 0;
      if (S == null) {
        return defaultConstructor;
      }
      if (IsConstructor(S)) {
        return S;
      }
      throw new $TypeError("no constructor found");
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/string.prototype.matchall@4.0.11/node_modules/string.prototype.matchall/regexp-matchall.js
var require_regexp_matchall = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/string.prototype.matchall@4.0.11/node_modules/string.prototype.matchall/regexp-matchall.js"(exports, module) {
    "use strict";
    var CreateRegExpStringIterator = require_CreateRegExpStringIterator();
    var Get = require_Get();
    var Set2 = require_Set();
    var SpeciesConstructor = require_SpeciesConstructor();
    var ToLength = require_ToLength2();
    var ToString = require_ToString();
    var Type = require_Type2();
    var flagsGetter = require_regexp_prototype();
    var setFunctionName = require_set_function_name();
    var callBound = require_callBound();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = require_type();
    var $indexOf = callBound("String.prototype.indexOf");
    var OrigRegExp = GetIntrinsic("%RegExp%");
    var supportsConstructingWithFlags = "flags" in OrigRegExp.prototype;
    var constructRegexWithFlags = function constructRegex(C, R) {
      var matcher;
      var flags = "flags" in R ? Get(R, "flags") : ToString(flagsGetter(R));
      if (supportsConstructingWithFlags && typeof flags === "string") {
        matcher = new C(R, flags);
      } else if (C === OrigRegExp) {
        matcher = new C(R.source, flags);
      } else {
        matcher = new C(R, flags);
      }
      return { flags, matcher };
    };
    var regexMatchAll = setFunctionName(function SymbolMatchAll(string) {
      var R = this;
      if (Type(R) !== "Object") {
        throw new $TypeError('"this" value must be an Object');
      }
      var S = ToString(string);
      var C = SpeciesConstructor(R, OrigRegExp);
      var tmp = constructRegexWithFlags(C, R);
      var flags = tmp.flags;
      var matcher = tmp.matcher;
      var lastIndex = ToLength(Get(R, "lastIndex"));
      Set2(matcher, "lastIndex", lastIndex, true);
      var global2 = $indexOf(flags, "g") > -1;
      var fullUnicode = $indexOf(flags, "u") > -1;
      return CreateRegExpStringIterator(matcher, S, global2, fullUnicode);
    }, "[Symbol.matchAll]", true);
    module.exports = regexMatchAll;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/string.prototype.matchall@4.0.11/node_modules/string.prototype.matchall/polyfill-regexp-matchall.js
var require_polyfill_regexp_matchall = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/string.prototype.matchall@4.0.11/node_modules/string.prototype.matchall/polyfill-regexp-matchall.js"(exports, module) {
    "use strict";
    var hasSymbols = require_has_symbols()();
    var regexpMatchAll = require_regexp_matchall();
    module.exports = function getRegExpMatchAllPolyfill() {
      if (!hasSymbols || typeof Symbol.matchAll !== "symbol" || typeof RegExp.prototype[Symbol.matchAll] !== "function") {
        return regexpMatchAll;
      }
      return RegExp.prototype[Symbol.matchAll];
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/string.prototype.matchall@4.0.11/node_modules/string.prototype.matchall/implementation.js
var require_implementation23 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/string.prototype.matchall@4.0.11/node_modules/string.prototype.matchall/implementation.js"(exports, module) {
    "use strict";
    var Call = require_Call();
    var Get = require_Get();
    var GetMethod = require_GetMethod();
    var IsRegExp = require_IsRegExp();
    var ToString = require_ToString();
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var callBound = require_callBound();
    var hasSymbols = require_has_symbols()();
    var flagsGetter = require_regexp_prototype();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = require_type();
    var $RegExp = GetIntrinsic("%RegExp%");
    var $indexOf = callBound("String.prototype.indexOf");
    var regexpMatchAllPolyfill = require_polyfill_regexp_matchall();
    var getMatcher = function getMatcher2(regexp) {
      var matcherPolyfill = regexpMatchAllPolyfill();
      if (hasSymbols && typeof Symbol.matchAll === "symbol") {
        var matcher = GetMethod(regexp, Symbol.matchAll);
        if (matcher === $RegExp.prototype[Symbol.matchAll] && matcher !== matcherPolyfill) {
          return matcherPolyfill;
        }
        return matcher;
      }
      if (IsRegExp(regexp)) {
        return matcherPolyfill;
      }
    };
    module.exports = function matchAll(regexp) {
      var O = RequireObjectCoercible(this);
      if (typeof regexp !== "undefined" && regexp !== null) {
        var isRegExp = IsRegExp(regexp);
        if (isRegExp) {
          var flags = "flags" in regexp ? Get(regexp, "flags") : flagsGetter(regexp);
          RequireObjectCoercible(flags);
          if ($indexOf(ToString(flags), "g") < 0) {
            throw new $TypeError("matchAll requires a global regular expression");
          }
        }
        var matcher = getMatcher(regexp);
        if (typeof matcher !== "undefined") {
          return Call(matcher, regexp, [O]);
        }
      }
      var S = ToString(O);
      var rx = new $RegExp(regexp, "g");
      return Call(getMatcher(rx), rx, [S]);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/string.prototype.matchall@4.0.11/node_modules/string.prototype.matchall/polyfill.js
var require_polyfill21 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/string.prototype.matchall@4.0.11/node_modules/string.prototype.matchall/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation23();
    module.exports = function getPolyfill() {
      if (String.prototype.matchAll) {
        try {
          "".matchAll(RegExp.prototype);
        } catch (e) {
          return String.prototype.matchAll;
        }
      }
      return implementation;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/string.prototype.matchall@4.0.11/node_modules/string.prototype.matchall/shim.js
var require_shim20 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/string.prototype.matchall@4.0.11/node_modules/string.prototype.matchall/shim.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var hasSymbols = require_has_symbols()();
    var gOPD = require_gopd();
    var getPolyfill = require_polyfill21();
    var regexpMatchAllPolyfill = require_polyfill_regexp_matchall();
    var defineP = Object.defineProperty;
    module.exports = function shimMatchAll() {
      var polyfill = getPolyfill();
      define(
        String.prototype,
        { matchAll: polyfill },
        { matchAll: function() {
          return String.prototype.matchAll !== polyfill;
        } }
      );
      if (hasSymbols) {
        var symbol = Symbol.matchAll || (Symbol["for"] ? Symbol["for"]("Symbol.matchAll") : Symbol("Symbol.matchAll"));
        define(
          Symbol,
          { matchAll: symbol },
          { matchAll: function() {
            return Symbol.matchAll !== symbol;
          } }
        );
        if (defineP && gOPD) {
          var desc = gOPD(Symbol, symbol);
          if (!desc || desc.configurable) {
            defineP(Symbol, symbol, {
              configurable: false,
              enumerable: false,
              value: symbol,
              writable: false
            });
          }
        }
        var regexpMatchAll = regexpMatchAllPolyfill();
        var func = {};
        func[symbol] = regexpMatchAll;
        var predicate = {};
        predicate[symbol] = function() {
          return RegExp.prototype[symbol] !== regexpMatchAll;
        };
        define(RegExp.prototype, func, predicate);
      }
      return polyfill;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/string.prototype.matchall@4.0.11/node_modules/string.prototype.matchall/index.js
var require_string_prototype2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/string.prototype.matchall@4.0.11/node_modules/string.prototype.matchall/index.js"(exports, module) {
    "use strict";
    var callBind = require_call_bind();
    var define = require_define_properties();
    var implementation = require_implementation23();
    var getPolyfill = require_polyfill21();
    var shim = require_shim20();
    var boundMatchAll = callBind(implementation);
    define(boundMatchAll, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = boundMatchAll;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-indent.js
var require_jsx_indent = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-indent.js"(exports, module) {
    "use strict";
    var matchAll = require_string_prototype2();
    var astUtil = require_ast();
    var docsUrl = require_docsUrl();
    var reportC = require_report();
    var jsxUtil = require_jsx();
    var eslintUtil = require_eslint();
    var getSourceCode = eslintUtil.getSourceCode;
    var getText = eslintUtil.getText;
    var messages = {
      wrongIndent: "Expected indentation of {{needed}} {{type}} {{characters}} but found {{gotten}}."
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce JSX indentation",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("jsx-indent")
        },
        fixable: "whitespace",
        messages,
        schema: [{
          anyOf: [{
            enum: ["tab"]
          }, {
            type: "integer"
          }]
        }, {
          type: "object",
          properties: {
            checkAttributes: {
              type: "boolean"
            },
            indentLogicalExpressions: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }]
      },
      create(context) {
        const extraColumnStart = 0;
        let indentType = "space";
        let indentSize = 4;
        if (context.options.length) {
          if (context.options[0] === "tab") {
            indentSize = 1;
            indentType = "tab";
          } else if (typeof context.options[0] === "number") {
            indentSize = context.options[0];
            indentType = "space";
          }
        }
        const indentChar = indentType === "space" ? " " : "	";
        const options = context.options[1] || {};
        const checkAttributes = options.checkAttributes || false;
        const indentLogicalExpressions = options.indentLogicalExpressions || false;
        function getFixerFunction(node, needed) {
          const indent = Array(needed + 1).join(indentChar);
          if (node.type === "JSXText" || node.type === "Literal") {
            return function fix(fixer) {
              const regExp = /\n[\t ]*(\S)/g;
              const fixedText = node.raw.replace(regExp, (match, p1) => `
${indent}${p1}`);
              return fixer.replaceText(node, fixedText);
            };
          }
          if (node.type === "ReturnStatement") {
            const raw = getText(context, node);
            const lines = raw.split("\n");
            if (lines.length > 1) {
              return function fix(fixer) {
                const lastLineStart = raw.lastIndexOf("\n");
                const lastLine = raw.slice(lastLineStart).replace(/^\n[\t ]*(\S)/, (match, p1) => `
${indent}${p1}`);
                return fixer.replaceTextRange(
                  [node.range[0] + lastLineStart, node.range[1]],
                  lastLine
                );
              };
            }
          }
          return function fix(fixer) {
            return fixer.replaceTextRange(
              [node.range[0] - node.loc.start.column, node.range[0]],
              indent
            );
          };
        }
        function report(node, needed, gotten, loc) {
          const msgContext = {
            needed,
            type: indentType,
            characters: needed === 1 ? "character" : "characters",
            gotten
          };
          reportC(context, messages.wrongIndent, "wrongIndent", Object.assign({
            node,
            data: msgContext,
            fix: getFixerFunction(node, needed)
          }, loc && { loc }));
        }
        function getNodeIndent(node, byLastLine, excludeCommas) {
          let src = getText(context, node, node.loc.start.column + extraColumnStart);
          const lines = src.split("\n");
          if (byLastLine) {
            src = lines[lines.length - 1];
          } else {
            src = lines[0];
          }
          const skip = excludeCommas ? "," : "";
          let regExp;
          if (indentType === "space") {
            regExp = new RegExp(`^[ ${skip}]+`);
          } else {
            regExp = new RegExp(`^[	${skip}]+`);
          }
          const indent = regExp.exec(src);
          return indent ? indent[0].length : 0;
        }
        function isRightInLogicalExp(node) {
          return node.parent && node.parent.parent && node.parent.parent.type === "LogicalExpression" && node.parent.parent.right === node.parent && !indentLogicalExpressions;
        }
        function isAlternateInConditionalExp(node) {
          return node.parent && node.parent.parent && node.parent.parent.type === "ConditionalExpression" && node.parent.parent.alternate === node.parent && getSourceCode(context).getTokenBefore(node).value !== "(";
        }
        function isSecondOrSubsequentExpWithinDoExp(node) {
          const isInExpStmt = node.parent && node.parent.parent && node.parent.parent.type === "ExpressionStatement";
          if (!isInExpStmt) {
            return false;
          }
          const expStmt = node.parent.parent;
          const isInBlockStmtWithinDoExp = expStmt.parent && expStmt.parent.type === "BlockStatement" && expStmt.parent.parent && expStmt.parent.parent.type === "DoExpression";
          if (!isInBlockStmtWithinDoExp) {
            return false;
          }
          const blockStmt = expStmt.parent;
          const blockStmtFirstExp = blockStmt.body[0];
          return !(blockStmtFirstExp === expStmt);
        }
        function checkNodesIndent(node, indent, excludeCommas) {
          const nodeIndent = getNodeIndent(node, false, excludeCommas);
          const isCorrectRightInLogicalExp = isRightInLogicalExp(node) && nodeIndent - indent === indentSize;
          const isCorrectAlternateInCondExp = isAlternateInConditionalExp(node) && nodeIndent - indent === 0;
          if (nodeIndent !== indent && astUtil.isNodeFirstInLine(context, node) && !isCorrectRightInLogicalExp && !isCorrectAlternateInCondExp) {
            report(node, indent, nodeIndent);
          }
        }
        function checkLiteralNodeIndent(node, indent) {
          const value = node.value;
          const regExp = indentType === "space" ? /\n( *)[\t ]*\S/g : /\n(\t*)[\t ]*\S/g;
          const nodeIndentsPerLine = Array.from(
            matchAll(String(value), regExp),
            (match) => match[1] ? match[1].length : 0
          );
          const hasFirstInLineNode = nodeIndentsPerLine.length > 0;
          if (hasFirstInLineNode && !nodeIndentsPerLine.every((actualIndent) => actualIndent === indent)) {
            nodeIndentsPerLine.forEach((nodeIndent) => {
              report(node, indent, nodeIndent);
            });
          }
        }
        function handleOpeningElement(node) {
          const sourceCode = getSourceCode(context);
          let prevToken = sourceCode.getTokenBefore(node);
          if (!prevToken) {
            return;
          }
          if (prevToken.type === "JSXText" || prevToken.type === "Punctuator" && prevToken.value === ",") {
            prevToken = sourceCode.getNodeByRangeIndex(prevToken.range[0]);
            prevToken = prevToken.type === "Literal" || prevToken.type === "JSXText" ? prevToken.parent : prevToken;
          } else if (prevToken.type === "Punctuator" && prevToken.value === ":") {
            do {
              prevToken = sourceCode.getTokenBefore(prevToken);
            } while (prevToken.type === "Punctuator" && prevToken.value !== "/");
            prevToken = sourceCode.getNodeByRangeIndex(prevToken.range[0]);
            while (prevToken.parent && prevToken.parent.type !== "ConditionalExpression") {
              prevToken = prevToken.parent;
            }
          }
          prevToken = prevToken.type === "JSXExpressionContainer" ? prevToken.expression : prevToken;
          const parentElementIndent = getNodeIndent(prevToken);
          const indent = prevToken.loc.start.line === node.loc.start.line || isRightInLogicalExp(node) || isAlternateInConditionalExp(node) || isSecondOrSubsequentExpWithinDoExp(node) ? 0 : indentSize;
          checkNodesIndent(node, parentElementIndent + indent);
        }
        function handleClosingElement(node) {
          if (!node.parent) {
            return;
          }
          const peerElementIndent = getNodeIndent(node.parent.openingElement || node.parent.openingFragment);
          checkNodesIndent(node, peerElementIndent);
        }
        function handleAttribute(node) {
          if (!checkAttributes || (!node.value || node.value.type !== "JSXExpressionContainer")) {
            return;
          }
          const nameIndent = getNodeIndent(node.name);
          const lastToken = getSourceCode(context).getLastToken(node.value);
          const firstInLine = astUtil.getFirstNodeInLine(context, lastToken);
          const indent = node.name.loc.start.line === firstInLine.loc.start.line ? 0 : nameIndent;
          checkNodesIndent(firstInLine, indent);
        }
        function handleLiteral(node) {
          if (!node.parent) {
            return;
          }
          if (node.parent.type !== "JSXElement" && node.parent.type !== "JSXFragment") {
            return;
          }
          const parentNodeIndent = getNodeIndent(node.parent);
          checkLiteralNodeIndent(node, parentNodeIndent + indentSize);
        }
        return {
          JSXOpeningElement: handleOpeningElement,
          JSXOpeningFragment: handleOpeningElement,
          JSXClosingElement: handleClosingElement,
          JSXClosingFragment: handleClosingElement,
          JSXAttribute: handleAttribute,
          JSXExpressionContainer(node) {
            if (!node.parent) {
              return;
            }
            const parentNodeIndent = getNodeIndent(node.parent);
            checkNodesIndent(node, parentNodeIndent + indentSize);
          },
          Literal: handleLiteral,
          JSXText: handleLiteral,
          ReturnStatement(node) {
            if (!node.parent || !jsxUtil.isJSX(node.argument)) {
              return;
            }
            let fn = node.parent;
            while (fn && fn.type !== "FunctionDeclaration" && fn.type !== "FunctionExpression") {
              fn = fn.parent;
            }
            if (!fn || !jsxUtil.isReturningJSX(context, node, true)) {
              return;
            }
            const openingIndent = getNodeIndent(node);
            const closingIndent = getNodeIndent(node, true);
            if (openingIndent !== closingIndent) {
              report(node, openingIndent, closingIndent);
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-indent-props.js
var require_jsx_indent_props = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-indent-props.js"(exports, module) {
    "use strict";
    var astUtil = require_ast();
    var docsUrl = require_docsUrl();
    var getText = require_eslint().getText;
    var reportC = require_report();
    var messages = {
      wrongIndent: "Expected indentation of {{needed}} {{type}} {{characters}} but found {{gotten}}."
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce props indentation in JSX",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("jsx-indent-props")
        },
        fixable: "code",
        messages,
        schema: [{
          anyOf: [{
            enum: ["tab", "first"]
          }, {
            type: "integer"
          }, {
            type: "object",
            properties: {
              indentMode: {
                anyOf: [{
                  enum: ["tab", "first"]
                }, {
                  type: "integer"
                }]
              },
              ignoreTernaryOperator: {
                type: "boolean"
              }
            }
          }]
        }]
      },
      create(context) {
        const extraColumnStart = 0;
        let indentType = "space";
        let indentSize = 4;
        const line = {
          isUsingOperator: false,
          currentOperator: false
        };
        let ignoreTernaryOperator = false;
        if (context.options.length) {
          const isConfigObject = typeof context.options[0] === "object";
          const indentMode = isConfigObject ? context.options[0].indentMode : context.options[0];
          if (indentMode === "first") {
            indentSize = "first";
            indentType = "space";
          } else if (indentMode === "tab") {
            indentSize = 1;
            indentType = "tab";
          } else if (typeof indentMode === "number") {
            indentSize = indentMode;
            indentType = "space";
          }
          if (isConfigObject && context.options[0].ignoreTernaryOperator) {
            ignoreTernaryOperator = true;
          }
        }
        function report(node, needed, gotten) {
          const msgContext = {
            needed,
            type: indentType,
            characters: needed === 1 ? "character" : "characters",
            gotten
          };
          reportC(context, messages.wrongIndent, "wrongIndent", {
            node,
            data: msgContext,
            fix(fixer) {
              return fixer.replaceTextRange(
                [node.range[0] - node.loc.start.column, node.range[0]],
                Array(needed + 1).join(indentType === "space" ? " " : "	")
              );
            }
          });
        }
        function getNodeIndent(node) {
          let src = getText(context, node, node.loc.start.column + extraColumnStart);
          const lines = src.split("\n");
          src = lines[0];
          let regExp;
          if (indentType === "space") {
            regExp = /^[ ]+/;
          } else {
            regExp = /^[\t]+/;
          }
          const indent = regExp.exec(src);
          const useOperator = /^([ ]|[\t])*[:]/.test(src) || /^([ ]|[\t])*[?]/.test(src);
          const useBracket = /[<]/.test(src);
          line.currentOperator = false;
          if (useOperator) {
            line.isUsingOperator = true;
            line.currentOperator = true;
          } else if (useBracket) {
            line.isUsingOperator = false;
          }
          return indent ? indent[0].length : 0;
        }
        function checkNodesIndent(nodes, indent) {
          let nestedIndent = indent;
          nodes.forEach((node) => {
            const nodeIndent = getNodeIndent(node);
            if (line.isUsingOperator && !line.currentOperator && indentSize !== "first" && !ignoreTernaryOperator) {
              nestedIndent += indentSize;
              line.isUsingOperator = false;
            }
            if (node.type !== "ArrayExpression" && node.type !== "ObjectExpression" && nodeIndent !== nestedIndent && astUtil.isNodeFirstInLine(context, node)) {
              report(node, nestedIndent, nodeIndent);
            }
          });
        }
        return {
          JSXOpeningElement(node) {
            if (!node.attributes.length) {
              return;
            }
            let propIndent;
            if (indentSize === "first") {
              const firstPropNode = node.attributes[0];
              propIndent = firstPropNode.loc.start.column;
            } else {
              const elementIndent = getNodeIndent(node);
              propIndent = elementIndent + indentSize;
            }
            checkNodesIndent(node.attributes, propIndent);
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/hasProp.js
var require_hasProp2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/hasProp.js"(exports, module) {
    module.exports = require_lib().hasProp;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/propName.js
var require_propName2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/jsx-ast-utils@3.3.5/node_modules/jsx-ast-utils/propName.js"(exports, module) {
    module.exports = require_lib().propName;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-key.js
var require_jsx_key = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-key.js"(exports, module) {
    "use strict";
    var hasProp = require_hasProp2();
    var propName = require_propName2();
    var values = require_object3();
    var docsUrl = require_docsUrl();
    var pragmaUtil = require_pragma();
    var report = require_report();
    var astUtil = require_ast();
    var getText = require_eslint().getText;
    var defaultOptions = {
      checkFragmentShorthand: false,
      checkKeyMustBeforeSpread: false,
      warnOnDuplicates: false
    };
    var messages = {
      missingIterKey: 'Missing "key" prop for element in iterator',
      missingIterKeyUsePrag: 'Missing "key" prop for element in iterator. Shorthand fragment syntax does not support providing keys. Use {{reactPrag}}.{{fragPrag}} instead',
      missingArrayKey: 'Missing "key" prop for element in array',
      missingArrayKeyUsePrag: 'Missing "key" prop for element in array. Shorthand fragment syntax does not support providing keys. Use {{reactPrag}}.{{fragPrag}} instead',
      keyBeforeSpread: "`key` prop must be placed before any `{...spread}, to avoid conflicting with React\u2019s new JSX transform: https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html`",
      nonUniqueKeys: "`key` prop must be unique"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow missing `key` props in iterators/collection literals",
          category: "Possible Errors",
          recommended: true,
          url: docsUrl("jsx-key")
        },
        messages,
        schema: [{
          type: "object",
          properties: {
            checkFragmentShorthand: {
              type: "boolean",
              default: defaultOptions.checkFragmentShorthand
            },
            checkKeyMustBeforeSpread: {
              type: "boolean",
              default: defaultOptions.checkKeyMustBeforeSpread
            },
            warnOnDuplicates: {
              type: "boolean",
              default: defaultOptions.warnOnDuplicates
            }
          },
          additionalProperties: false
        }]
      },
      create(context) {
        const options = Object.assign({}, defaultOptions, context.options[0]);
        const checkFragmentShorthand = options.checkFragmentShorthand;
        const checkKeyMustBeforeSpread = options.checkKeyMustBeforeSpread;
        const warnOnDuplicates = options.warnOnDuplicates;
        const reactPragma = pragmaUtil.getFromContext(context);
        const fragmentPragma = pragmaUtil.getFragmentFromContext(context);
        function checkIteratorElement(node) {
          if (node.type === "JSXElement" && !hasProp(node.openingElement.attributes, "key")) {
            report(context, messages.missingIterKey, "missingIterKey", {
              node
            });
          } else if (checkFragmentShorthand && node.type === "JSXFragment") {
            report(context, messages.missingIterKeyUsePrag, "missingIterKeyUsePrag", {
              node,
              data: {
                reactPrag: reactPragma,
                fragPrag: fragmentPragma
              }
            });
          }
        }
        function getReturnStatements(node) {
          const returnStatements = arguments[1] || [];
          if (node.type === "IfStatement") {
            if (node.consequent) {
              getReturnStatements(node.consequent, returnStatements);
            }
            if (node.alternate) {
              getReturnStatements(node.alternate, returnStatements);
            }
          } else if (node.type === "ReturnStatement") {
            returnStatements.push(node);
          } else if (Array.isArray(node.body)) {
            node.body.forEach((item) => {
              if (item.type === "IfStatement") {
                getReturnStatements(item, returnStatements);
              }
              if (item.type === "ReturnStatement") {
                returnStatements.push(item);
              }
            });
          }
          return returnStatements;
        }
        function isKeyAfterSpread(attributes) {
          let hasFoundSpread = false;
          return attributes.some((attribute) => {
            if (attribute.type === "JSXSpreadAttribute") {
              hasFoundSpread = true;
              return false;
            }
            if (attribute.type !== "JSXAttribute") {
              return false;
            }
            return hasFoundSpread && propName(attribute) === "key";
          });
        }
        function checkFunctionsBlockStatement(node) {
          if (astUtil.isFunctionLikeExpression(node)) {
            if (node.body.type === "BlockStatement") {
              getReturnStatements(node.body).filter((returnStatement) => returnStatement && returnStatement.argument).forEach((returnStatement) => {
                checkIteratorElement(returnStatement.argument);
              });
            }
          }
        }
        function checkArrowFunctionWithJSX(node) {
          const isArrFn = node && node.type === "ArrowFunctionExpression";
          const shouldCheckNode = (n) => n && (n.type === "JSXElement" || n.type === "JSXFragment");
          if (isArrFn && shouldCheckNode(node.body)) {
            checkIteratorElement(node.body);
          }
          if (node.body.type === "ConditionalExpression") {
            if (shouldCheckNode(node.body.consequent)) {
              checkIteratorElement(node.body.consequent);
            }
            if (shouldCheckNode(node.body.alternate)) {
              checkIteratorElement(node.body.alternate);
            }
          } else if (node.body.type === "LogicalExpression" && shouldCheckNode(node.body.right)) {
            checkIteratorElement(node.body.right);
          }
        }
        const childrenToArraySelector = `:matches(
      CallExpression
        [callee.object.object.name=${reactPragma}]
        [callee.object.property.name=Children]
        [callee.property.name=toArray],
      CallExpression
        [callee.object.name=Children]
        [callee.property.name=toArray]
    )`.replace(/\s/g, "");
        let isWithinChildrenToArray = false;
        const seen = /* @__PURE__ */ new WeakSet();
        return {
          [childrenToArraySelector]() {
            isWithinChildrenToArray = true;
          },
          [`${childrenToArraySelector}:exit`]() {
            isWithinChildrenToArray = false;
          },
          "ArrayExpression, JSXElement > JSXElement"(node) {
            if (isWithinChildrenToArray) {
              return;
            }
            const jsx = (node.type === "ArrayExpression" ? node.elements : node.parent.children).filter((x) => x && x.type === "JSXElement");
            if (jsx.length === 0) {
              return;
            }
            const map = {};
            jsx.forEach((element) => {
              const attrs = element.openingElement.attributes;
              const keys = attrs.filter((x) => x.name && x.name.name === "key");
              if (keys.length === 0) {
                if (node.type === "ArrayExpression") {
                  report(context, messages.missingArrayKey, "missingArrayKey", {
                    node: element
                  });
                }
              } else {
                keys.forEach((attr) => {
                  const value = getText(context, attr.value);
                  if (!map[value]) {
                    map[value] = [];
                  }
                  map[value].push(attr);
                  if (checkKeyMustBeforeSpread && isKeyAfterSpread(attrs)) {
                    report(context, messages.keyBeforeSpread, "keyBeforeSpread", {
                      node: node.type === "ArrayExpression" ? node : node.parent
                    });
                  }
                });
              }
            });
            if (warnOnDuplicates) {
              values(map).filter((v) => v.length > 1).forEach((v) => {
                v.forEach((n) => {
                  if (!seen.has(n)) {
                    seen.add(n);
                    report(context, messages.nonUniqueKeys, "nonUniqueKeys", {
                      node: n
                    });
                  }
                });
              });
            }
          },
          JSXFragment(node) {
            if (!checkFragmentShorthand || isWithinChildrenToArray) {
              return;
            }
            if (node.parent.type === "ArrayExpression") {
              report(context, messages.missingArrayKeyUsePrag, "missingArrayKeyUsePrag", {
                node,
                data: {
                  reactPrag: reactPragma,
                  fragPrag: fragmentPragma
                }
              });
            }
          },
          // Array.prototype.map
          // eslint-disable-next-line no-multi-str
          'CallExpression[callee.type="MemberExpression"][callee.property.name="map"],       CallExpression[callee.type="OptionalMemberExpression"][callee.property.name="map"],       OptionalCallExpression[callee.type="MemberExpression"][callee.property.name="map"],       OptionalCallExpression[callee.type="OptionalMemberExpression"][callee.property.name="map"]'(node) {
            if (isWithinChildrenToArray) {
              return;
            }
            const fn = node.arguments.length > 0 && node.arguments[0];
            if (!fn || !astUtil.isFunctionLikeExpression(fn)) {
              return;
            }
            checkArrowFunctionWithJSX(fn);
            checkFunctionsBlockStatement(fn);
          },
          // Array.from
          'CallExpression[callee.type="MemberExpression"][callee.property.name="from"]'(node) {
            if (isWithinChildrenToArray) {
              return;
            }
            const fn = node.arguments.length > 1 && node.arguments[1];
            if (!astUtil.isFunctionLikeExpression(fn)) {
              return;
            }
            checkArrowFunctionWithJSX(fn);
            checkFunctionsBlockStatement(fn);
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-max-depth.js
var require_jsx_max_depth = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-max-depth.js"(exports, module) {
    "use strict";
    var has = require_polyfill19()();
    var includes = require_array_includes();
    var variableUtil = require_variable();
    var jsxUtil = require_jsx();
    var docsUrl = require_docsUrl();
    var reportC = require_report();
    var messages = {
      wrongDepth: "Expected the depth of nested jsx elements to be <= {{needed}}, but found {{found}}."
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce JSX maximum depth",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("jsx-max-depth")
        },
        messages,
        schema: [
          {
            type: "object",
            properties: {
              max: {
                type: "integer",
                minimum: 0
              }
            },
            additionalProperties: false
          }
        ]
      },
      create(context) {
        const DEFAULT_DEPTH = 2;
        const option = context.options[0] || {};
        const maxDepth = has(option, "max") ? option.max : DEFAULT_DEPTH;
        function isExpression(node) {
          return node.type === "JSXExpressionContainer";
        }
        function hasJSX(node) {
          return jsxUtil.isJSX(node) || isExpression(node) && jsxUtil.isJSX(node.expression);
        }
        function isLeaf(node) {
          const children = node.children;
          return !children || children.length === 0 || !children.some(hasJSX);
        }
        function getDepth(node) {
          let count = 0;
          while (jsxUtil.isJSX(node.parent) || isExpression(node.parent)) {
            node = node.parent;
            if (jsxUtil.isJSX(node)) {
              count += 1;
            }
          }
          return count;
        }
        function report(node, depth) {
          reportC(context, messages.wrongDepth, "wrongDepth", {
            node,
            data: {
              found: depth,
              needed: maxDepth
            }
          });
        }
        function findJSXElementOrFragment(variables, name, previousReferences) {
          function find(refs, prevRefs) {
            for (let i = refs.length - 1; i >= 0; i--) {
              if (has(refs[i], "writeExpr")) {
                const writeExpr = refs[i].writeExpr;
                return jsxUtil.isJSX(writeExpr) && writeExpr || writeExpr && writeExpr.type === "Identifier" && findJSXElementOrFragment(variables, writeExpr.name, prevRefs);
              }
            }
            return null;
          }
          const variable = variableUtil.getVariable(variables, name);
          if (variable && variable.references) {
            const containDuplicates = previousReferences.some((ref) => includes(variable.references, ref));
            if (containDuplicates) {
              return false;
            }
            return find(variable.references, previousReferences.concat(variable.references));
          }
          return false;
        }
        function checkDescendant(baseDepth, children) {
          baseDepth += 1;
          (children || []).filter((node) => hasJSX(node)).forEach((node) => {
            if (baseDepth > maxDepth) {
              report(node, baseDepth);
            } else if (!isLeaf(node)) {
              checkDescendant(baseDepth, node.children);
            }
          });
        }
        function handleJSX(node) {
          if (!isLeaf(node)) {
            return;
          }
          const depth = getDepth(node);
          if (depth > maxDepth) {
            report(node, depth);
          }
        }
        return {
          JSXElement: handleJSX,
          JSXFragment: handleJSX,
          JSXExpressionContainer(node) {
            if (node.expression.type !== "Identifier") {
              return;
            }
            const variables = variableUtil.variablesInScope(context, node);
            const element = findJSXElementOrFragment(variables, node.expression.name, []);
            if (element) {
              const baseDepth = getDepth(node);
              checkDescendant(baseDepth, element.children);
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-max-props-per-line.js
var require_jsx_max_props_per_line = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-max-props-per-line.js"(exports, module) {
    "use strict";
    var docsUrl = require_docsUrl();
    var getText = require_eslint().getText;
    var report = require_report();
    function getPropName(context, propNode) {
      if (propNode.type === "JSXSpreadAttribute") {
        return getText(context, propNode.argument);
      }
      return propNode.name.name;
    }
    var messages = {
      newLine: "Prop `{{prop}}` must be placed on a new line"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce maximum of props on a single line in JSX",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("jsx-max-props-per-line")
        },
        fixable: "code",
        messages,
        schema: [{
          anyOf: [{
            type: "object",
            properties: {
              maximum: {
                type: "object",
                properties: {
                  single: {
                    type: "integer",
                    minimum: 1
                  },
                  multi: {
                    type: "integer",
                    minimum: 1
                  }
                }
              }
            },
            additionalProperties: false
          }, {
            type: "object",
            properties: {
              maximum: {
                type: "number",
                minimum: 1
              },
              when: {
                type: "string",
                enum: ["always", "multiline"]
              }
            },
            additionalProperties: false
          }]
        }]
      },
      create(context) {
        const configuration = context.options[0] || {};
        const maximum = configuration.maximum || 1;
        const maxConfig = typeof maximum === "number" ? {
          single: configuration.when === "multiline" ? Infinity : maximum,
          multi: maximum
        } : {
          single: maximum.single || Infinity,
          multi: maximum.multi || Infinity
        };
        function generateFixFunction(line, max) {
          const output = [];
          const front = line[0].range[0];
          const back = line[line.length - 1].range[1];
          for (let i = 0; i < line.length; i += max) {
            const nodes = line.slice(i, i + max);
            output.push(nodes.reduce((prev, curr) => {
              if (prev === "") {
                return getText(context, curr);
              }
              return `${prev} ${getText(context, curr)}`;
            }, ""));
          }
          const code = output.join("\n");
          return function fix(fixer) {
            return fixer.replaceTextRange([front, back], code);
          };
        }
        return {
          JSXOpeningElement(node) {
            if (!node.attributes.length) {
              return;
            }
            const isSingleLineTag = node.loc.start.line === node.loc.end.line;
            if ((isSingleLineTag ? maxConfig.single : maxConfig.multi) === Infinity) {
              return;
            }
            const firstProp = node.attributes[0];
            const linePartitionedProps = [[firstProp]];
            node.attributes.reduce((last, decl) => {
              if (last.loc.end.line === decl.loc.start.line) {
                linePartitionedProps[linePartitionedProps.length - 1].push(decl);
              } else {
                linePartitionedProps.push([decl]);
              }
              return decl;
            });
            linePartitionedProps.forEach((propsInLine) => {
              const maxPropsCountPerLine = isSingleLineTag && propsInLine[0].loc.start.line === node.loc.start.line ? maxConfig.single : maxConfig.multi;
              if (propsInLine.length > maxPropsCountPerLine) {
                const name = getPropName(context, propsInLine[maxPropsCountPerLine]);
                report(context, messages.newLine, "newLine", {
                  node: propsInLine[maxPropsCountPerLine],
                  data: {
                    prop: name
                  },
                  fix: generateFixFunction(propsInLine, maxPropsCountPerLine)
                });
              }
            });
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-newline.js
var require_jsx_newline = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-newline.js"(exports, module) {
    "use strict";
    var docsUrl = require_docsUrl();
    var getText = require_eslint().getText;
    var report = require_report();
    var messages = {
      require: "JSX element should start in a new line",
      prevent: "JSX element should not start in a new line",
      allowMultilines: "Multiline JSX elements should start in a new line"
    };
    function isMultilined(node) {
      return node && node.loc.start.line !== node.loc.end.line;
    }
    module.exports = {
      meta: {
        docs: {
          description: "Require or prevent a new line after jsx elements and expressions.",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("jsx-newline")
        },
        fixable: "code",
        messages,
        schema: [
          {
            type: "object",
            properties: {
              prevent: {
                default: false,
                type: "boolean"
              },
              allowMultilines: {
                default: false,
                type: "boolean"
              }
            },
            additionalProperties: false,
            if: {
              properties: {
                allowMultilines: {
                  const: true
                }
              }
            },
            then: {
              properties: {
                prevent: {
                  const: true
                }
              },
              required: [
                "prevent"
              ]
            }
          }
        ]
      },
      create(context) {
        const jsxElementParents = /* @__PURE__ */ new Set();
        function isBlockCommentInCurlyBraces(element) {
          const elementRawValue = getText(context, element);
          return /^\s*{\/\*/.test(elementRawValue);
        }
        function isNonBlockComment(element) {
          return !isBlockCommentInCurlyBraces(element) && (element.type === "JSXElement" || element.type === "JSXExpressionContainer");
        }
        return {
          "Program:exit"() {
            jsxElementParents.forEach((parent) => {
              parent.children.forEach((element, index, elements) => {
                if (element.type === "JSXElement" || element.type === "JSXExpressionContainer") {
                  const configuration = context.options[0] || {};
                  const prevent = configuration.prevent || false;
                  const allowMultilines = configuration.allowMultilines || false;
                  const firstAdjacentSibling = elements[index + 1];
                  const secondAdjacentSibling = elements[index + 2];
                  const hasSibling = firstAdjacentSibling && secondAdjacentSibling && (firstAdjacentSibling.type === "Literal" || firstAdjacentSibling.type === "JSXText");
                  if (!hasSibling)
                    return;
                  const isWithoutNewLine = !/\n\s*\n/.test(firstAdjacentSibling.value);
                  if (isBlockCommentInCurlyBraces(element))
                    return;
                  if (allowMultilines && (isMultilined(element) || isMultilined(elements.slice(index + 2).find(isNonBlockComment)))) {
                    if (!isWithoutNewLine)
                      return;
                    const regex2 = /(\n)(?!.*\1)/g;
                    const replacement2 = "\n\n";
                    const messageId2 = "allowMultilines";
                    report(context, messages[messageId2], messageId2, {
                      node: secondAdjacentSibling,
                      fix(fixer) {
                        return fixer.replaceText(
                          firstAdjacentSibling,
                          getText(context, firstAdjacentSibling).replace(regex2, replacement2)
                        );
                      }
                    });
                    return;
                  }
                  if (isWithoutNewLine === prevent)
                    return;
                  const messageId = prevent ? "prevent" : "require";
                  const regex = prevent ? /(\n\n)(?!.*\1)/g : /(\n)(?!.*\1)/g;
                  const replacement = prevent ? "\n" : "\n\n";
                  report(context, messages[messageId], messageId, {
                    node: secondAdjacentSibling,
                    fix(fixer) {
                      return fixer.replaceText(
                        firstAdjacentSibling,
                        // double or remove the last newline
                        getText(context, firstAdjacentSibling).replace(regex, replacement)
                      );
                    }
                  });
                }
              });
            });
          },
          ":matches(JSXElement, JSXFragment) > :matches(JSXElement, JSXExpressionContainer)": (node) => {
            jsxElementParents.add(node.parent);
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-no-bind.js
var require_jsx_no_bind = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-no-bind.js"(exports, module) {
    "use strict";
    var propName = require_propName2();
    var docsUrl = require_docsUrl();
    var jsxUtil = require_jsx();
    var report = require_report();
    var getAncestors = require_eslint().getAncestors;
    var messages = {
      bindCall: "JSX props should not use .bind()",
      arrowFunc: "JSX props should not use arrow functions",
      bindExpression: "JSX props should not use ::",
      func: "JSX props should not use functions"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow `.bind()` or arrow functions in JSX props",
          category: "Best Practices",
          recommended: false,
          url: docsUrl("jsx-no-bind")
        },
        messages,
        schema: [{
          type: "object",
          properties: {
            allowArrowFunctions: {
              default: false,
              type: "boolean"
            },
            allowBind: {
              default: false,
              type: "boolean"
            },
            allowFunctions: {
              default: false,
              type: "boolean"
            },
            ignoreRefs: {
              default: false,
              type: "boolean"
            },
            ignoreDOMComponents: {
              default: false,
              type: "boolean"
            }
          },
          additionalProperties: false
        }]
      },
      create(context) {
        const configuration = context.options[0] || {};
        const blockVariableNameSets = {};
        function setBlockVariableNameSet(blockStart) {
          blockVariableNameSets[blockStart] = {
            arrowFunc: /* @__PURE__ */ new Set(),
            bindCall: /* @__PURE__ */ new Set(),
            bindExpression: /* @__PURE__ */ new Set(),
            func: /* @__PURE__ */ new Set()
          };
        }
        function getNodeViolationType(node) {
          const nodeType = node.type;
          if (!configuration.allowBind && nodeType === "CallExpression" && node.callee.type === "MemberExpression" && node.callee.property.type === "Identifier" && node.callee.property.name === "bind") {
            return "bindCall";
          }
          if (nodeType === "ConditionalExpression") {
            return getNodeViolationType(node.test) || getNodeViolationType(node.consequent) || getNodeViolationType(node.alternate);
          }
          if (!configuration.allowArrowFunctions && nodeType === "ArrowFunctionExpression") {
            return "arrowFunc";
          }
          if (!configuration.allowFunctions && (nodeType === "FunctionExpression" || nodeType === "FunctionDeclaration")) {
            return "func";
          }
          if (!configuration.allowBind && nodeType === "BindExpression") {
            return "bindExpression";
          }
          return null;
        }
        function addVariableNameToSet(violationType, variableName, blockStart) {
          blockVariableNameSets[blockStart][violationType].add(variableName);
        }
        function getBlockStatementAncestors(node) {
          return getAncestors(context, node).filter(
            (ancestor) => ancestor.type === "BlockStatement"
          ).reverse();
        }
        function reportVariableViolation(node, name, blockStart) {
          const blockSets = blockVariableNameSets[blockStart];
          const violationTypes = Object.keys(blockSets);
          return violationTypes.find((type) => {
            if (blockSets[type].has(name)) {
              report(context, messages[type], type, {
                node
              });
              return true;
            }
            return false;
          });
        }
        function findVariableViolation(node, name) {
          getBlockStatementAncestors(node).find(
            (block) => reportVariableViolation(node, name, block.range[0])
          );
        }
        return {
          BlockStatement(node) {
            setBlockVariableNameSet(node.range[0]);
          },
          FunctionDeclaration(node) {
            const blockAncestors = getBlockStatementAncestors(node);
            const variableViolationType = getNodeViolationType(node);
            if (blockAncestors.length > 0 && variableViolationType) {
              addVariableNameToSet(variableViolationType, node.id.name, blockAncestors[0].range[0]);
            }
          },
          VariableDeclarator(node) {
            if (!node.init) {
              return;
            }
            const blockAncestors = getBlockStatementAncestors(node);
            const variableViolationType = getNodeViolationType(node.init);
            if (blockAncestors.length > 0 && variableViolationType && node.parent.kind === "const") {
              addVariableNameToSet(
                variableViolationType,
                node.id.name,
                blockAncestors[0].range[0]
              );
            }
          },
          JSXAttribute(node) {
            const isRef = configuration.ignoreRefs && propName(node) === "ref";
            if (isRef || !node.value || !node.value.expression) {
              return;
            }
            const isDOMComponent = jsxUtil.isDOMComponent(node.parent);
            if (configuration.ignoreDOMComponents && isDOMComponent) {
              return;
            }
            const valueNode = node.value.expression;
            const valueNodeType = valueNode.type;
            const nodeViolationType = getNodeViolationType(valueNode);
            if (valueNodeType === "Identifier") {
              findVariableViolation(node, valueNode.name);
            } else if (nodeViolationType) {
              report(context, messages[nodeViolationType], nodeViolationType, {
                node
              });
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-no-comment-textnodes.js
var require_jsx_no_comment_textnodes = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-no-comment-textnodes.js"(exports, module) {
    "use strict";
    var docsUrl = require_docsUrl();
    var getText = require_eslint().getText;
    var report = require_report();
    var messages = {
      putCommentInBraces: "Comments inside children section of tag should be placed inside braces"
    };
    function checkText(context, node) {
      const rawValue = getText(context, node);
      if (/^\s*\/(\/|\*)/m.test(rawValue)) {
        if (node.parent.type !== "JSXAttribute" && node.parent.type !== "JSXExpressionContainer" && node.parent.type.indexOf("JSX") !== -1) {
          report(context, messages.putCommentInBraces, "putCommentInBraces", {
            node
          });
        }
      }
    }
    module.exports = {
      meta: {
        docs: {
          description: "Disallow comments from being inserted as text nodes",
          category: "Possible Errors",
          recommended: true,
          url: docsUrl("jsx-no-comment-textnodes")
        },
        messages,
        schema: []
      },
      create(context) {
        return {
          Literal(node) {
            checkText(context, node);
          },
          JSXText(node) {
            checkText(context, node);
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-no-constructed-context-values.js
var require_jsx_no_constructed_context_values = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-no-constructed-context-values.js"(exports, module) {
    "use strict";
    var Components = require_Components();
    var docsUrl = require_docsUrl();
    var getScope = require_eslint().getScope;
    var report = require_report();
    function isConstruction(node, callScope) {
      switch (node.type) {
        case "Literal":
          if (node.regex != null) {
            return { type: "regular expression", node };
          }
          return null;
        case "Identifier": {
          const variableScoping = callScope.set.get(node.name);
          if (variableScoping == null || variableScoping.defs == null) {
            return null;
          }
          const variableDefs = variableScoping.defs;
          const def = variableDefs[variableDefs.length - 1];
          if (def != null && def.type !== "Variable" && def.type !== "FunctionName") {
            return null;
          }
          if (def.node.type === "FunctionDeclaration") {
            return { type: "function declaration", node: def.node, usage: node };
          }
          const init = def.node.init;
          if (init == null) {
            return null;
          }
          const initConstruction = isConstruction(init, callScope);
          if (initConstruction == null) {
            return null;
          }
          return {
            type: initConstruction.type,
            node: initConstruction.node,
            usage: node
          };
        }
        case "ObjectExpression":
          return { type: "object", node };
        case "ArrayExpression":
          return { type: "array", node };
        case "ArrowFunctionExpression":
        case "FunctionExpression":
          return { type: "function expression", node };
        case "ClassExpression":
          return { type: "class expression", node };
        case "NewExpression":
          return { type: "new expression", node };
        case "ConditionalExpression":
          return isConstruction(node.consequent, callScope) || isConstruction(node.alternate, callScope);
        case "LogicalExpression":
          return isConstruction(node.left, callScope) || isConstruction(node.right, callScope);
        case "MemberExpression": {
          const objConstruction = isConstruction(node.object, callScope);
          if (objConstruction == null) {
            return null;
          }
          return {
            type: objConstruction.type,
            node: objConstruction.node,
            usage: node.object
          };
        }
        case "JSXFragment":
          return { type: "JSX fragment", node };
        case "JSXElement":
          return { type: "JSX element", node };
        case "AssignmentExpression": {
          const construct = isConstruction(node.right, callScope);
          if (construct != null) {
            return {
              type: "assignment expression",
              node: construct.node,
              usage: node
            };
          }
          return null;
        }
        case "TypeCastExpression":
        case "TSAsExpression":
          return isConstruction(node.expression, callScope);
        default:
          return null;
      }
    }
    var messages = {
      withIdentifierMsg: "The '{{variableName}}' {{type}} (at line {{nodeLine}}) passed as the value prop to the Context provider (at line {{usageLine}}) changes every render. To fix this consider wrapping it in a useMemo hook.",
      withIdentifierMsgFunc: "The '{{variableName}}' {{type}} (at line {{nodeLine}}) passed as the value prop to the Context provider (at line {{usageLine}}) changes every render. To fix this consider wrapping it in a useCallback hook.",
      defaultMsg: "The {{type}} passed as the value prop to the Context provider (at line {{nodeLine}}) changes every render. To fix this consider wrapping it in a useMemo hook.",
      defaultMsgFunc: "The {{type}} passed as the value prop to the Context provider (at line {{nodeLine}}) changes every render. To fix this consider wrapping it in a useCallback hook."
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallows JSX context provider values from taking values that will cause needless rerenders",
          category: "Best Practices",
          recommended: false,
          url: docsUrl("jsx-no-constructed-context-values")
        },
        messages,
        schema: false
      },
      // eslint-disable-next-line arrow-body-style
      create: Components.detect((context, components, utils) => {
        return {
          JSXOpeningElement(node) {
            const openingElementName = node.name;
            if (openingElementName.type !== "JSXMemberExpression") {
              return;
            }
            const isJsxContext = openingElementName.property.name === "Provider";
            if (!isJsxContext) {
              return;
            }
            const jsxValueAttribute = node.attributes.find(
              (attribute) => attribute.type === "JSXAttribute" && attribute.name.name === "value"
            );
            if (jsxValueAttribute == null) {
              return;
            }
            const valueNode = jsxValueAttribute.value;
            if (!valueNode) {
              return;
            }
            if (valueNode.type !== "JSXExpressionContainer") {
              return;
            }
            const valueExpression = valueNode.expression;
            const invocationScope = getScope(context, node);
            const constructInfo = isConstruction(valueExpression, invocationScope);
            if (constructInfo == null) {
              return;
            }
            if (!utils.getParentComponent(node)) {
              return;
            }
            const constructType = constructInfo.type;
            const constructNode = constructInfo.node;
            const constructUsage = constructInfo.usage;
            const data = {
              type: constructType,
              nodeLine: constructNode.loc.start.line
            };
            let messageId = "defaultMsg";
            if (constructUsage != null) {
              messageId = "withIdentifierMsg";
              data.usageLine = constructUsage.loc.start.line;
              data.variableName = constructUsage.name;
            }
            if (constructType === "function expression" || constructType === "function declaration") {
              messageId += "Func";
            }
            report(context, messages[messageId], messageId, {
              node: constructNode,
              data
            });
          }
        };
      })
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-no-duplicate-props.js
var require_jsx_no_duplicate_props = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-no-duplicate-props.js"(exports, module) {
    "use strict";
    var has = require_polyfill19()();
    var docsUrl = require_docsUrl();
    var report = require_report();
    var messages = {
      noDuplicateProps: "No duplicate props allowed"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow duplicate properties in JSX",
          category: "Possible Errors",
          recommended: true,
          url: docsUrl("jsx-no-duplicate-props")
        },
        messages,
        schema: [{
          type: "object",
          properties: {
            ignoreCase: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }]
      },
      create(context) {
        const configuration = context.options[0] || {};
        const ignoreCase = configuration.ignoreCase || false;
        return {
          JSXOpeningElement(node) {
            const props = {};
            node.attributes.forEach((decl) => {
              if (decl.type === "JSXSpreadAttribute") {
                return;
              }
              let name = decl.name.name;
              if (typeof name !== "string") {
                return;
              }
              if (ignoreCase) {
                name = name.toLowerCase();
              }
              if (has(props, name)) {
                report(context, messages.noDuplicateProps, "noDuplicateProps", {
                  node: decl
                });
              } else {
                props[name] = 1;
              }
            });
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.find/implementation.js
var require_implementation24 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.find/implementation.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var Call = require_Call();
    var GetIteratorDirect = require_GetIteratorDirect();
    var IsCallable = require_IsCallable();
    var IteratorClose = require_IteratorClose();
    var IteratorStepValue = require_IteratorStepValue();
    var NormalCompletion = require_NormalCompletion();
    var ThrowCompletion = require_ThrowCompletion();
    var ToBoolean = require_ToBoolean();
    var Type = require_Type2();
    module.exports = function find(predicate) {
      if (this instanceof find) {
        throw new $TypeError("`find` is not a constructor");
      }
      var O = this;
      if (Type(O) !== "Object") {
        throw new $TypeError("`this` value must be an Object");
      }
      if (!IsCallable(predicate)) {
        throw new $TypeError("`predicate` must be a function");
      }
      var iterated = GetIteratorDirect(O);
      var counter = 0;
      while (true) {
        var value = IteratorStepValue(iterated);
        if (iterated["[[Done]]"]) {
          return void 0;
        }
        var result;
        try {
          result = Call(predicate, void 0, [value, counter]);
        } catch (e) {
          IteratorClose(
            iterated,
            ThrowCompletion(e)
          );
        } finally {
          counter += 1;
        }
        if (ToBoolean(result)) {
          return IteratorClose(
            iterated,
            NormalCompletion(value)
          );
        }
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.find/polyfill.js
var require_polyfill22 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.find/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation24();
    module.exports = function getPolyfill() {
      return typeof Iterator === "function" && typeof Iterator.prototype.find === "function" ? Iterator.prototype.find : implementation;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.find/shim.js
var require_shim21 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.find/shim.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var getPolyfill = require_polyfill22();
    var $IteratorPrototype = require_implementation12();
    module.exports = function shimIteratorPrototypeFind() {
      var polyfill = getPolyfill();
      define(
        $IteratorPrototype,
        { find: polyfill },
        { find: function() {
          return $IteratorPrototype.find !== polyfill;
        } }
      );
      return polyfill;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.find/index.js
var require_Iterator_prototype5 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-iterator-helpers@1.0.19/node_modules/es-iterator-helpers/Iterator.prototype.find/index.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation24();
    var getPolyfill = require_polyfill22();
    var shim = require_shim21();
    var polyfill = callBind(getPolyfill());
    define(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = polyfill;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-no-leaked-render.js
var require_jsx_no_leaked_render = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-no-leaked-render.js"(exports, module) {
    "use strict";
    var find = require_Iterator_prototype5();
    var from = require_Iterator2();
    var getText = require_eslint().getText;
    var docsUrl = require_docsUrl();
    var report = require_report();
    var variableUtil = require_variable();
    var testReactVersion = require_version().testReactVersion;
    var isParenthesized = require_ast().isParenthesized;
    var messages = {
      noPotentialLeakedRender: "Potential leaked value that might cause unintentionally rendered values or rendering crashes"
    };
    var COERCE_STRATEGY = "coerce";
    var TERNARY_STRATEGY = "ternary";
    var DEFAULT_VALID_STRATEGIES = [TERNARY_STRATEGY, COERCE_STRATEGY];
    var COERCE_VALID_LEFT_SIDE_EXPRESSIONS = ["UnaryExpression", "BinaryExpression", "CallExpression"];
    var TERNARY_INVALID_ALTERNATE_VALUES = [void 0, null, false];
    function trimLeftNode(node) {
      if (node.type === "UnaryExpression" && node.argument.type === "UnaryExpression") {
        return trimLeftNode(node.argument.argument);
      }
      return node;
    }
    function getIsCoerceValidNestedLogicalExpression(node) {
      if (node.type === "LogicalExpression") {
        return getIsCoerceValidNestedLogicalExpression(node.left) && getIsCoerceValidNestedLogicalExpression(node.right);
      }
      return COERCE_VALID_LEFT_SIDE_EXPRESSIONS.some((validExpression) => validExpression === node.type);
    }
    function extractExpressionBetweenLogicalAnds(node) {
      if (node.type !== "LogicalExpression")
        return [node];
      if (node.operator !== "&&")
        return [node];
      return [].concat(
        extractExpressionBetweenLogicalAnds(node.left),
        extractExpressionBetweenLogicalAnds(node.right)
      );
    }
    function ruleFixer(context, fixStrategy, fixer, reportedNode, leftNode, rightNode) {
      const rightSideText = getText(context, rightNode);
      if (fixStrategy === COERCE_STRATEGY) {
        const expressions = extractExpressionBetweenLogicalAnds(leftNode);
        const newText = expressions.map((node) => {
          let nodeText = getText(context, node);
          if (isParenthesized(context, node)) {
            nodeText = `(${nodeText})`;
          }
          if (node.parent && node.parent.type === "ConditionalExpression" && node.parent.consequent.value === false) {
            return `${getIsCoerceValidNestedLogicalExpression(node) ? "" : "!"}${nodeText}`;
          }
          return `${getIsCoerceValidNestedLogicalExpression(node) ? "" : "!!"}${nodeText}`;
        }).join(" && ");
        if (rightNode.parent && rightNode.parent.type === "ConditionalExpression" && rightNode.parent.consequent.value === false) {
          const consequentVal = rightNode.parent.consequent.raw || rightNode.parent.consequent.name;
          const alternateVal = rightNode.parent.alternate.raw || rightNode.parent.alternate.name;
          if (rightNode.parent.test && rightNode.parent.test.type === "LogicalExpression") {
            return fixer.replaceText(reportedNode, `${newText} ? ${consequentVal} : ${alternateVal}`);
          }
          return fixer.replaceText(reportedNode, `${newText} && ${alternateVal}`);
        }
        if (rightNode.type === "ConditionalExpression" || rightNode.type === "LogicalExpression") {
          return fixer.replaceText(reportedNode, `${newText} && (${rightSideText})`);
        }
        if (rightNode.type === "JSXElement") {
          const rightSideTextLines = rightSideText.split("\n");
          if (rightSideTextLines.length > 1) {
            const rightSideTextLastLine = rightSideTextLines[rightSideTextLines.length - 1];
            const indentSpacesStart = " ".repeat(rightSideTextLastLine.search(/\S/));
            const indentSpacesClose = " ".repeat(rightSideTextLastLine.search(/\S/) - 2);
            return fixer.replaceText(reportedNode, `${newText} && (
${indentSpacesStart}${rightSideText}
${indentSpacesClose})`);
          }
        }
        if (rightNode.type === "Literal") {
          return null;
        }
        return fixer.replaceText(reportedNode, `${newText} && ${rightSideText}`);
      }
      if (fixStrategy === TERNARY_STRATEGY) {
        let leftSideText = getText(context, trimLeftNode(leftNode));
        if (isParenthesized(context, leftNode)) {
          leftSideText = `(${leftSideText})`;
        }
        return fixer.replaceText(reportedNode, `${leftSideText} ? ${rightSideText} : null`);
      }
      throw new TypeError('Invalid value for "validStrategies" option');
    }
    module.exports = {
      meta: {
        docs: {
          description: "Disallow problematic leaked values from being rendered",
          category: "Possible Errors",
          recommended: false,
          url: docsUrl("jsx-no-leaked-render")
        },
        messages,
        fixable: "code",
        schema: [
          {
            type: "object",
            properties: {
              validStrategies: {
                type: "array",
                items: {
                  enum: [
                    TERNARY_STRATEGY,
                    COERCE_STRATEGY
                  ]
                },
                uniqueItems: true,
                default: DEFAULT_VALID_STRATEGIES
              }
            },
            additionalProperties: false
          }
        ]
      },
      create(context) {
        const config = context.options[0] || {};
        const validStrategies = new Set(config.validStrategies || DEFAULT_VALID_STRATEGIES);
        const fixStrategy = find(from(validStrategies), () => true);
        return {
          'JSXExpressionContainer > LogicalExpression[operator="&&"]'(node) {
            const leftSide = node.left;
            const isCoerceValidLeftSide = COERCE_VALID_LEFT_SIDE_EXPRESSIONS.some((validExpression) => validExpression === leftSide.type);
            if (validStrategies.has(COERCE_STRATEGY)) {
              if (isCoerceValidLeftSide || getIsCoerceValidNestedLogicalExpression(leftSide)) {
                return;
              }
              const variables = variableUtil.variablesInScope(context, node);
              const leftSideVar = variableUtil.getVariable(variables, leftSide.name);
              if (leftSideVar) {
                const leftSideValue = leftSideVar.defs && leftSideVar.defs.length && leftSideVar.defs[0].node.init && leftSideVar.defs[0].node.init.value;
                if (typeof leftSideValue === "boolean") {
                  return;
                }
              }
            }
            if (testReactVersion(context, ">= 18") && leftSide.type === "Literal" && leftSide.value === "") {
              return;
            }
            report(context, messages.noPotentialLeakedRender, "noPotentialLeakedRender", {
              node,
              fix(fixer) {
                return ruleFixer(context, fixStrategy, fixer, node, leftSide, node.right);
              }
            });
          },
          "JSXExpressionContainer > ConditionalExpression"(node) {
            if (validStrategies.has(TERNARY_STRATEGY)) {
              return;
            }
            const isValidTernaryAlternate = TERNARY_INVALID_ALTERNATE_VALUES.indexOf(node.alternate.value) === -1;
            const isJSXElementAlternate = node.alternate.type === "JSXElement";
            if (isValidTernaryAlternate || isJSXElementAlternate) {
              return;
            }
            report(context, messages.noPotentialLeakedRender, "noPotentialLeakedRender", {
              node,
              fix(fixer) {
                return ruleFixer(context, fixStrategy, fixer, node, node.test, node.consequent);
              }
            });
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-no-literals.js
var require_jsx_no_literals = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-no-literals.js"(exports, module) {
    "use strict";
    var iterFrom = require_Iterator2();
    var map = require_Iterator_prototype();
    var docsUrl = require_docsUrl();
    var report = require_report();
    var getText = require_eslint().getText;
    function trimIfString(val) {
      return typeof val === "string" ? val.trim() : val;
    }
    var messages = {
      invalidPropValue: 'Invalid prop value: "{{text}}"',
      noStringsInAttributes: 'Strings not allowed in attributes: "{{text}}"',
      noStringsInJSX: 'Strings not allowed in JSX files: "{{text}}"',
      literalNotInJSXExpression: 'Missing JSX expression container around literal string: "{{text}}"'
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow usage of string literals in JSX",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("jsx-no-literals")
        },
        messages,
        schema: [{
          type: "object",
          properties: {
            noStrings: {
              type: "boolean"
            },
            allowedStrings: {
              type: "array",
              uniqueItems: true,
              items: {
                type: "string"
              }
            },
            ignoreProps: {
              type: "boolean"
            },
            noAttributeStrings: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }]
      },
      create(context) {
        const defaults = {
          noStrings: false,
          allowedStrings: [],
          ignoreProps: false,
          noAttributeStrings: false
        };
        const config = Object.assign({}, defaults, context.options[0] || {});
        config.allowedStrings = new Set(map(iterFrom(config.allowedStrings), trimIfString));
        function defaultMessageId() {
          const ancestorIsJSXElement = arguments.length >= 1 && arguments[0];
          if (config.noAttributeStrings && !ancestorIsJSXElement) {
            return "noStringsInAttributes";
          }
          if (config.noStrings) {
            return "noStringsInJSX";
          }
          return "literalNotInJSXExpression";
        }
        function getParentIgnoringBinaryExpressions(node) {
          let current = node;
          while (current.parent.type === "BinaryExpression") {
            current = current.parent;
          }
          return current.parent;
        }
        function getValidation(node) {
          const values = [trimIfString(node.raw), trimIfString(node.value)];
          if (values.some((value) => config.allowedStrings.has(value))) {
            return false;
          }
          const parent = getParentIgnoringBinaryExpressions(node);
          function isParentNodeStandard() {
            if (!/^[\s]+$/.test(node.value) && typeof node.value === "string" && parent.type.includes("JSX")) {
              if (config.noAttributeStrings) {
                return parent.type === "JSXAttribute" || parent.type === "JSXElement";
              }
              if (!config.noAttributeStrings) {
                return parent.type !== "JSXAttribute";
              }
            }
            return false;
          }
          const standard = isParentNodeStandard();
          if (config.noStrings) {
            return standard;
          }
          return standard && parent.type !== "JSXExpressionContainer";
        }
        function getParentAndGrandParentType(node) {
          const parent = getParentIgnoringBinaryExpressions(node);
          const parentType = parent.type;
          const grandParentType = parent.parent.type;
          return {
            parent,
            parentType,
            grandParentType,
            grandParent: parent.parent
          };
        }
        function hasJSXElementParentOrGrandParent(node) {
          const parents = getParentAndGrandParentType(node);
          const parentType = parents.parentType;
          const grandParentType = parents.grandParentType;
          return parentType === "JSXFragment" || parentType === "JSXElement" || grandParentType === "JSXElement";
        }
        function reportLiteralNode(node, messageId) {
          const ancestorIsJSXElement = hasJSXElementParentOrGrandParent(node);
          messageId = messageId || defaultMessageId(ancestorIsJSXElement);
          report(context, messages[messageId], messageId, {
            node,
            data: {
              text: getText(context, node).trim()
            }
          });
        }
        return {
          Literal(node) {
            if (getValidation(node) && (hasJSXElementParentOrGrandParent(node) || !config.ignoreProps)) {
              reportLiteralNode(node);
            }
          },
          JSXAttribute(node) {
            const isNodeValueString = node && node.value && node.value.type === "Literal" && typeof node.value.value === "string" && !config.allowedStrings.has(node.value.value);
            if (config.noStrings && !config.ignoreProps && isNodeValueString) {
              const messageId = "invalidPropValue";
              reportLiteralNode(node, messageId);
            }
          },
          JSXText(node) {
            if (getValidation(node)) {
              reportLiteralNode(node);
            }
          },
          TemplateLiteral(node) {
            const parents = getParentAndGrandParentType(node);
            const parentType = parents.parentType;
            const grandParentType = parents.grandParentType;
            const isParentJSXExpressionCont = parentType === "JSXExpressionContainer";
            const isParentJSXElement = parentType === "JSXElement" || grandParentType === "JSXElement";
            if (isParentJSXExpressionCont && config.noStrings && (isParentJSXElement || !config.ignoreProps)) {
              reportLiteralNode(node);
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/linkComponents.js
var require_linkComponents = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/linkComponents.js"(exports, module) {
    "use strict";
    var iterFrom = require_Iterator2();
    var map = require_Iterator_prototype();
    var DEFAULT_LINK_COMPONENTS = ["a"];
    var DEFAULT_LINK_ATTRIBUTE = "href";
    var DEFAULT_FORM_COMPONENTS = ["form"];
    var DEFAULT_FORM_ATTRIBUTE = "action";
    function getFormComponents(context) {
      const settings = context.settings || {};
      const formComponents = (
        /** @type {typeof DEFAULT_FORM_COMPONENTS} */
        DEFAULT_FORM_COMPONENTS.concat(settings.formComponents || [])
      );
      return new Map(map(iterFrom(formComponents), (value) => {
        if (typeof value === "string") {
          return [value, [DEFAULT_FORM_ATTRIBUTE]];
        }
        return [value.name, [].concat(value.formAttribute)];
      }));
    }
    function getLinkComponents(context) {
      const settings = context.settings || {};
      const linkComponents = (
        /** @type {typeof DEFAULT_LINK_COMPONENTS} */
        DEFAULT_LINK_COMPONENTS.concat(settings.linkComponents || [])
      );
      return new Map(map(iterFrom(linkComponents), (value) => {
        if (typeof value === "string") {
          return [value, [DEFAULT_LINK_ATTRIBUTE]];
        }
        return [value.name, [].concat(value.linkAttribute)];
      }));
    }
    module.exports = {
      getFormComponents,
      getLinkComponents
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-no-script-url.js
var require_jsx_no_script_url = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-no-script-url.js"(exports, module) {
    "use strict";
    var includes = require_array_includes();
    var docsUrl = require_docsUrl();
    var linkComponentsUtil = require_linkComponents();
    var report = require_report();
    var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
    function hasJavaScriptProtocol(attr) {
      return attr.value && attr.value.type === "Literal" && isJavaScriptProtocol.test(attr.value.value);
    }
    function shouldVerifyProp(node, config) {
      const name = node.name && node.name.name;
      const parentName = node.parent.name && node.parent.name.name;
      if (!name || !parentName || !config.has(parentName))
        return false;
      const attributes = config.get(parentName);
      return includes(attributes, name);
    }
    function parseLegacyOption(config, option) {
      option.forEach((opt) => {
        config.set(opt.name, opt.props);
      });
    }
    var messages = {
      noScriptURL: "A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML, try using dangerouslySetInnerHTML instead."
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow usage of `javascript:` URLs",
          category: "Best Practices",
          recommended: false,
          url: docsUrl("jsx-no-script-url")
        },
        messages,
        schema: {
          anyOf: [
            {
              type: "array",
              items: [
                {
                  type: "array",
                  uniqueItems: true,
                  items: {
                    type: "object",
                    properties: {
                      name: {
                        type: "string"
                      },
                      props: {
                        type: "array",
                        items: {
                          type: "string",
                          uniqueItems: true
                        }
                      }
                    },
                    required: ["name", "props"],
                    additionalProperties: false
                  }
                },
                {
                  type: "object",
                  properties: {
                    includeFromSettings: {
                      type: "boolean"
                    }
                  },
                  additionalItems: false
                }
              ],
              additionalItems: false
            },
            {
              type: "array",
              items: [
                {
                  type: "object",
                  properties: {
                    includeFromSettings: {
                      type: "boolean"
                    }
                  },
                  additionalItems: false
                }
              ],
              additionalItems: false
            }
          ]
        }
      },
      create(context) {
        const options = context.options;
        const hasLegacyOption = Array.isArray(options[0]);
        const legacyOptions = hasLegacyOption ? options[0] : [];
        const objectOption = hasLegacyOption && options.length > 1 ? options[1] : options.length > 0 ? options[0] : {
          includeFromSettings: false
        };
        const includeFromSettings = objectOption.includeFromSettings;
        const linkComponents = linkComponentsUtil.getLinkComponents(includeFromSettings ? context : {});
        parseLegacyOption(linkComponents, legacyOptions);
        return {
          JSXAttribute(node) {
            if (shouldVerifyProp(node, linkComponents) && hasJavaScriptProtocol(node)) {
              report(context, messages.noScriptURL, "noScriptURL", {
                node
              });
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-no-target-blank.js
var require_jsx_no_target_blank = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-no-target-blank.js"(exports, module) {
    "use strict";
    var includes = require_array_includes();
    var docsUrl = require_docsUrl();
    var linkComponentsUtil = require_linkComponents();
    var report = require_report();
    function findLastIndex(arr, condition) {
      for (let i = arr.length - 1; i >= 0; i -= 1) {
        if (condition(arr[i])) {
          return i;
        }
      }
      return -1;
    }
    function attributeValuePossiblyBlank(attribute) {
      if (!attribute || !attribute.value) {
        return false;
      }
      const value = attribute.value;
      if (value.type === "Literal") {
        return typeof value.value === "string" && value.value.toLowerCase() === "_blank";
      }
      if (value.type === "JSXExpressionContainer") {
        const expr = value.expression;
        if (expr.type === "Literal") {
          return typeof expr.value === "string" && expr.value.toLowerCase() === "_blank";
        }
        if (expr.type === "ConditionalExpression") {
          if (expr.alternate.type === "Literal" && expr.alternate.value && expr.alternate.value.toLowerCase() === "_blank") {
            return true;
          }
          if (expr.consequent.type === "Literal" && expr.consequent.value && expr.consequent.value.toLowerCase() === "_blank") {
            return true;
          }
        }
      }
      return false;
    }
    function hasExternalLink(node, linkAttributes, warnOnSpreadAttributes, spreadAttributeIndex) {
      const linkIndex = findLastIndex(node.attributes, (attr) => attr.name && includes(linkAttributes, attr.name.name));
      const foundExternalLink = linkIndex !== -1 && ((attr) => attr.value && attr.value.type === "Literal" && /^(?:\w+:|\/\/)/.test(attr.value.value))(
        node.attributes[linkIndex]
      );
      return foundExternalLink || warnOnSpreadAttributes && linkIndex < spreadAttributeIndex;
    }
    function hasDynamicLink(node, linkAttributes) {
      const dynamicLinkIndex = findLastIndex(node.attributes, (attr) => attr.name && includes(linkAttributes, attr.name.name) && attr.value && attr.value.type === "JSXExpressionContainer");
      if (dynamicLinkIndex !== -1) {
        return true;
      }
    }
    function getStringFromValue(value, targetValue) {
      if (value) {
        if (value.type === "Literal") {
          return value.value;
        }
        if (value.type === "JSXExpressionContainer") {
          if (value.expression.type === "TemplateLiteral") {
            return value.expression.quasis[0].value.cooked;
          }
          const expr = value.expression;
          if (expr && expr.type === "ConditionalExpression") {
            const relValues = [expr.consequent.value, expr.alternate.value];
            if (targetValue.type === "JSXExpressionContainer" && targetValue.expression && targetValue.expression.type === "ConditionalExpression") {
              const targetTestCond = targetValue.expression.test.name;
              const relTestCond = value.expression.test.name;
              if (targetTestCond === relTestCond) {
                const targetBlankIndex = [targetValue.expression.consequent.value, targetValue.expression.alternate.value].indexOf("_blank");
                return relValues[targetBlankIndex];
              }
            }
            return relValues;
          }
          return expr.value;
        }
      }
      return null;
    }
    function hasSecureRel(node, allowReferrer, warnOnSpreadAttributes, spreadAttributeIndex) {
      const relIndex = findLastIndex(node.attributes, (attr) => attr.type === "JSXAttribute" && attr.name.name === "rel");
      const targetIndex = findLastIndex(node.attributes, (attr) => attr.type === "JSXAttribute" && attr.name.name === "target");
      if (relIndex === -1 || warnOnSpreadAttributes && relIndex < spreadAttributeIndex) {
        return false;
      }
      const relAttribute = node.attributes[relIndex];
      const targetAttributeValue = node.attributes[targetIndex] && node.attributes[targetIndex].value;
      const value = getStringFromValue(relAttribute.value, targetAttributeValue);
      return [].concat(value).every((item) => {
        const tags = typeof item === "string" ? item.toLowerCase().split(" ") : false;
        const noreferrer = tags && tags.indexOf("noreferrer") >= 0;
        if (noreferrer) {
          return true;
        }
        const noopener = tags && tags.indexOf("noopener") >= 0;
        return allowReferrer && noopener;
      });
    }
    var messages = {
      noTargetBlankWithoutNoreferrer: 'Using target="_blank" without rel="noreferrer" (which implies rel="noopener") is a security risk in older browsers: see https://mathiasbynens.github.io/rel-noopener/#recommendations',
      noTargetBlankWithoutNoopener: 'Using target="_blank" without rel="noreferrer" or rel="noopener" (the former implies the latter and is preferred due to wider support) is a security risk: see https://mathiasbynens.github.io/rel-noopener/#recommendations'
    };
    module.exports = {
      meta: {
        fixable: "code",
        docs: {
          description: 'Disallow `target="_blank"` attribute without `rel="noreferrer"`',
          category: "Best Practices",
          recommended: true,
          url: docsUrl("jsx-no-target-blank")
        },
        messages,
        schema: [{
          type: "object",
          properties: {
            allowReferrer: {
              type: "boolean"
            },
            enforceDynamicLinks: {
              enum: ["always", "never"]
            },
            warnOnSpreadAttributes: {
              type: "boolean"
            },
            links: {
              type: "boolean",
              default: true
            },
            forms: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }]
      },
      create(context) {
        const configuration = Object.assign(
          {
            allowReferrer: false,
            warnOnSpreadAttributes: false,
            links: true,
            forms: false
          },
          context.options[0]
        );
        const allowReferrer = configuration.allowReferrer;
        const warnOnSpreadAttributes = configuration.warnOnSpreadAttributes;
        const enforceDynamicLinks = configuration.enforceDynamicLinks || "always";
        const linkComponents = linkComponentsUtil.getLinkComponents(context);
        const formComponents = linkComponentsUtil.getFormComponents(context);
        return {
          JSXOpeningElement(node) {
            const targetIndex = findLastIndex(node.attributes, (attr) => attr.name && attr.name.name === "target");
            const spreadAttributeIndex = findLastIndex(node.attributes, (attr) => attr.type === "JSXSpreadAttribute");
            if (linkComponents.has(node.name.name)) {
              if (!attributeValuePossiblyBlank(node.attributes[targetIndex])) {
                const hasSpread = spreadAttributeIndex >= 0;
                if (warnOnSpreadAttributes && hasSpread) {
                } else if (hasSpread && targetIndex < spreadAttributeIndex || !hasSpread || !warnOnSpreadAttributes) {
                  return;
                }
              }
              const linkAttributes = linkComponents.get(node.name.name);
              const hasDangerousLink = hasExternalLink(node, linkAttributes, warnOnSpreadAttributes, spreadAttributeIndex) || enforceDynamicLinks === "always" && hasDynamicLink(node, linkAttributes);
              if (hasDangerousLink && !hasSecureRel(node, allowReferrer, warnOnSpreadAttributes, spreadAttributeIndex)) {
                const messageId = allowReferrer ? "noTargetBlankWithoutNoopener" : "noTargetBlankWithoutNoreferrer";
                const relValue = allowReferrer ? "noopener" : "noreferrer";
                report(context, messages[messageId], messageId, {
                  node,
                  fix(fixer) {
                    const nodeWithAttrs = node.parent.attributes ? node.parent : node;
                    const relAttribute = nodeWithAttrs.attributes.find((attr) => attr.name && attr.name.name === "rel");
                    if (targetIndex < spreadAttributeIndex || spreadAttributeIndex >= 0 && !relAttribute) {
                      return null;
                    }
                    if (!relAttribute) {
                      return fixer.insertTextAfter(nodeWithAttrs.attributes.slice(-1)[0], ` rel="${relValue}"`);
                    }
                    if (!relAttribute.value) {
                      return fixer.insertTextAfter(relAttribute, `="${relValue}"`);
                    }
                    if (relAttribute.value.type === "Literal") {
                      const parts = relAttribute.value.value.split("noreferrer").filter(Boolean);
                      return fixer.replaceText(relAttribute.value, `"${parts.concat("noreferrer").join(" ")}"`);
                    }
                    if (relAttribute.value.type === "JSXExpressionContainer") {
                      if (relAttribute.value.expression.type === "Literal") {
                        if (typeof relAttribute.value.expression.value === "string") {
                          const parts = relAttribute.value.expression.value.split("noreferrer").filter(Boolean);
                          return fixer.replaceText(relAttribute.value.expression, `"${parts.concat("noreferrer").join(" ")}"`);
                        }
                        return fixer.replaceText(relAttribute.value, '"noreferrer"');
                      }
                    }
                    return null;
                  }
                });
              }
            }
            if (formComponents.has(node.name.name)) {
              if (!attributeValuePossiblyBlank(node.attributes[targetIndex])) {
                const hasSpread = spreadAttributeIndex >= 0;
                if (warnOnSpreadAttributes && hasSpread) {
                } else if (hasSpread && targetIndex < spreadAttributeIndex || !hasSpread || !warnOnSpreadAttributes) {
                  return;
                }
              }
              if (!configuration.forms || hasSecureRel(node)) {
                return;
              }
              const formAttributes = formComponents.get(node.name.name);
              if (hasExternalLink(node, formAttributes) || enforceDynamicLinks === "always" && hasDynamicLink(node, formAttributes)) {
                const messageId = allowReferrer ? "noTargetBlankWithoutNoopener" : "noTargetBlankWithoutNoreferrer";
                report(context, messages[messageId], messageId, {
                  node
                });
              }
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-no-useless-fragment.js
var require_jsx_no_useless_fragment = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-no-useless-fragment.js"(exports, module) {
    "use strict";
    var arrayIncludes = require_array_includes();
    var pragmaUtil = require_pragma();
    var jsxUtil = require_jsx();
    var docsUrl = require_docsUrl();
    var report = require_report();
    var getText = require_eslint().getText;
    function isJSXText(node) {
      return !!node && (node.type === "JSXText" || node.type === "Literal");
    }
    function isOnlyWhitespace(text) {
      return text.trim().length === 0;
    }
    function isNonspaceJSXTextOrJSXCurly(node) {
      return isJSXText(node) && !isOnlyWhitespace(node.raw) || node.type === "JSXExpressionContainer";
    }
    function isFragmentWithOnlyTextAndIsNotChild(node) {
      return node.children.length === 1 && isJSXText(node.children[0]) && !(node.parent.type === "JSXElement" || node.parent.type === "JSXFragment");
    }
    function trimLikeReact(text) {
      const leadingSpaces = /^\s*/.exec(text)[0];
      const trailingSpaces = /\s*$/.exec(text)[0];
      const start = arrayIncludes(leadingSpaces, "\n") ? leadingSpaces.length : 0;
      const end = arrayIncludes(trailingSpaces, "\n") ? text.length - trailingSpaces.length : text.length;
      return text.slice(start, end);
    }
    function isKeyedElement(node) {
      return node.type === "JSXElement" && node.openingElement.attributes && node.openingElement.attributes.some(jsxUtil.isJSXAttributeKey);
    }
    function containsCallExpression(node) {
      return node && node.type === "JSXExpressionContainer" && node.expression && node.expression.type === "CallExpression";
    }
    var messages = {
      NeedsMoreChildren: "Fragments should contain more than one child - otherwise, there\u2019s no need for a Fragment at all.",
      ChildOfHtmlElement: "Passing a fragment to an HTML element is useless."
    };
    module.exports = {
      meta: {
        type: "suggestion",
        fixable: "code",
        docs: {
          description: "Disallow unnecessary fragments",
          category: "Possible Errors",
          recommended: false,
          url: docsUrl("jsx-no-useless-fragment")
        },
        messages,
        schema: [{
          type: "object",
          properties: {
            allowExpressions: {
              type: "boolean"
            }
          }
        }]
      },
      create(context) {
        const config = context.options[0] || {};
        const allowExpressions = config.allowExpressions || false;
        const reactPragma = pragmaUtil.getFromContext(context);
        const fragmentPragma = pragmaUtil.getFragmentFromContext(context);
        function isPaddingSpaces(node) {
          return isJSXText(node) && isOnlyWhitespace(node.raw) && arrayIncludes(node.raw, "\n");
        }
        function isFragmentWithSingleExpression(node) {
          const children = node && node.children.filter((child) => !isPaddingSpaces(child));
          return children && children.length === 1 && children[0].type === "JSXExpressionContainer";
        }
        function hasLessThanTwoChildren(node) {
          if (!node || !node.children) {
            return true;
          }
          const nonPaddingChildren = node.children.filter(
            (child) => !isPaddingSpaces(child)
          );
          if (nonPaddingChildren.length < 2) {
            return !containsCallExpression(nonPaddingChildren[0]);
          }
        }
        function isChildOfHtmlElement(node) {
          return node.parent.type === "JSXElement" && node.parent.openingElement.name.type === "JSXIdentifier" && /^[a-z]+$/.test(node.parent.openingElement.name.name);
        }
        function isChildOfComponentElement(node) {
          return node.parent.type === "JSXElement" && !isChildOfHtmlElement(node) && !jsxUtil.isFragment(node.parent, reactPragma, fragmentPragma);
        }
        function canFix(node) {
          if (!(node.parent.type === "JSXElement" || node.parent.type === "JSXFragment")) {
            if (node.children.length === 0) {
              return false;
            }
            if (node.children.some(isNonspaceJSXTextOrJSXCurly)) {
              return false;
            }
          }
          if (isChildOfComponentElement(node)) {
            return false;
          }
          if (node.type === "JSXFragment" && (!node.openingFragment || !node.closingFragment)) {
            return false;
          }
          return true;
        }
        function getFix(node) {
          if (!canFix(node)) {
            return void 0;
          }
          return function fix(fixer) {
            const opener = node.type === "JSXFragment" ? node.openingFragment : node.openingElement;
            const closer = node.type === "JSXFragment" ? node.closingFragment : node.closingElement;
            const childrenText = opener.selfClosing ? "" : getText(context).slice(opener.range[1], closer.range[0]);
            return fixer.replaceText(node, trimLikeReact(childrenText));
          };
        }
        function checkNode(node) {
          if (isKeyedElement(node)) {
            return;
          }
          if (hasLessThanTwoChildren(node) && !isFragmentWithOnlyTextAndIsNotChild(node) && !(allowExpressions && isFragmentWithSingleExpression(node))) {
            report(context, messages.NeedsMoreChildren, "NeedsMoreChildren", {
              node,
              fix: getFix(node)
            });
          }
          if (isChildOfHtmlElement(node)) {
            report(context, messages.ChildOfHtmlElement, "ChildOfHtmlElement", {
              node,
              fix: getFix(node)
            });
          }
        }
        return {
          JSXElement(node) {
            if (jsxUtil.isFragment(node, reactPragma, fragmentPragma)) {
              checkNode(node);
            }
          },
          JSXFragment: checkNode
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-one-expression-per-line.js
var require_jsx_one_expression_per_line = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-one-expression-per-line.js"(exports, module) {
    "use strict";
    var docsUrl = require_docsUrl();
    var eslintUtil = require_eslint();
    var jsxUtil = require_jsx();
    var report = require_report();
    var getSourceCode = eslintUtil.getSourceCode;
    var getText = eslintUtil.getText;
    var optionDefaults = {
      allow: "none"
    };
    var messages = {
      moveToNewLine: "`{{descriptor}}` must be placed on a new line"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Require one JSX element per line",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("jsx-one-expression-per-line")
        },
        fixable: "whitespace",
        messages,
        schema: [
          {
            type: "object",
            properties: {
              allow: {
                enum: ["none", "literal", "single-child", "non-jsx"]
              }
            },
            default: optionDefaults,
            additionalProperties: false
          }
        ]
      },
      create(context) {
        const options = Object.assign({}, optionDefaults, context.options[0]);
        function nodeKey(node) {
          return `${node.loc.start.line},${node.loc.start.column}`;
        }
        function nodeDescriptor(n) {
          return n.openingElement ? n.openingElement.name.name : getText(context, n).replace(/\n/g, "");
        }
        function handleJSX(node) {
          const children = node.children;
          if (!children || !children.length) {
            return;
          }
          if (options.allow === "non-jsx" && !children.find((child) => child.type === "JSXFragment" || child.type === "JSXElement")) {
            return;
          }
          const openingElement = node.openingElement || node.openingFragment;
          const closingElement = node.closingElement || node.closingFragment;
          const openingElementStartLine = openingElement.loc.start.line;
          const openingElementEndLine = openingElement.loc.end.line;
          const closingElementStartLine = closingElement.loc.start.line;
          const closingElementEndLine = closingElement.loc.end.line;
          if (children.length === 1) {
            const child = children[0];
            if (openingElementStartLine === openingElementEndLine && openingElementEndLine === closingElementStartLine && closingElementStartLine === closingElementEndLine && closingElementEndLine === child.loc.start.line && child.loc.start.line === child.loc.end.line) {
              if (options.allow === "single-child" || options.allow === "literal" && (child.type === "Literal" || child.type === "JSXText")) {
                return;
              }
            }
          }
          const childrenGroupedByLine = {};
          const fixDetailsByNode = {};
          children.forEach((child) => {
            let countNewLinesBeforeContent = 0;
            let countNewLinesAfterContent = 0;
            if (child.type === "Literal" || child.type === "JSXText") {
              if (jsxUtil.isWhiteSpaces(child.raw)) {
                return;
              }
              countNewLinesBeforeContent = (child.raw.match(/^\s*\n/g) || []).length;
              countNewLinesAfterContent = (child.raw.match(/\n\s*$/g) || []).length;
            }
            const startLine = child.loc.start.line + countNewLinesBeforeContent;
            const endLine = child.loc.end.line - countNewLinesAfterContent;
            if (startLine === endLine) {
              if (!childrenGroupedByLine[startLine]) {
                childrenGroupedByLine[startLine] = [];
              }
              childrenGroupedByLine[startLine].push(child);
            } else {
              if (!childrenGroupedByLine[startLine]) {
                childrenGroupedByLine[startLine] = [];
              }
              childrenGroupedByLine[startLine].push(child);
              if (!childrenGroupedByLine[endLine]) {
                childrenGroupedByLine[endLine] = [];
              }
              childrenGroupedByLine[endLine].push(child);
            }
          });
          Object.keys(childrenGroupedByLine).forEach((_line) => {
            const line = parseInt(_line, 10);
            const firstIndex = 0;
            const lastIndex = childrenGroupedByLine[line].length - 1;
            childrenGroupedByLine[line].forEach((child, i) => {
              let prevChild;
              let nextChild;
              if (i === firstIndex) {
                if (line === openingElementEndLine) {
                  prevChild = openingElement;
                }
              } else {
                prevChild = childrenGroupedByLine[line][i - 1];
              }
              if (i === lastIndex) {
                if (line === closingElementStartLine) {
                  nextChild = closingElement;
                }
              } else {
              }
              function spaceBetweenPrev() {
                return (prevChild.type === "Literal" || prevChild.type === "JSXText") && / $/.test(prevChild.raw) || (child.type === "Literal" || child.type === "JSXText") && /^ /.test(child.raw) || getSourceCode(context).isSpaceBetweenTokens(prevChild, child);
              }
              function spaceBetweenNext() {
                return (nextChild.type === "Literal" || nextChild.type === "JSXText") && /^ /.test(nextChild.raw) || (child.type === "Literal" || child.type === "JSXText") && / $/.test(child.raw) || getSourceCode(context).isSpaceBetweenTokens(child, nextChild);
              }
              if (!prevChild && !nextChild) {
                return;
              }
              const source = getText(context, child);
              const leadingSpace = !!(prevChild && spaceBetweenPrev());
              const trailingSpace = !!(nextChild && spaceBetweenNext());
              const leadingNewLine = !!prevChild;
              const trailingNewLine = !!nextChild;
              const key = nodeKey(child);
              if (!fixDetailsByNode[key]) {
                fixDetailsByNode[key] = {
                  node: child,
                  source,
                  descriptor: nodeDescriptor(child)
                };
              }
              if (leadingSpace) {
                fixDetailsByNode[key].leadingSpace = true;
              }
              if (leadingNewLine) {
                fixDetailsByNode[key].leadingNewLine = true;
              }
              if (trailingNewLine) {
                fixDetailsByNode[key].trailingNewLine = true;
              }
              if (trailingSpace) {
                fixDetailsByNode[key].trailingSpace = true;
              }
            });
          });
          Object.keys(fixDetailsByNode).forEach((key) => {
            const details = fixDetailsByNode[key];
            const nodeToReport = details.node;
            const descriptor = details.descriptor;
            const source = details.source.replace(/(^ +| +(?=\n)*$)/g, "");
            const leadingSpaceString = details.leadingSpace ? "\n{' '}" : "";
            const trailingSpaceString = details.trailingSpace ? "{' '}\n" : "";
            const leadingNewLineString = details.leadingNewLine ? "\n" : "";
            const trailingNewLineString = details.trailingNewLine ? "\n" : "";
            const replaceText = `${leadingSpaceString}${leadingNewLineString}${source}${trailingNewLineString}${trailingSpaceString}`;
            report(context, messages.moveToNewLine, "moveToNewLine", {
              node: nodeToReport,
              data: {
                descriptor
              },
              fix(fixer) {
                return fixer.replaceText(nodeToReport, replaceText);
              }
            });
          });
        }
        return {
          JSXElement: handleJSX,
          JSXFragment: handleJSX
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-no-undef.js
var require_jsx_no_undef = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-no-undef.js"(exports, module) {
    "use strict";
    var docsUrl = require_docsUrl();
    var eslintUtil = require_eslint();
    var jsxUtil = require_jsx();
    var report = require_report();
    var messages = {
      undefined: "'{{identifier}}' is not defined."
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow undeclared variables in JSX",
          category: "Possible Errors",
          recommended: true,
          url: docsUrl("jsx-no-undef")
        },
        messages,
        schema: [{
          type: "object",
          properties: {
            allowGlobals: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }]
      },
      create(context) {
        const config = context.options[0] || {};
        const allowGlobals = config.allowGlobals || false;
        function checkIdentifierInJSX(node) {
          let scope = eslintUtil.getScope(context, node);
          const sourceCode = eslintUtil.getSourceCode(context);
          const sourceType = sourceCode.ast.sourceType;
          const scopeUpperBound = !allowGlobals && sourceType === "module" ? "module" : "global";
          let variables = scope.variables;
          let i;
          let len;
          if (node.name === "this") {
            return;
          }
          while (scope.type !== scopeUpperBound && scope.type !== "global") {
            scope = scope.upper;
            variables = scope.variables.concat(variables);
          }
          if (scope.childScopes.length) {
            variables = scope.childScopes[0].variables.concat(variables);
            if (scope.childScopes[0].childScopes.length) {
              variables = scope.childScopes[0].childScopes[0].variables.concat(variables);
            }
          }
          for (i = 0, len = variables.length; i < len; i++) {
            if (variables[i].name === node.name) {
              return;
            }
          }
          report(context, messages.undefined, "undefined", {
            node,
            data: {
              identifier: node.name
            }
          });
        }
        return {
          JSXOpeningElement(node) {
            switch (node.name.type) {
              case "JSXIdentifier":
                if (jsxUtil.isDOMComponent(node)) {
                  return;
                }
                node = node.name;
                break;
              case "JSXMemberExpression":
                node = node.name;
                do {
                  node = node.object;
                } while (node && node.type !== "JSXIdentifier");
                break;
              case "JSXNamespacedName":
                return;
              default:
                break;
            }
            checkIdentifierInJSX(node);
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-curly-brace-presence.js
var require_jsx_curly_brace_presence = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-curly-brace-presence.js"(exports, module) {
    "use strict";
    var arrayIncludes = require_array_includes();
    var docsUrl = require_docsUrl();
    var jsxUtil = require_jsx();
    var report = require_report();
    var eslintUtil = require_eslint();
    var getSourceCode = eslintUtil.getSourceCode;
    var getText = eslintUtil.getText;
    var OPTION_ALWAYS = "always";
    var OPTION_NEVER = "never";
    var OPTION_IGNORE = "ignore";
    var OPTION_VALUES = [
      OPTION_ALWAYS,
      OPTION_NEVER,
      OPTION_IGNORE
    ];
    var DEFAULT_CONFIG = { props: OPTION_NEVER, children: OPTION_NEVER, propElementValues: OPTION_IGNORE };
    var messages = {
      unnecessaryCurly: "Curly braces are unnecessary here.",
      missingCurly: "Need to wrap this literal in a JSX expression."
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow unnecessary JSX expressions when literals alone are sufficient or enforce JSX expressions on literals in JSX children or attributes",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("jsx-curly-brace-presence")
        },
        fixable: "code",
        messages,
        schema: [
          {
            anyOf: [
              {
                type: "object",
                properties: {
                  props: { enum: OPTION_VALUES },
                  children: { enum: OPTION_VALUES },
                  propElementValues: { enum: OPTION_VALUES }
                },
                additionalProperties: false
              },
              {
                enum: OPTION_VALUES
              }
            ]
          }
        ]
      },
      create(context) {
        const HTML_ENTITY_REGEX = () => /&[A-Za-z\d#]+;/g;
        const ruleOptions = context.options[0];
        const userConfig = typeof ruleOptions === "string" ? { props: ruleOptions, children: ruleOptions, propElementValues: OPTION_IGNORE } : Object.assign({}, DEFAULT_CONFIG, ruleOptions);
        function containsLineTerminators(rawStringValue) {
          return /[\n\r\u2028\u2029]/.test(rawStringValue);
        }
        function containsBackslash(rawStringValue) {
          return arrayIncludes(rawStringValue, "\\");
        }
        function containsHTMLEntity(rawStringValue) {
          return HTML_ENTITY_REGEX().test(rawStringValue);
        }
        function containsOnlyHtmlEntities(rawStringValue) {
          return rawStringValue.replace(HTML_ENTITY_REGEX(), "").trim() === "";
        }
        function containsDisallowedJSXTextChars(rawStringValue) {
          return /[{<>}]/.test(rawStringValue);
        }
        function containsQuoteCharacters(value) {
          return /['"]/.test(value);
        }
        function containsMultilineComment(value) {
          return /\/\*/.test(value);
        }
        function escapeDoubleQuotes(rawStringValue) {
          return rawStringValue.replace(/\\"/g, '"').replace(/"/g, '\\"');
        }
        function escapeBackslashes(rawStringValue) {
          return rawStringValue.replace(/\\/g, "\\\\");
        }
        function needToEscapeCharacterForJSX(raw, node) {
          return containsBackslash(raw) || containsHTMLEntity(raw) || node.parent.type !== "JSXAttribute" && containsDisallowedJSXTextChars(raw);
        }
        function containsWhitespaceExpression(child) {
          if (child.type === "JSXExpressionContainer") {
            const value = child.expression.value;
            return value ? jsxUtil.isWhiteSpaces(value) : false;
          }
          return false;
        }
        function isLineBreak(text) {
          return containsLineTerminators(text) && text.trim() === "";
        }
        function wrapNonHTMLEntities(text) {
          const HTML_ENTITY = "<HTML_ENTITY>";
          const withCurlyBraces = text.split(HTML_ENTITY_REGEX()).map((word) => word === "" ? "" : `{${JSON.stringify(word)}}`).join(HTML_ENTITY);
          const htmlEntities = text.match(HTML_ENTITY_REGEX());
          return htmlEntities.reduce((acc, htmlEntity) => acc.replace(HTML_ENTITY, htmlEntity), withCurlyBraces);
        }
        function wrapWithCurlyBraces(rawText) {
          if (!containsLineTerminators(rawText)) {
            return `{${JSON.stringify(rawText)}}`;
          }
          return rawText.split("\n").map((line) => {
            if (line.trim() === "") {
              return line;
            }
            const firstCharIndex = line.search(/[^\s]/);
            const leftWhitespace = line.slice(0, firstCharIndex);
            const text = line.slice(firstCharIndex);
            if (containsHTMLEntity(line)) {
              return `${leftWhitespace}${wrapNonHTMLEntities(text)}`;
            }
            return `${leftWhitespace}{${JSON.stringify(text)}}`;
          }).join("\n");
        }
        function reportUnnecessaryCurly(JSXExpressionNode) {
          report(context, messages.unnecessaryCurly, "unnecessaryCurly", {
            node: JSXExpressionNode,
            fix(fixer) {
              const expression = JSXExpressionNode.expression;
              let textToReplace;
              if (jsxUtil.isJSX(expression)) {
                textToReplace = getText(context, expression);
              } else {
                const expressionType = expression && expression.type;
                const parentType = JSXExpressionNode.parent.type;
                if (parentType === "JSXAttribute") {
                  textToReplace = `"${expressionType === "TemplateLiteral" ? expression.quasis[0].value.raw : expression.raw.slice(1, -1)}"`;
                } else if (jsxUtil.isJSX(expression)) {
                  textToReplace = getText(context, expression);
                } else {
                  textToReplace = expressionType === "TemplateLiteral" ? expression.quasis[0].value.cooked : expression.value;
                }
              }
              return fixer.replaceText(JSXExpressionNode, textToReplace);
            }
          });
        }
        function reportMissingCurly(literalNode) {
          report(context, messages.missingCurly, "missingCurly", {
            node: literalNode,
            fix(fixer) {
              if (jsxUtil.isJSX(literalNode)) {
                return fixer.replaceText(literalNode, `{${getText(context, literalNode)}}`);
              }
              if (containsOnlyHtmlEntities(literalNode.raw) || literalNode.parent.type === "JSXAttribute" && containsLineTerminators(literalNode.raw) || isLineBreak(literalNode.raw)) {
                return null;
              }
              const expression = literalNode.parent.type === "JSXAttribute" ? `{"${escapeDoubleQuotes(escapeBackslashes(
                literalNode.raw.slice(1, -1)
              ))}"}` : wrapWithCurlyBraces(literalNode.raw);
              return fixer.replaceText(literalNode, expression);
            }
          });
        }
        function isWhiteSpaceLiteral(node) {
          return node.type && node.type === "Literal" && node.value && jsxUtil.isWhiteSpaces(node.value);
        }
        function isStringWithTrailingWhiteSpaces(value) {
          return /^\s|\s$/.test(value);
        }
        function isLiteralWithTrailingWhiteSpaces(node) {
          return node.type && node.type === "Literal" && node.value && isStringWithTrailingWhiteSpaces(node.value);
        }
        function lintUnnecessaryCurly(JSXExpressionNode) {
          const expression = JSXExpressionNode.expression;
          const expressionType = expression.type;
          const sourceCode = getSourceCode(context);
          if (sourceCode.getCommentsInside && sourceCode.getCommentsInside(JSXExpressionNode).length > 0) {
            return;
          }
          if ((expressionType === "Literal" || expressionType === "JSXText") && typeof expression.value === "string" && (JSXExpressionNode.parent.type === "JSXAttribute" && !isWhiteSpaceLiteral(expression) || !isLiteralWithTrailingWhiteSpaces(expression)) && !containsMultilineComment(expression.value) && !needToEscapeCharacterForJSX(expression.raw, JSXExpressionNode) && (jsxUtil.isJSX(JSXExpressionNode.parent) || !containsQuoteCharacters(expression.value))) {
            reportUnnecessaryCurly(JSXExpressionNode);
          } else if (expressionType === "TemplateLiteral" && expression.expressions.length === 0 && expression.quasis[0].value.raw.indexOf("\n") === -1 && !isStringWithTrailingWhiteSpaces(expression.quasis[0].value.raw) && !needToEscapeCharacterForJSX(expression.quasis[0].value.raw, JSXExpressionNode) && !containsQuoteCharacters(expression.quasis[0].value.cooked)) {
            reportUnnecessaryCurly(JSXExpressionNode);
          } else if (jsxUtil.isJSX(expression)) {
            reportUnnecessaryCurly(JSXExpressionNode);
          }
        }
        function areRuleConditionsSatisfied(parent, config, ruleCondition) {
          return parent.type === "JSXAttribute" && typeof config.props === "string" && config.props === ruleCondition || jsxUtil.isJSX(parent) && typeof config.children === "string" && config.children === ruleCondition;
        }
        function getAdjacentSiblings(node, children) {
          for (let i = 1; i < children.length - 1; i++) {
            const child = children[i];
            if (node === child) {
              return [children[i - 1], children[i + 1]];
            }
          }
          if (node === children[0] && children[1]) {
            return [children[1]];
          }
          if (node === children[children.length - 1] && children[children.length - 2]) {
            return [children[children.length - 2]];
          }
          return [];
        }
        function hasAdjacentJsxExpressionContainers(node, children) {
          if (!children) {
            return false;
          }
          const childrenExcludingWhitespaceLiteral = children.filter((child) => !isWhiteSpaceLiteral(child));
          const adjSiblings = getAdjacentSiblings(node, childrenExcludingWhitespaceLiteral);
          return adjSiblings.some((x) => x.type && x.type === "JSXExpressionContainer");
        }
        function hasAdjacentJsx(node, children) {
          if (!children) {
            return false;
          }
          const childrenExcludingWhitespaceLiteral = children.filter((child) => !isWhiteSpaceLiteral(child));
          const adjSiblings = getAdjacentSiblings(node, childrenExcludingWhitespaceLiteral);
          return adjSiblings.some((x) => x.type && arrayIncludes(["JSXExpressionContainer", "JSXElement"], x.type));
        }
        function shouldCheckForUnnecessaryCurly(node, config) {
          const parent = node.parent;
          if (parent.type && parent.type === "JSXAttribute" && (node.expression && node.expression.type && node.expression.type !== "Literal" && node.expression.type !== "StringLiteral" && node.expression.type !== "TemplateLiteral")) {
            return false;
          }
          if (jsxUtil.isJSX(parent) && hasAdjacentJsxExpressionContainers(node, parent.children)) {
            return false;
          }
          if (containsWhitespaceExpression(node) && hasAdjacentJsx(node, parent.children)) {
            return false;
          }
          if (parent.children && parent.children.length === 1 && containsWhitespaceExpression(node)) {
            return false;
          }
          return areRuleConditionsSatisfied(parent, config, OPTION_NEVER);
        }
        function shouldCheckForMissingCurly(node, config) {
          if (jsxUtil.isJSX(node)) {
            return config.propElementValues !== OPTION_IGNORE;
          }
          if (isLineBreak(node.raw) || containsOnlyHtmlEntities(node.raw)) {
            return false;
          }
          const parent = node.parent;
          if (parent.children && parent.children.length === 1 && containsWhitespaceExpression(parent.children[0])) {
            return false;
          }
          return areRuleConditionsSatisfied(parent, config, OPTION_ALWAYS);
        }
        return {
          "JSXAttribute > JSXExpressionContainer > JSXElement"(node) {
            if (userConfig.propElementValues === OPTION_NEVER) {
              reportUnnecessaryCurly(node.parent);
            }
          },
          JSXExpressionContainer(node) {
            if (shouldCheckForUnnecessaryCurly(node, userConfig)) {
              lintUnnecessaryCurly(node);
            }
          },
          "JSXAttribute > JSXElement, Literal, JSXText"(node) {
            if (shouldCheckForMissingCurly(node, userConfig)) {
              reportMissingCurly(node);
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/concat-map@0.0.1/node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/concat-map@0.0.1/node_modules/concat-map/index.js"(exports, module) {
    module.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js"(exports, module) {
    "use strict";
    module.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/brace-expansion@1.1.11/node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/brace-expansion@1.1.11/node_modules/brace-expansion/index.js"(exports, module) {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/minimatch@3.1.2/node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/minimatch@3.1.2/node_modules/minimatch/minimatch.js"(exports, module) {
    module.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path = function() {
      try {
        return __require("path");
      } catch (e) {
      }
    }() || {
      sep: "/"
    };
    minimatch.sep = path.sep;
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      b = b || {};
      var t = {};
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      m.Minimatch.defaults = function defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      };
      m.filter = function filter2(pattern, options) {
        return orig.filter(pattern, ext(def, options));
      };
      m.defaults = function defaults(options) {
        return orig.defaults(ext(def, options));
      };
      m.makeRe = function makeRe2(pattern, options) {
        return orig.makeRe(pattern, ext(def, options));
      };
      m.braceExpand = function braceExpand2(pattern, options) {
        return orig.braceExpand(pattern, ext(def, options));
      };
      m.match = function(list, pattern, options) {
        return orig.match(list, pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      assertValidPattern(pattern);
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      assertValidPattern(pattern);
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (!options.allowWindowsEscape && path.sep !== "/") {
        pattern = pattern.split(path.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = function debug() {
          console.error.apply(console, arguments);
        };
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    }
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = function(pattern) {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    Minimatch.prototype.parse = parse;
    var SUBPARSE = {};
    function parse(pattern, isSub) {
      assertValidPattern(pattern);
      var options = this.options;
      if (pattern === "**") {
        if (!options.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      }
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/": {
            return false;
          }
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case "[":
        case ".":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = function match(f, partial) {
      if (typeof partial === "undefined")
        partial = this.partial;
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options = this.options;
      if (path.sep !== "/") {
        f = f.split(path.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    };
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug(
        "matchOne",
        { "this": this, file, pattern }
      );
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-pascal-case.js
var require_jsx_pascal_case = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-pascal-case.js"(exports, module) {
    "use strict";
    var elementType = require_elementType2();
    var minimatch = require_minimatch();
    var docsUrl = require_docsUrl();
    var jsxUtil = require_jsx();
    var report = require_report();
    function testDigit(char) {
      const charCode = char.charCodeAt(0);
      return charCode >= 48 && charCode <= 57;
    }
    function testUpperCase(char) {
      const upperCase = char.toUpperCase();
      return char === upperCase && upperCase !== char.toLowerCase();
    }
    function testLowerCase(char) {
      const lowerCase = char.toLowerCase();
      return char === lowerCase && lowerCase !== char.toUpperCase();
    }
    function testPascalCase(name) {
      if (!testUpperCase(name.charAt(0))) {
        return false;
      }
      const anyNonAlphaNumeric = Array.prototype.some.call(
        name.slice(1),
        (char) => char.toLowerCase() === char.toUpperCase() && !testDigit(char)
      );
      if (anyNonAlphaNumeric) {
        return false;
      }
      return Array.prototype.some.call(
        name.slice(1),
        (char) => testLowerCase(char) || testDigit(char)
      );
    }
    function testAllCaps(name) {
      const firstChar = name.charAt(0);
      if (!(testUpperCase(firstChar) || testDigit(firstChar))) {
        return false;
      }
      for (let i = 1; i < name.length - 1; i += 1) {
        const char = name.charAt(i);
        if (!(testUpperCase(char) || testDigit(char) || char === "_")) {
          return false;
        }
      }
      const lastChar = name.charAt(name.length - 1);
      if (!(testUpperCase(lastChar) || testDigit(lastChar))) {
        return false;
      }
      return true;
    }
    function ignoreCheck(ignore, name) {
      return ignore.some(
        (entry) => name === entry || minimatch(name, entry, { noglobstar: true })
      );
    }
    var messages = {
      usePascalCase: "Imported JSX component {{name}} must be in PascalCase",
      usePascalOrSnakeCase: "Imported JSX component {{name}} must be in PascalCase or SCREAMING_SNAKE_CASE"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce PascalCase for user-defined JSX components",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("jsx-pascal-case")
        },
        messages,
        schema: [{
          type: "object",
          properties: {
            allowAllCaps: {
              type: "boolean"
            },
            allowLeadingUnderscore: {
              type: "boolean"
            },
            allowNamespace: {
              type: "boolean"
            },
            ignore: {
              items: [
                {
                  type: "string"
                }
              ],
              minItems: 0,
              type: "array",
              uniqueItems: true
            }
          },
          additionalProperties: false
        }]
      },
      create(context) {
        const configuration = context.options[0] || {};
        const allowAllCaps = configuration.allowAllCaps || false;
        const allowLeadingUnderscore = configuration.allowLeadingUnderscore || false;
        const allowNamespace = configuration.allowNamespace || false;
        const ignore = configuration.ignore || [];
        return {
          JSXOpeningElement(node) {
            const isCompatTag = jsxUtil.isDOMComponent(node);
            if (isCompatTag)
              return void 0;
            const name = elementType(node);
            let checkNames = [name];
            let index = 0;
            if (name.lastIndexOf(":") > -1) {
              checkNames = name.split(":");
            } else if (name.lastIndexOf(".") > -1) {
              checkNames = name.split(".");
            }
            do {
              const splitName = checkNames[index];
              if (splitName.length === 1)
                return void 0;
              const isIgnored = ignoreCheck(ignore, splitName);
              const checkName = allowLeadingUnderscore && splitName.startsWith("_") ? splitName.slice(1) : splitName;
              const isPascalCase = testPascalCase(checkName);
              const isAllowedAllCaps = allowAllCaps && testAllCaps(checkName);
              if (!isPascalCase && !isAllowedAllCaps && !isIgnored) {
                const messageId = allowAllCaps ? "usePascalOrSnakeCase" : "usePascalCase";
                report(context, messages[messageId], messageId, {
                  node,
                  data: {
                    name: splitName
                  }
                });
                break;
              }
              index += 1;
            } while (index < checkNames.length && !allowNamespace);
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-fragments.js
var require_jsx_fragments = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-fragments.js"(exports, module) {
    "use strict";
    var elementType = require_elementType2();
    var pragmaUtil = require_pragma();
    var variableUtil = require_variable();
    var testReactVersion = require_version().testReactVersion;
    var docsUrl = require_docsUrl();
    var report = require_report();
    var getText = require_eslint().getText;
    function replaceNode(source, node, text) {
      return `${source.slice(0, node.range[0])}${text}${source.slice(node.range[1])}`;
    }
    var messages = {
      fragmentsNotSupported: "Fragments are only supported starting from React v16.2. Please disable the `react/jsx-fragments` rule in `eslint` settings or upgrade your version of React.",
      preferPragma: "Prefer {{react}}.{{fragment}} over fragment shorthand",
      preferFragment: "Prefer fragment shorthand over {{react}}.{{fragment}}"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce shorthand or standard form for React fragments",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("jsx-fragments")
        },
        fixable: "code",
        messages,
        schema: [{
          enum: ["syntax", "element"]
        }]
      },
      create(context) {
        const configuration = context.options[0] || "syntax";
        const reactPragma = pragmaUtil.getFromContext(context);
        const fragmentPragma = pragmaUtil.getFragmentFromContext(context);
        const openFragShort = "<>";
        const closeFragShort = "</>";
        const openFragLong = `<${reactPragma}.${fragmentPragma}>`;
        const closeFragLong = `</${reactPragma}.${fragmentPragma}>`;
        function reportOnReactVersion(node) {
          if (!testReactVersion(context, ">= 16.2.0")) {
            report(context, messages.fragmentsNotSupported, "fragmentsNotSupported", {
              node
            });
            return true;
          }
          return false;
        }
        function getFixerToLong(jsxFragment) {
          if (!jsxFragment.closingFragment || !jsxFragment.openingFragment) {
            return null;
          }
          return function fix(fixer) {
            let source = getText(context);
            source = replaceNode(source, jsxFragment.closingFragment, closeFragLong);
            source = replaceNode(source, jsxFragment.openingFragment, openFragLong);
            const lengthDiff = openFragLong.length - getText(context, jsxFragment.openingFragment).length + closeFragLong.length - getText(context, jsxFragment.closingFragment).length;
            const range = jsxFragment.range;
            return fixer.replaceTextRange(range, source.slice(range[0], range[1] + lengthDiff));
          };
        }
        function getFixerToShort(jsxElement) {
          return function fix(fixer) {
            let source = getText(context);
            let lengthDiff;
            if (jsxElement.closingElement) {
              source = replaceNode(source, jsxElement.closingElement, closeFragShort);
              source = replaceNode(source, jsxElement.openingElement, openFragShort);
              lengthDiff = getText(context, jsxElement.openingElement).length - openFragShort.length + getText(context, jsxElement.closingElement).length - closeFragShort.length;
            } else {
              source = replaceNode(source, jsxElement.openingElement, `${openFragShort}${closeFragShort}`);
              lengthDiff = getText(context, jsxElement.openingElement).length - openFragShort.length - closeFragShort.length;
            }
            const range = jsxElement.range;
            return fixer.replaceTextRange(range, source.slice(range[0], range[1] - lengthDiff));
          };
        }
        function refersToReactFragment(node, name) {
          const variableInit = variableUtil.findVariableByName(context, node, name);
          if (!variableInit) {
            return false;
          }
          if (variableInit.type === "Identifier" && variableInit.name === reactPragma) {
            return true;
          }
          if (variableInit.type === "MemberExpression" && variableInit.object.type === "Identifier" && variableInit.object.name === reactPragma && variableInit.property.type === "Identifier" && variableInit.property.name === fragmentPragma) {
            return true;
          }
          if (variableInit.callee && variableInit.callee.name === "require" && variableInit.arguments && variableInit.arguments[0] && variableInit.arguments[0].value === "react") {
            return true;
          }
          return false;
        }
        const jsxElements = [];
        const fragmentNames = /* @__PURE__ */ new Set([`${reactPragma}.${fragmentPragma}`]);
        return {
          JSXElement(node) {
            jsxElements.push(node);
          },
          JSXFragment(node) {
            if (reportOnReactVersion(node)) {
              return;
            }
            if (configuration === "element") {
              report(context, messages.preferPragma, "preferPragma", {
                node,
                data: {
                  react: reactPragma,
                  fragment: fragmentPragma
                },
                fix: getFixerToLong(node)
              });
            }
          },
          ImportDeclaration(node) {
            if (node.source && node.source.value === "react") {
              node.specifiers.forEach((spec) => {
                if (spec.imported && spec.imported.name === fragmentPragma) {
                  if (spec.local) {
                    fragmentNames.add(spec.local.name);
                  }
                }
              });
            }
          },
          "Program:exit"() {
            jsxElements.forEach((node) => {
              const openingEl = node.openingElement;
              const elName = elementType(openingEl);
              if (fragmentNames.has(elName) || refersToReactFragment(node, elName)) {
                if (reportOnReactVersion(node)) {
                  return;
                }
                const attrs = openingEl.attributes;
                if (configuration === "syntax" && !(attrs && attrs.length > 0)) {
                  report(context, messages.preferFragment, "preferFragment", {
                    node,
                    data: {
                      react: reactPragma,
                      fragment: fragmentPragma
                    },
                    fix: getFixerToShort(node)
                  });
                }
              }
            });
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-props-no-multi-spaces.js
var require_jsx_props_no_multi_spaces = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-props-no-multi-spaces.js"(exports, module) {
    "use strict";
    var docsUrl = require_docsUrl();
    var eslintUtil = require_eslint();
    var report = require_report();
    var getSourceCode = eslintUtil.getSourceCode;
    var getText = eslintUtil.getText;
    var messages = {
      noLineGap: "Expected no line gap between \u201C{{prop1}}\u201D and \u201C{{prop2}}\u201D",
      onlyOneSpace: "Expected only one space between \u201C{{prop1}}\u201D and \u201C{{prop2}}\u201D"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow multiple spaces between inline JSX props",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("jsx-props-no-multi-spaces")
        },
        fixable: "code",
        messages,
        schema: []
      },
      create(context) {
        const sourceCode = getSourceCode(context);
        function getPropName(propNode) {
          switch (propNode.type) {
            case "JSXSpreadAttribute":
              return getText(context, propNode.argument);
            case "JSXIdentifier":
              return propNode.name;
            case "JSXMemberExpression":
              return `${getPropName(propNode.object)}.${propNode.property.name}`;
            default:
              return propNode.name ? propNode.name.name : `${getText(context, propNode.object)}.${propNode.property.name}`;
          }
        }
        function hasEmptyLines(first, second) {
          const comments = sourceCode.getCommentsBefore ? sourceCode.getCommentsBefore(second) : [];
          const nodes = [].concat(first, comments, second);
          for (let i = 1; i < nodes.length; i += 1) {
            const prev = nodes[i - 1];
            const curr = nodes[i];
            if (curr.loc.start.line - prev.loc.end.line >= 2) {
              return true;
            }
          }
          return false;
        }
        function checkSpacing(prev, node) {
          if (hasEmptyLines(prev, node)) {
            report(context, messages.noLineGap, "noLineGap", {
              node,
              data: {
                prop1: getPropName(prev),
                prop2: getPropName(node)
              }
            });
          }
          if (prev.loc.end.line !== node.loc.end.line) {
            return;
          }
          const between = getSourceCode(context).text.slice(prev.range[1], node.range[0]);
          if (between !== " ") {
            report(context, messages.onlyOneSpace, "onlyOneSpace", {
              node,
              data: {
                prop1: getPropName(prev),
                prop2: getPropName(node)
              },
              fix(fixer) {
                return fixer.replaceTextRange([prev.range[1], node.range[0]], " ");
              }
            });
          }
        }
        function containsGenericType(node) {
          const nodeTypeParams = node.typeParameters;
          if (typeof nodeTypeParams === "undefined") {
            return false;
          }
          return nodeTypeParams.type === "TSTypeParameterInstantiation";
        }
        function getGenericNode(node) {
          const name = node.name;
          if (containsGenericType(node)) {
            const type = node.typeParameters;
            return Object.assign(
              {},
              node,
              {
                range: [
                  name.range[0],
                  type.range[1]
                ]
              }
            );
          }
          return name;
        }
        return {
          JSXOpeningElement(node) {
            node.attributes.reduce((prev, prop) => {
              checkSpacing(prev, prop);
              return prop;
            }, getGenericNode(node));
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-props-no-spreading.js
var require_jsx_props_no_spreading = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-props-no-spreading.js"(exports, module) {
    "use strict";
    var docsUrl = require_docsUrl();
    var report = require_report();
    var OPTIONS = { ignore: "ignore", enforce: "enforce" };
    var DEFAULTS = {
      html: OPTIONS.enforce,
      custom: OPTIONS.enforce,
      explicitSpread: OPTIONS.enforce,
      exceptions: []
    };
    var isException = (tag, allExceptions) => allExceptions.indexOf(tag) !== -1;
    var isProperty = (property) => property.type === "Property";
    var getTagNameFromMemberExpression = (node) => {
      if (node.property.parent) {
        return `${node.property.parent.object.name}.${node.property.name}`;
      }
      return `${node.object.name}.${node.property.name}`;
    };
    var messages = {
      noSpreading: "Prop spreading is forbidden"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow JSX prop spreading",
          category: "Best Practices",
          recommended: false,
          url: docsUrl("jsx-props-no-spreading")
        },
        messages,
        schema: [{
          allOf: [{
            type: "object",
            properties: {
              html: {
                enum: [OPTIONS.enforce, OPTIONS.ignore]
              },
              custom: {
                enum: [OPTIONS.enforce, OPTIONS.ignore]
              },
              exceptions: {
                type: "array",
                items: {
                  type: "string",
                  uniqueItems: true
                }
              }
            }
          }, {
            not: {
              type: "object",
              required: ["html", "custom"],
              properties: {
                html: {
                  enum: [OPTIONS.ignore]
                },
                custom: {
                  enum: [OPTIONS.ignore]
                },
                exceptions: {
                  type: "array",
                  minItems: 0,
                  maxItems: 0
                }
              }
            }
          }]
        }]
      },
      create(context) {
        const configuration = context.options[0] || {};
        const ignoreHtmlTags = (configuration.html || DEFAULTS.html) === OPTIONS.ignore;
        const ignoreCustomTags = (configuration.custom || DEFAULTS.custom) === OPTIONS.ignore;
        const ignoreExplicitSpread = (configuration.explicitSpread || DEFAULTS.explicitSpread) === OPTIONS.ignore;
        const exceptions = configuration.exceptions || DEFAULTS.exceptions;
        return {
          JSXSpreadAttribute(node) {
            const jsxOpeningElement = node.parent.name;
            const type = jsxOpeningElement.type;
            let tagName;
            if (type === "JSXIdentifier") {
              tagName = jsxOpeningElement.name;
            } else if (type === "JSXMemberExpression") {
              tagName = getTagNameFromMemberExpression(jsxOpeningElement);
            } else {
              tagName = void 0;
            }
            const isHTMLTag = tagName && tagName[0] !== tagName[0].toUpperCase();
            const isCustomTag = tagName && (tagName[0] === tagName[0].toUpperCase() || tagName.includes("."));
            if (isHTMLTag && (ignoreHtmlTags && !isException(tagName, exceptions) || !ignoreHtmlTags && isException(tagName, exceptions))) {
              return;
            }
            if (isCustomTag && (ignoreCustomTags && !isException(tagName, exceptions) || !ignoreCustomTags && isException(tagName, exceptions))) {
              return;
            }
            if (ignoreExplicitSpread && node.argument.type === "ObjectExpression" && node.argument.properties.every(isProperty)) {
              return;
            }
            report(context, messages.noSpreading, "noSpreading", {
              node
            });
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/log.js
var require_log = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/log.js"(exports, module) {
    "use strict";
    function log(message) {
      if (!/=-(f|-format)=/.test(__Process$.argv.join("="))) {
        console.log(message);
      }
    }
    module.exports = log;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-sort-default-props.js
var require_jsx_sort_default_props = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-sort-default-props.js"(exports, module) {
    "use strict";
    var variableUtil = require_variable();
    var docsUrl = require_docsUrl();
    var report = require_report();
    var log = require_log();
    var eslintUtil = require_eslint();
    var getFirstTokens = eslintUtil.getFirstTokens;
    var getText = eslintUtil.getText;
    var isWarnedForDeprecation = false;
    var messages = {
      propsNotSorted: "Default prop types declarations should be sorted alphabetically"
    };
    module.exports = {
      meta: {
        deprecated: true,
        replacedBy: ["sort-default-props"],
        docs: {
          description: "Enforce defaultProps declarations alphabetical sorting",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("jsx-sort-default-props")
        },
        // fixable: 'code',
        messages,
        schema: [{
          type: "object",
          properties: {
            ignoreCase: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }]
      },
      create(context) {
        const configuration = context.options[0] || {};
        const ignoreCase = configuration.ignoreCase || false;
        function getPropertyName(node) {
          if (node.key || ["MethodDefinition", "Property"].indexOf(node.type) !== -1) {
            return node.key.name;
          }
          if (node.type === "MemberExpression") {
            return node.property.name;
          }
          if (node.type === "ClassProperty") {
            const tokens = getFirstTokens(context, node, 2);
            return tokens[1] && tokens[1].type === "Identifier" ? tokens[1].value : tokens[0].value;
          }
          return "";
        }
        function isDefaultPropsDeclaration(node) {
          const propName = getPropertyName(node);
          return propName === "defaultProps" || propName === "getDefaultProps";
        }
        function getKey(node) {
          return getText(context, node.key || node.argument);
        }
        function findVariableByName(node, name) {
          const variable = variableUtil.variablesInScope(context, node).find((item) => item.name === name);
          if (!variable || !variable.defs[0] || !variable.defs[0].node) {
            return null;
          }
          if (variable.defs[0].node.type === "TypeAlias") {
            return variable.defs[0].node.right;
          }
          return variable.defs[0].node.init;
        }
        function checkSorted(declarations) {
          declarations.reduce((prev, curr, idx, decls) => {
            if (/Spread(?:Property|Element)$/.test(curr.type)) {
              return decls[idx + 1];
            }
            let prevPropName = getKey(prev);
            let currentPropName = getKey(curr);
            if (ignoreCase) {
              prevPropName = prevPropName.toLowerCase();
              currentPropName = currentPropName.toLowerCase();
            }
            if (currentPropName < prevPropName) {
              report(context, messages.propsNotSorted, "propsNotSorted", {
                node: curr
                // fix
              });
              return prev;
            }
            return curr;
          }, declarations[0]);
        }
        function checkNode(node) {
          if (!node) {
            return;
          }
          if (node.type === "ObjectExpression") {
            checkSorted(node.properties);
          } else if (node.type === "Identifier") {
            const propTypesObject = findVariableByName(node, node.name);
            if (propTypesObject && propTypesObject.properties) {
              checkSorted(propTypesObject.properties);
            }
          }
        }
        return {
          "ClassProperty, PropertyDefinition"(node) {
            if (!isDefaultPropsDeclaration(node)) {
              return;
            }
            checkNode(node.value);
          },
          MemberExpression(node) {
            if (!isDefaultPropsDeclaration(node)) {
              return;
            }
            checkNode(node.parent.right);
          },
          Program() {
            if (isWarnedForDeprecation) {
              return;
            }
            log("The react/jsx-sort-default-props rule is deprecated. It has been renamed to `react/sort-default-props`.");
            isWarnedForDeprecation = true;
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/ArrayCreate.js
var require_ArrayCreate2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/ArrayCreate.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $ArrayPrototype = GetIntrinsic("%Array.prototype%");
    var $RangeError = require_range();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var isInteger = require_isInteger();
    var MAX_ARRAY_LENGTH = Math.pow(2, 32) - 1;
    var hasProto = require_has_proto()();
    var $setProto = GetIntrinsic("%Object.setPrototypeOf%", true) || (hasProto ? function(O, proto) {
      O.__proto__ = proto;
      return O;
    } : null);
    module.exports = function ArrayCreate(length) {
      if (!isInteger(length) || length < 0) {
        throw new $TypeError("Assertion failed: `length` must be an integer Number >= 0");
      }
      if (length > MAX_ARRAY_LENGTH) {
        throw new $RangeError("length is greater than (2**32 - 1)");
      }
      var proto = arguments.length > 1 ? arguments[1] : $ArrayPrototype;
      var A = [];
      if (proto !== $ArrayPrototype) {
        if (!$setProto) {
          throw new $SyntaxError("ArrayCreate: a `proto` argument that is not `Array.prototype` is not supported in an environment that does not support setting the [[Prototype]]");
        }
        $setProto(A, proto);
      }
      if (length !== 0) {
        A.length = length;
      }
      return A;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/StringToBigInt.js
var require_StringToBigInt = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/StringToBigInt.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $BigInt = GetIntrinsic("%BigInt%", true);
    var $TypeError = require_type();
    var $SyntaxError = require_syntax();
    module.exports = function StringToBigInt(argument) {
      if (typeof argument !== "string") {
        throw new $TypeError("`argument` must be a string");
      }
      if (!$BigInt) {
        throw new $SyntaxError("BigInts are not supported in this environment");
      }
      try {
        return $BigInt(argument);
      } catch (e) {
        return void 0;
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/ToNumeric.js
var require_ToNumeric = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/ToNumeric.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $Number = GetIntrinsic("%Number%");
    var isPrimitive = require_isPrimitive();
    var ToPrimitive = require_ToPrimitive();
    var ToNumber = require_ToNumber2();
    module.exports = function ToNumeric(argument) {
      var primValue = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
      if (typeof primValue === "bigint") {
        return primValue;
      }
      return ToNumber(primValue);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/BigInt/lessThan.js
var require_lessThan = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/BigInt/lessThan.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    module.exports = function BigIntLessThan(x, y) {
      if (typeof x !== "bigint" || typeof y !== "bigint") {
        throw new $TypeError("Assertion failed: `x` and `y` arguments must be BigInts");
      }
      return x < y;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/Number/lessThan.js
var require_lessThan2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/Number/lessThan.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var isNaN2 = require_isNaN();
    module.exports = function NumberLessThan(x, y) {
      if (typeof x !== "number" || typeof y !== "number") {
        throw new $TypeError("Assertion failed: `x` and `y` arguments must be Numbers");
      }
      if (isNaN2(x) || isNaN2(y)) {
        return void 0;
      }
      return x < y;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IsLessThan.js
var require_IsLessThan = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/IsLessThan.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $Number = GetIntrinsic("%Number%");
    var $TypeError = require_type();
    var min = GetIntrinsic("%Math.min%");
    var $isNaN = require_isNaN();
    var $charCodeAt = require_callBound()("String.prototype.charCodeAt");
    var StringToBigInt = require_StringToBigInt();
    var ToNumeric = require_ToNumeric();
    var ToPrimitive = require_ToPrimitive();
    var BigIntLessThan = require_lessThan();
    var NumberLessThan = require_lessThan2();
    module.exports = function IsLessThan(x, y, LeftFirst) {
      if (typeof LeftFirst !== "boolean") {
        throw new $TypeError("Assertion failed: LeftFirst argument must be a Boolean");
      }
      var px;
      var py;
      if (LeftFirst) {
        px = ToPrimitive(x, $Number);
        py = ToPrimitive(y, $Number);
      } else {
        py = ToPrimitive(y, $Number);
        px = ToPrimitive(x, $Number);
      }
      if (typeof px === "string" && typeof py === "string") {
        var lx = px.length;
        var ly = py.length;
        for (var i = 0; i < min(lx, ly); i++) {
          var cx = $charCodeAt(px, i);
          var cy = $charCodeAt(py, i);
          if (cx < cy) {
            return true;
          }
          if (cx > cy) {
            return false;
          }
        }
        return lx < ly;
      }
      var nx;
      var ny;
      if (typeof px === "bigint" && typeof py === "string") {
        ny = StringToBigInt(py);
        if (typeof ny === "undefined") {
          return void 0;
        }
        return BigIntLessThan(px, ny);
      }
      if (typeof px === "string" && typeof py === "bigint") {
        nx = StringToBigInt(px);
        if (typeof nx === "undefined") {
          return void 0;
        }
        return BigIntLessThan(nx, py);
      }
      nx = ToNumeric(px);
      ny = ToNumeric(py);
      if (typeof nx === typeof ny) {
        return typeof nx === "number" ? NumberLessThan(nx, ny) : BigIntLessThan(nx, ny);
      }
      if ($isNaN(nx) || $isNaN(ny)) {
        return void 0;
      }
      if (nx === -Infinity || ny === Infinity) {
        return true;
      }
      if (nx === Infinity || ny === -Infinity) {
        return false;
      }
      return nx < ny;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/CompareArrayElements.js
var require_CompareArrayElements = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/CompareArrayElements.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var Call = require_Call();
    var IsLessThan = require_IsLessThan();
    var ToNumber = require_ToNumber2();
    var ToString = require_ToString();
    var isNaN2 = require_isNaN();
    module.exports = function CompareArrayElements(x, y, compareFn) {
      if (typeof compareFn !== "function" && typeof compareFn !== "undefined") {
        throw new $TypeError("Assertion failed: `compareFn` must be a function or undefined");
      }
      if (typeof x === "undefined" && typeof y === "undefined") {
        return 0;
      }
      if (typeof x === "undefined") {
        return 1;
      }
      if (typeof y === "undefined") {
        return -1;
      }
      if (typeof compareFn !== "undefined") {
        var v = ToNumber(Call(compareFn, void 0, [x, y]));
        if (isNaN2(v)) {
          return 0;
        }
        return v;
      }
      var xString = ToString(x);
      var yString = ToString(y);
      var xSmaller = IsLessThan(xString, yString, true);
      if (xSmaller) {
        return -1;
      }
      var ySmaller = IsLessThan(yString, xString, true);
      if (ySmaller) {
        return 1;
      }
      return 0;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/LengthOfArrayLike.js
var require_LengthOfArrayLike2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/LengthOfArrayLike.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var Get = require_Get();
    var ToLength = require_ToLength2();
    var Type = require_Type2();
    module.exports = function LengthOfArrayLike(obj) {
      if (Type(obj) !== "Object") {
        throw new $TypeError("Assertion failed: `obj` must be an Object");
      }
      return ToLength(Get(obj, "length"));
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/HasProperty.js
var require_HasProperty2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/HasProperty.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var IsPropertyKey = require_IsPropertyKey();
    var Type = require_Type2();
    module.exports = function HasProperty(O, P) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: `O` must be an Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: `P` must be a Property Key");
      }
      return P in O;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/isAbstractClosure.js
var require_isAbstractClosure = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/helpers/isAbstractClosure.js"(exports, module) {
    "use strict";
    var functionName = require_function_prototype();
    var anon = functionName(function() {
    });
    module.exports = function isAbstractClosure(x) {
      return typeof x === "function" && (!x.prototype || functionName(x) === anon);
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/SortIndexedProperties.js
var require_SortIndexedProperties = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/SortIndexedProperties.js"(exports, module) {
    "use strict";
    var callBound = require_callBound();
    var $TypeError = require_type();
    var Get = require_Get();
    var HasProperty = require_HasProperty2();
    var ToString = require_ToString();
    var Type = require_Type2();
    var isAbstractClosure = require_isAbstractClosure();
    var isInteger = require_isInteger();
    var $push = callBound("Array.prototype.push");
    var $sort = callBound("Array.prototype.sort");
    module.exports = function SortIndexedProperties(obj, len, SortCompare, holes) {
      if (Type(obj) !== "Object") {
        throw new $TypeError("Assertion failed: Type(obj) is not Object");
      }
      if (!isInteger(len) || len < 0) {
        throw new $TypeError("Assertion failed: `len` must be an integer >= 0");
      }
      if (!isAbstractClosure(SortCompare) || SortCompare.length !== 2) {
        throw new $TypeError("Assertion failed: `SortCompare` must be an abstract closure taking 2 arguments");
      }
      if (holes !== "skip-holes" && holes !== "read-through-holes") {
        throw new $TypeError("Assertion failed: `holes` must be either `skip-holes` or `read-through-holes`");
      }
      var items = [];
      var k = 0;
      while (k < len) {
        var Pk = ToString(k);
        var kRead = holes === "skip-holes" ? HasProperty(obj, Pk) : true;
        if (kRead) {
          var kValue = Get(obj, Pk);
          $push(items, kValue);
        }
        k += 1;
      }
      $sort(items, SortCompare);
      return items;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/ToObject.js
var require_ToObject3 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/es-abstract@1.23.3/node_modules/es-abstract/2024/ToObject.js"(exports, module) {
    "use strict";
    module.exports = require_ToObject();
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.tosorted@1.1.4/node_modules/array.prototype.tosorted/implementation.js
var require_implementation25 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.tosorted@1.1.4/node_modules/array.prototype.tosorted/implementation.js"(exports, module) {
    "use strict";
    var ArrayCreate = require_ArrayCreate2();
    var CompareArrayElements = require_CompareArrayElements();
    var CreateDataPropertyOrThrow = require_CreateDataPropertyOrThrow();
    var IsCallable = require_IsCallable();
    var LengthOfArrayLike = require_LengthOfArrayLike2();
    var SortIndexedProperties = require_SortIndexedProperties();
    var ToObject = require_ToObject3();
    var ToString = require_ToString();
    var $TypeError = require_type();
    module.exports = function toSorted(comparefn) {
      if (typeof comparefn !== "undefined" && !IsCallable(comparefn)) {
        throw new $TypeError("`comparefn` must be a function");
      }
      var O = ToObject(this);
      var len = LengthOfArrayLike(O);
      var A = ArrayCreate(len);
      var SortCompare = (0, function(x, y) {
        return CompareArrayElements(x, y, comparefn);
      });
      var sortedList = SortIndexedProperties(O, len, SortCompare, "read-through-holes");
      var j = 0;
      while (j < len) {
        CreateDataPropertyOrThrow(A, ToString(j), sortedList[j]);
        j += 1;
      }
      return A;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.tosorted@1.1.4/node_modules/array.prototype.tosorted/polyfill.js
var require_polyfill23 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.tosorted@1.1.4/node_modules/array.prototype.tosorted/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation25();
    module.exports = function getPolyfill() {
      return Array.prototype.toSorted || implementation;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.tosorted@1.1.4/node_modules/array.prototype.tosorted/shim.js
var require_shim22 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.tosorted@1.1.4/node_modules/array.prototype.tosorted/shim.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var shimUnscopables = require_es_shim_unscopables();
    var getPolyfill = require_polyfill23();
    module.exports = function shim() {
      var polyfill = getPolyfill();
      define(
        Array.prototype,
        { toSorted: polyfill },
        { toSorted: function() {
          return Array.prototype.toSorted !== polyfill;
        } }
      );
      shimUnscopables("toSorted");
      return polyfill;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.tosorted@1.1.4/node_modules/array.prototype.tosorted/index.js
var require_array_prototype4 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.tosorted@1.1.4/node_modules/array.prototype.tosorted/index.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation25();
    var getPolyfill = require_polyfill23();
    var polyfill = getPolyfill();
    var shim = require_shim22();
    var bound = callBind(polyfill);
    define(bound, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = bound;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-sort-props.js
var require_jsx_sort_props = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-sort-props.js"(exports, module) {
    "use strict";
    var propName = require_propName2();
    var includes = require_array_includes();
    var toSorted = require_array_prototype4();
    var docsUrl = require_docsUrl();
    var jsxUtil = require_jsx();
    var report = require_report();
    var eslintUtil = require_eslint();
    var getText = eslintUtil.getText;
    var getSourceCode = eslintUtil.getSourceCode;
    function isCallbackPropName(name) {
      return /^on[A-Z]/.test(name);
    }
    function isMultilineProp(node) {
      return node.loc.start.line !== node.loc.end.line;
    }
    var messages = {
      noUnreservedProps: "A customized reserved first list must only contain a subset of React reserved props. Remove: {{unreservedWords}}",
      listIsEmpty: "A customized reserved first list must not be empty",
      listReservedPropsFirst: "Reserved props must be listed before all other props",
      listCallbacksLast: "Callbacks must be listed after all other props",
      listShorthandFirst: "Shorthand props must be listed before all other props",
      listShorthandLast: "Shorthand props must be listed after all other props",
      listMultilineFirst: "Multiline props must be listed before all other props",
      listMultilineLast: "Multiline props must be listed after all other props",
      sortPropsByAlpha: "Props should be sorted alphabetically"
    };
    var RESERVED_PROPS_LIST = [
      "children",
      "dangerouslySetInnerHTML",
      "key",
      "ref"
    ];
    function isReservedPropName(name, list) {
      return list.indexOf(name) >= 0;
    }
    var attributeMap;
    function shouldSortToEnd(node) {
      const attr = attributeMap.get(node);
      return !!attr && !!attr.hasComment;
    }
    function contextCompare(a, b, options) {
      let aProp = propName(a);
      let bProp = propName(b);
      const aSortToEnd = shouldSortToEnd(a);
      const bSortToEnd = shouldSortToEnd(b);
      if (aSortToEnd && !bSortToEnd) {
        return 1;
      }
      if (!aSortToEnd && bSortToEnd) {
        return -1;
      }
      if (options.reservedFirst) {
        const aIsReserved = isReservedPropName(aProp, options.reservedList);
        const bIsReserved = isReservedPropName(bProp, options.reservedList);
        if (aIsReserved && !bIsReserved) {
          return -1;
        }
        if (!aIsReserved && bIsReserved) {
          return 1;
        }
      }
      if (options.callbacksLast) {
        const aIsCallback = isCallbackPropName(aProp);
        const bIsCallback = isCallbackPropName(bProp);
        if (aIsCallback && !bIsCallback) {
          return 1;
        }
        if (!aIsCallback && bIsCallback) {
          return -1;
        }
      }
      if (options.shorthandFirst || options.shorthandLast) {
        const shorthandSign = options.shorthandFirst ? -1 : 1;
        if (!a.value && b.value) {
          return shorthandSign;
        }
        if (a.value && !b.value) {
          return -shorthandSign;
        }
      }
      if (options.multiline !== "ignore") {
        const multilineSign = options.multiline === "first" ? -1 : 1;
        const aIsMultiline = isMultilineProp(a);
        const bIsMultiline = isMultilineProp(b);
        if (aIsMultiline && !bIsMultiline) {
          return multilineSign;
        }
        if (!aIsMultiline && bIsMultiline) {
          return -multilineSign;
        }
      }
      if (options.noSortAlphabetically) {
        return 0;
      }
      const actualLocale = options.locale === "auto" ? void 0 : options.locale;
      if (options.ignoreCase) {
        aProp = aProp.toLowerCase();
        bProp = bProp.toLowerCase();
        return aProp.localeCompare(bProp, actualLocale);
      }
      if (aProp === bProp) {
        return 0;
      }
      if (options.locale === "auto") {
        return aProp < bProp ? -1 : 1;
      }
      return aProp.localeCompare(bProp, actualLocale);
    }
    function getGroupsOfSortableAttributes(attributes, context) {
      const sourceCode = getSourceCode(context);
      const sortableAttributeGroups = [];
      let groupCount = 0;
      function addtoSortableAttributeGroups(attribute) {
        sortableAttributeGroups[groupCount - 1].push(attribute);
      }
      for (let i = 0; i < attributes.length; i++) {
        const attribute = attributes[i];
        const nextAttribute = attributes[i + 1];
        const attributeline = attribute.loc.start.line;
        let comment = [];
        try {
          comment = sourceCode.getCommentsAfter(attribute);
        } catch (e) {
        }
        const lastAttr = attributes[i - 1];
        const attrIsSpread = attribute.type === "JSXSpreadAttribute";
        if (!lastAttr || lastAttr.type === "JSXSpreadAttribute" && !attrIsSpread) {
          groupCount += 1;
          sortableAttributeGroups[groupCount - 1] = [];
        }
        if (!attrIsSpread) {
          if (comment.length === 0) {
            attributeMap.set(attribute, { end: attribute.range[1], hasComment: false });
            addtoSortableAttributeGroups(attribute);
          } else {
            const firstComment = comment[0];
            const commentline = firstComment.loc.start.line;
            if (comment.length === 1) {
              if (attributeline + 1 === commentline && nextAttribute) {
                attributeMap.set(attribute, { end: nextAttribute.range[1], hasComment: true });
                addtoSortableAttributeGroups(attribute);
                i += 1;
              } else if (attributeline === commentline) {
                if (firstComment.type === "Block" && nextAttribute) {
                  attributeMap.set(attribute, { end: nextAttribute.range[1], hasComment: true });
                  i += 1;
                } else if (firstComment.type === "Block") {
                  attributeMap.set(attribute, { end: firstComment.range[1], hasComment: true });
                } else {
                  attributeMap.set(attribute, { end: firstComment.range[1], hasComment: false });
                }
                addtoSortableAttributeGroups(attribute);
              }
            } else if (comment.length > 1 && attributeline + 1 === comment[1].loc.start.line && nextAttribute) {
              const commentNextAttribute = sourceCode.getCommentsAfter(nextAttribute);
              attributeMap.set(attribute, { end: nextAttribute.range[1], hasComment: true });
              if (commentNextAttribute.length === 1 && nextAttribute.loc.start.line === commentNextAttribute[0].loc.start.line) {
                attributeMap.set(attribute, { end: commentNextAttribute[0].range[1], hasComment: true });
              }
              addtoSortableAttributeGroups(attribute);
              i += 1;
            }
          }
        }
      }
      return sortableAttributeGroups;
    }
    function generateFixerFunction(node, context, reservedList) {
      const attributes = node.attributes.slice(0);
      const configuration = context.options[0] || {};
      const ignoreCase = configuration.ignoreCase || false;
      const callbacksLast = configuration.callbacksLast || false;
      const shorthandFirst = configuration.shorthandFirst || false;
      const shorthandLast = configuration.shorthandLast || false;
      const multiline = configuration.multiline || "ignore";
      const noSortAlphabetically = configuration.noSortAlphabetically || false;
      const reservedFirst = configuration.reservedFirst || false;
      const locale = configuration.locale || "auto";
      const options = {
        ignoreCase,
        callbacksLast,
        shorthandFirst,
        shorthandLast,
        multiline,
        noSortAlphabetically,
        reservedFirst,
        reservedList,
        locale
      };
      const sortableAttributeGroups = getGroupsOfSortableAttributes(attributes, context);
      const sortedAttributeGroups = sortableAttributeGroups.slice(0).map((group) => toSorted(group, (a, b) => contextCompare(a, b, options)));
      return function fixFunction(fixer) {
        const fixers = [];
        let source = getText(context);
        sortableAttributeGroups.forEach((sortableGroup, ii) => {
          sortableGroup.forEach((attr, jj) => {
            const sortedAttr = sortedAttributeGroups[ii][jj];
            const sortedAttrText = source.slice(sortedAttr.range[0], attributeMap.get(sortedAttr).end);
            fixers.push({
              range: [attr.range[0], attributeMap.get(attr).end],
              text: sortedAttrText
            });
          });
        });
        fixers.sort((a, b) => b.range[0] - a.range[0]);
        const firstFixer = fixers[0];
        const lastFixer = fixers[fixers.length - 1];
        const rangeStart = lastFixer ? lastFixer.range[0] : 0;
        const rangeEnd = firstFixer ? firstFixer.range[1] : -0;
        fixers.forEach((fix) => {
          source = `${source.slice(0, fix.range[0])}${fix.text}${source.slice(fix.range[1])}`;
        });
        return fixer.replaceTextRange([rangeStart, rangeEnd], source.slice(rangeStart, rangeEnd));
      };
    }
    function validateReservedFirstConfig(context, reservedFirst) {
      if (reservedFirst) {
        if (Array.isArray(reservedFirst)) {
          const nonReservedWords = reservedFirst.filter((word) => !isReservedPropName(
            word,
            RESERVED_PROPS_LIST
          ));
          if (reservedFirst.length === 0) {
            return function Report(decl) {
              report(context, messages.listIsEmpty, "listIsEmpty", {
                node: decl
              });
            };
          }
          if (nonReservedWords.length > 0) {
            return function Report(decl) {
              report(context, messages.noUnreservedProps, "noUnreservedProps", {
                node: decl,
                data: {
                  unreservedWords: nonReservedWords.toString()
                }
              });
            };
          }
        }
      }
    }
    var reportedNodeAttributes = /* @__PURE__ */ new WeakMap();
    function reportNodeAttribute(nodeAttribute, errorType, node, context, reservedList) {
      const errors = reportedNodeAttributes.get(nodeAttribute) || [];
      if (includes(errors, errorType)) {
        return;
      }
      errors.push(errorType);
      reportedNodeAttributes.set(nodeAttribute, errors);
      report(context, messages[errorType], errorType, {
        node: nodeAttribute.name,
        fix: generateFixerFunction(node, context, reservedList)
      });
    }
    module.exports = {
      meta: {
        docs: {
          description: "Enforce props alphabetical sorting",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("jsx-sort-props")
        },
        fixable: "code",
        messages,
        schema: [{
          type: "object",
          properties: {
            // Whether callbacks (prefixed with "on") should be listed at the very end,
            // after all other props. Supersedes shorthandLast.
            callbacksLast: {
              type: "boolean"
            },
            // Whether shorthand properties (without a value) should be listed first
            shorthandFirst: {
              type: "boolean"
            },
            // Whether shorthand properties (without a value) should be listed last
            shorthandLast: {
              type: "boolean"
            },
            // Whether multiline properties should be listed first or last
            multiline: {
              enum: ["ignore", "first", "last"],
              default: "ignore"
            },
            ignoreCase: {
              type: "boolean"
            },
            // Whether alphabetical sorting should be enforced
            noSortAlphabetically: {
              type: "boolean"
            },
            reservedFirst: {
              type: ["array", "boolean"]
            },
            locale: {
              type: "string",
              default: "auto"
            }
          },
          additionalProperties: false
        }]
      },
      create(context) {
        const configuration = context.options[0] || {};
        const ignoreCase = configuration.ignoreCase || false;
        const callbacksLast = configuration.callbacksLast || false;
        const shorthandFirst = configuration.shorthandFirst || false;
        const shorthandLast = configuration.shorthandLast || false;
        const multiline = configuration.multiline || "ignore";
        const noSortAlphabetically = configuration.noSortAlphabetically || false;
        const reservedFirst = configuration.reservedFirst || false;
        const reservedFirstError = validateReservedFirstConfig(context, reservedFirst);
        const reservedList = Array.isArray(reservedFirst) ? reservedFirst : RESERVED_PROPS_LIST;
        const locale = configuration.locale || "auto";
        return {
          Program() {
            attributeMap = /* @__PURE__ */ new WeakMap();
          },
          JSXOpeningElement(node) {
            const nodeReservedList = reservedFirst && !jsxUtil.isDOMComponent(node) ? reservedList.filter((prop) => prop !== "dangerouslySetInnerHTML") : reservedList;
            node.attributes.reduce((memo, decl, idx, attrs) => {
              if (decl.type === "JSXSpreadAttribute") {
                return attrs[idx + 1];
              }
              let previousPropName = propName(memo);
              let currentPropName = propName(decl);
              const previousValue = memo.value;
              const currentValue = decl.value;
              const previousIsCallback = isCallbackPropName(previousPropName);
              const currentIsCallback = isCallbackPropName(currentPropName);
              if (ignoreCase) {
                previousPropName = previousPropName.toLowerCase();
                currentPropName = currentPropName.toLowerCase();
              }
              if (reservedFirst) {
                if (reservedFirstError) {
                  reservedFirstError(decl);
                  return memo;
                }
                const previousIsReserved = isReservedPropName(previousPropName, nodeReservedList);
                const currentIsReserved = isReservedPropName(currentPropName, nodeReservedList);
                if (previousIsReserved && !currentIsReserved) {
                  return decl;
                }
                if (!previousIsReserved && currentIsReserved) {
                  reportNodeAttribute(decl, "listReservedPropsFirst", node, context, nodeReservedList);
                  return memo;
                }
              }
              if (callbacksLast) {
                if (!previousIsCallback && currentIsCallback) {
                  return decl;
                }
                if (previousIsCallback && !currentIsCallback) {
                  reportNodeAttribute(memo, "listCallbacksLast", node, context, nodeReservedList);
                  return memo;
                }
              }
              if (shorthandFirst) {
                if (currentValue && !previousValue) {
                  return decl;
                }
                if (!currentValue && previousValue) {
                  reportNodeAttribute(decl, "listShorthandFirst", node, context, nodeReservedList);
                  return memo;
                }
              }
              if (shorthandLast) {
                if (!currentValue && previousValue) {
                  return decl;
                }
                if (currentValue && !previousValue) {
                  reportNodeAttribute(memo, "listShorthandLast", node, context, nodeReservedList);
                  return memo;
                }
              }
              const previousIsMultiline = isMultilineProp(memo);
              const currentIsMultiline = isMultilineProp(decl);
              if (multiline === "first") {
                if (previousIsMultiline && !currentIsMultiline) {
                  return decl;
                }
                if (!previousIsMultiline && currentIsMultiline) {
                  reportNodeAttribute(decl, "listMultilineFirst", node, context, nodeReservedList);
                  return memo;
                }
              } else if (multiline === "last") {
                if (!previousIsMultiline && currentIsMultiline) {
                  return decl;
                }
                if (previousIsMultiline && !currentIsMultiline) {
                  reportNodeAttribute(memo, "listMultilineLast", node, context, nodeReservedList);
                  return memo;
                }
              }
              if (!noSortAlphabetically && (ignoreCase || locale !== "auto" ? previousPropName.localeCompare(currentPropName, locale === "auto" ? void 0 : locale) > 0 : previousPropName > currentPropName)) {
                reportNodeAttribute(decl, "sortPropsByAlpha", node, context, nodeReservedList);
                return memo;
              }
              return decl;
            }, node.attributes[0]);
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/getTokenBeforeClosingBracket.js
var require_getTokenBeforeClosingBracket = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/getTokenBeforeClosingBracket.js"(exports, module) {
    "use strict";
    function getTokenBeforeClosingBracket(node) {
      const attributes = node.attributes;
      if (!attributes || attributes.length === 0) {
        return node.name;
      }
      return attributes[attributes.length - 1];
    }
    module.exports = getTokenBeforeClosingBracket;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-space-before-closing.js
var require_jsx_space_before_closing = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-space-before-closing.js"(exports, module) {
    "use strict";
    var getTokenBeforeClosingBracket = require_getTokenBeforeClosingBracket();
    var docsUrl = require_docsUrl();
    var log = require_log();
    var report = require_report();
    var getSourceCode = require_eslint().getSourceCode;
    var isWarnedForDeprecation = false;
    var messages = {
      noSpaceBeforeClose: "A space is forbidden before closing bracket",
      needSpaceBeforeClose: "A space is required before closing bracket"
    };
    module.exports = {
      meta: {
        deprecated: true,
        replacedBy: ["jsx-tag-spacing"],
        docs: {
          description: "Enforce spacing before closing bracket in JSX",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("jsx-space-before-closing")
        },
        fixable: "code",
        messages,
        schema: [{
          enum: ["always", "never"]
        }]
      },
      create(context) {
        const configuration = context.options[0] || "always";
        return {
          JSXOpeningElement(node) {
            if (!node.selfClosing) {
              return;
            }
            const sourceCode = getSourceCode(context);
            const leftToken = getTokenBeforeClosingBracket(node);
            const closingSlash = sourceCode.getTokenAfter(leftToken);
            if (leftToken.loc.end.line !== closingSlash.loc.start.line) {
              return;
            }
            if (configuration === "always" && !sourceCode.isSpaceBetweenTokens(leftToken, closingSlash)) {
              report(context, messages.needSpaceBeforeClose, "needSpaceBeforeClose", {
                loc: closingSlash.loc.start,
                fix(fixer) {
                  return fixer.insertTextBefore(closingSlash, " ");
                }
              });
            } else if (configuration === "never" && sourceCode.isSpaceBetweenTokens(leftToken, closingSlash)) {
              report(context, messages.noSpaceBeforeClose, "noSpaceBeforeClose", {
                loc: closingSlash.loc.start,
                fix(fixer) {
                  const previousToken = sourceCode.getTokenBefore(closingSlash);
                  return fixer.removeRange([previousToken.range[1], closingSlash.range[0]]);
                }
              });
            }
          },
          Program() {
            if (isWarnedForDeprecation) {
              return;
            }
            log('The react/jsx-space-before-closing rule is deprecated. Please use the react/jsx-tag-spacing rule with the "beforeSelfClosing" option instead.');
            isWarnedForDeprecation = true;
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-tag-spacing.js
var require_jsx_tag_spacing = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-tag-spacing.js"(exports, module) {
    "use strict";
    var getTokenBeforeClosingBracket = require_getTokenBeforeClosingBracket();
    var docsUrl = require_docsUrl();
    var report = require_report();
    var eslintUtil = require_eslint();
    var getFirstTokens = eslintUtil.getFirstTokens;
    var getSourceCode = eslintUtil.getSourceCode;
    var messages = {
      selfCloseSlashNoSpace: "Whitespace is forbidden between `/` and `>`; write `/>`",
      selfCloseSlashNeedSpace: "Whitespace is required between `/` and `>`; write `/ >`",
      closeSlashNoSpace: "Whitespace is forbidden between `<` and `/`; write `</`",
      closeSlashNeedSpace: "Whitespace is required between `<` and `/`; write `< /`",
      beforeSelfCloseNoSpace: "A space is forbidden before closing bracket",
      beforeSelfCloseNeedSpace: "A space is required before closing bracket",
      beforeSelfCloseNeedNewline: "A newline is required before closing bracket",
      afterOpenNoSpace: "A space is forbidden after opening bracket",
      afterOpenNeedSpace: "A space is required after opening bracket",
      beforeCloseNoSpace: "A space is forbidden before closing bracket",
      beforeCloseNeedSpace: "Whitespace is required before closing bracket",
      beforeCloseNeedNewline: "A newline is required before closing bracket"
    };
    function validateClosingSlash(context, node, option) {
      const sourceCode = getSourceCode(context);
      let adjacent;
      if (node.selfClosing) {
        const lastTokens = sourceCode.getLastTokens(node, 2);
        adjacent = !sourceCode.isSpaceBetweenTokens(lastTokens[0], lastTokens[1]);
        if (option === "never") {
          if (!adjacent) {
            report(context, messages.selfCloseSlashNoSpace, "selfCloseSlashNoSpace", {
              node,
              loc: {
                start: lastTokens[0].loc.start,
                end: lastTokens[1].loc.end
              },
              fix(fixer) {
                return fixer.removeRange([lastTokens[0].range[1], lastTokens[1].range[0]]);
              }
            });
          }
        } else if (option === "always" && adjacent) {
          report(context, messages.selfCloseSlashNeedSpace, "selfCloseSlashNeedSpace", {
            node,
            loc: {
              start: lastTokens[0].loc.start,
              end: lastTokens[1].loc.end
            },
            fix(fixer) {
              return fixer.insertTextBefore(lastTokens[1], " ");
            }
          });
        }
      } else {
        const firstTokens = getFirstTokens(context, node, 2);
        adjacent = !sourceCode.isSpaceBetweenTokens(firstTokens[0], firstTokens[1]);
        if (option === "never") {
          if (!adjacent) {
            report(context, messages.closeSlashNoSpace, "closeSlashNoSpace", {
              node,
              loc: {
                start: firstTokens[0].loc.start,
                end: firstTokens[1].loc.end
              },
              fix(fixer) {
                return fixer.removeRange([firstTokens[0].range[1], firstTokens[1].range[0]]);
              }
            });
          }
        } else if (option === "always" && adjacent) {
          report(context, messages.closeSlashNeedSpace, "closeSlashNeedSpace", {
            node,
            loc: {
              start: firstTokens[0].loc.start,
              end: firstTokens[1].loc.end
            },
            fix(fixer) {
              return fixer.insertTextBefore(firstTokens[1], " ");
            }
          });
        }
      }
    }
    function validateBeforeSelfClosing(context, node, option) {
      const sourceCode = getSourceCode(context);
      const leftToken = getTokenBeforeClosingBracket(node);
      const closingSlash = sourceCode.getTokenAfter(leftToken);
      if (node.loc.start.line !== node.loc.end.line && option === "proportional-always") {
        if (leftToken.loc.end.line === closingSlash.loc.start.line) {
          report(context, messages.beforeSelfCloseNeedNewline, "beforeSelfCloseNeedNewline", {
            node,
            loc: leftToken.loc.end,
            fix(fixer) {
              return fixer.insertTextBefore(closingSlash, "\n");
            }
          });
          return;
        }
      }
      if (leftToken.loc.end.line !== closingSlash.loc.start.line) {
        return;
      }
      const adjacent = !sourceCode.isSpaceBetweenTokens(leftToken, closingSlash);
      if ((option === "always" || option === "proportional-always") && adjacent) {
        report(context, messages.beforeSelfCloseNeedSpace, "beforeSelfCloseNeedSpace", {
          node,
          loc: closingSlash.loc.start,
          fix(fixer) {
            return fixer.insertTextBefore(closingSlash, " ");
          }
        });
      } else if (option === "never" && !adjacent) {
        report(context, messages.beforeSelfCloseNoSpace, "beforeSelfCloseNoSpace", {
          node,
          loc: closingSlash.loc.start,
          fix(fixer) {
            const previousToken = sourceCode.getTokenBefore(closingSlash);
            return fixer.removeRange([previousToken.range[1], closingSlash.range[0]]);
          }
        });
      }
    }
    function validateAfterOpening(context, node, option) {
      const sourceCode = getSourceCode(context);
      const openingToken = sourceCode.getTokenBefore(node.name);
      if (option === "allow-multiline") {
        if (openingToken.loc.start.line !== node.name.loc.start.line) {
          return;
        }
      }
      const adjacent = !sourceCode.isSpaceBetweenTokens(openingToken, node.name);
      if (option === "never" || option === "allow-multiline") {
        if (!adjacent) {
          report(context, messages.afterOpenNoSpace, "afterOpenNoSpace", {
            node,
            loc: {
              start: openingToken.loc.start,
              end: node.name.loc.start
            },
            fix(fixer) {
              return fixer.removeRange([openingToken.range[1], node.name.range[0]]);
            }
          });
        }
      } else if (option === "always" && adjacent) {
        report(context, messages.afterOpenNeedSpace, "afterOpenNeedSpace", {
          node,
          loc: {
            start: openingToken.loc.start,
            end: node.name.loc.start
          },
          fix(fixer) {
            return fixer.insertTextBefore(node.name, " ");
          }
        });
      }
    }
    function validateBeforeClosing(context, node, option) {
      if (!node.selfClosing) {
        const sourceCode = getSourceCode(context);
        const leftToken = option === "proportional-always" ? getTokenBeforeClosingBracket(node) : sourceCode.getLastTokens(node, 2)[0];
        const closingToken = sourceCode.getTokenAfter(leftToken);
        if (node.loc.start.line !== node.loc.end.line && option === "proportional-always") {
          if (leftToken.loc.end.line === closingToken.loc.start.line) {
            report(context, messages.beforeCloseNeedNewline, "beforeCloseNeedNewline", {
              node,
              loc: leftToken.loc.end,
              fix(fixer) {
                return fixer.insertTextBefore(closingToken, "\n");
              }
            });
            return;
          }
        }
        if (leftToken.loc.start.line !== closingToken.loc.start.line) {
          return;
        }
        const adjacent = !sourceCode.isSpaceBetweenTokens(leftToken, closingToken);
        if (option === "never" && !adjacent) {
          report(context, messages.beforeCloseNoSpace, "beforeCloseNoSpace", {
            node,
            loc: {
              start: leftToken.loc.end,
              end: closingToken.loc.start
            },
            fix(fixer) {
              return fixer.removeRange([leftToken.range[1], closingToken.range[0]]);
            }
          });
        } else if (option === "always" && adjacent) {
          report(context, messages.beforeCloseNeedSpace, "beforeCloseNeedSpace", {
            node,
            loc: {
              start: leftToken.loc.end,
              end: closingToken.loc.start
            },
            fix(fixer) {
              return fixer.insertTextBefore(closingToken, " ");
            }
          });
        } else if (option === "proportional-always" && node.type === "JSXOpeningElement" && adjacent !== (node.loc.start.line === node.loc.end.line)) {
          report(context, messages.beforeCloseNeedSpace, "beforeCloseNeedSpace", {
            node,
            loc: {
              start: leftToken.loc.end,
              end: closingToken.loc.start
            },
            fix(fixer) {
              return fixer.insertTextBefore(closingToken, " ");
            }
          });
        }
      }
    }
    var optionDefaults = {
      closingSlash: "never",
      beforeSelfClosing: "always",
      afterOpening: "never",
      beforeClosing: "allow"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce whitespace in and around the JSX opening and closing brackets",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("jsx-tag-spacing")
        },
        fixable: "whitespace",
        messages,
        schema: [
          {
            type: "object",
            properties: {
              closingSlash: {
                enum: ["always", "never", "allow"]
              },
              beforeSelfClosing: {
                enum: ["always", "proportional-always", "never", "allow"]
              },
              afterOpening: {
                enum: ["always", "allow-multiline", "never", "allow"]
              },
              beforeClosing: {
                enum: ["always", "proportional-always", "never", "allow"]
              }
            },
            default: optionDefaults,
            additionalProperties: false
          }
        ]
      },
      create(context) {
        const options = Object.assign({}, optionDefaults, context.options[0]);
        return {
          JSXOpeningElement(node) {
            if (options.closingSlash !== "allow" && node.selfClosing) {
              validateClosingSlash(context, node, options.closingSlash);
            }
            if (options.afterOpening !== "allow") {
              validateAfterOpening(context, node, options.afterOpening);
            }
            if (options.beforeSelfClosing !== "allow" && node.selfClosing) {
              validateBeforeSelfClosing(context, node, options.beforeSelfClosing);
            }
            if (options.beforeClosing !== "allow") {
              validateBeforeClosing(context, node, options.beforeClosing);
            }
          },
          JSXClosingElement(node) {
            if (options.afterOpening !== "allow") {
              validateAfterOpening(context, node, options.afterOpening);
            }
            if (options.closingSlash !== "allow") {
              validateClosingSlash(context, node, options.closingSlash);
            }
            if (options.beforeClosing !== "allow") {
              validateBeforeClosing(context, node, options.beforeClosing);
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-uses-react.js
var require_jsx_uses_react = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-uses-react.js"(exports, module) {
    "use strict";
    var pragmaUtil = require_pragma();
    var docsUrl = require_docsUrl();
    var markVariableAsUsed = require_eslint().markVariableAsUsed;
    module.exports = {
      // eslint-disable-next-line eslint-plugin/prefer-message-ids -- https://github.com/not-an-aardvark/eslint-plugin-eslint-plugin/issues/292
      meta: {
        docs: {
          description: "Disallow React to be incorrectly marked as unused",
          category: "Best Practices",
          recommended: true,
          url: docsUrl("jsx-uses-react")
        },
        schema: []
      },
      create(context) {
        const pragma = pragmaUtil.getFromContext(context);
        const fragment = pragmaUtil.getFragmentFromContext(context);
        function handleOpeningElement(node) {
          markVariableAsUsed(pragma, node, context);
        }
        return {
          JSXOpeningElement: handleOpeningElement,
          JSXOpeningFragment: handleOpeningElement,
          JSXFragment(node) {
            markVariableAsUsed(fragment, node, context);
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-uses-vars.js
var require_jsx_uses_vars = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-uses-vars.js"(exports, module) {
    "use strict";
    var docsUrl = require_docsUrl();
    var markVariableAsUsed = require_eslint().markVariableAsUsed;
    var isTagNameRe = /^[a-z]/;
    var isTagName = (name) => isTagNameRe.test(name);
    module.exports = {
      // eslint-disable-next-line eslint-plugin/prefer-message-ids -- https://github.com/not-an-aardvark/eslint-plugin-eslint-plugin/issues/292
      meta: {
        docs: {
          description: "Disallow variables used in JSX to be incorrectly marked as unused",
          category: "Best Practices",
          recommended: true,
          url: docsUrl("jsx-uses-vars")
        },
        schema: []
      },
      create(context) {
        return {
          JSXOpeningElement(node) {
            let name;
            if (node.name.namespace) {
              return;
            }
            if (node.name.name) {
              name = node.name.name;
              if (isTagName(name)) {
                return;
              }
            } else if (node.name.object) {
              let parent = node.name.object;
              while (parent.object) {
                parent = parent.object;
              }
              name = parent.name;
            } else {
              return;
            }
            markVariableAsUsed(name, node, context);
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-wrap-multilines.js
var require_jsx_wrap_multilines = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/jsx-wrap-multilines.js"(exports, module) {
    "use strict";
    var has = require_polyfill19()();
    var docsUrl = require_docsUrl();
    var eslintUtil = require_eslint();
    var jsxUtil = require_jsx();
    var reportC = require_report();
    var isParenthesized = require_ast().isParenthesized;
    var getSourceCode = eslintUtil.getSourceCode;
    var getText = eslintUtil.getText;
    var DEFAULTS = {
      declaration: "parens",
      assignment: "parens",
      return: "parens",
      arrow: "parens",
      condition: "ignore",
      logical: "ignore",
      prop: "ignore"
    };
    var messages = {
      missingParens: "Missing parentheses around multilines JSX",
      extraParens: "Expected no parentheses around multilines JSX",
      parensOnNewLines: "Parentheses around JSX should be on separate lines"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow missing parentheses around multiline JSX",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("jsx-wrap-multilines")
        },
        fixable: "code",
        messages,
        schema: [{
          type: "object",
          // true/false are for backwards compatibility
          properties: {
            declaration: {
              enum: [true, false, "ignore", "parens", "parens-new-line", "never"]
            },
            assignment: {
              enum: [true, false, "ignore", "parens", "parens-new-line", "never"]
            },
            return: {
              enum: [true, false, "ignore", "parens", "parens-new-line", "never"]
            },
            arrow: {
              enum: [true, false, "ignore", "parens", "parens-new-line", "never"]
            },
            condition: {
              enum: [true, false, "ignore", "parens", "parens-new-line", "never"]
            },
            logical: {
              enum: [true, false, "ignore", "parens", "parens-new-line", "never"]
            },
            prop: {
              enum: [true, false, "ignore", "parens", "parens-new-line", "never"]
            }
          },
          additionalProperties: false
        }]
      },
      create(context) {
        function getOption(type) {
          const userOptions = context.options[0] || {};
          if (has(userOptions, type)) {
            return userOptions[type];
          }
          return DEFAULTS[type];
        }
        function isEnabled(type) {
          const option = getOption(type);
          return option && option !== "ignore";
        }
        function needsOpeningNewLine(node) {
          const previousToken = getSourceCode(context).getTokenBefore(node);
          if (!isParenthesized(context, node)) {
            return false;
          }
          if (previousToken.loc.end.line === node.loc.start.line) {
            return true;
          }
          return false;
        }
        function needsClosingNewLine(node) {
          const nextToken = getSourceCode(context).getTokenAfter(node);
          if (!isParenthesized(context, node)) {
            return false;
          }
          if (node.loc.end.line === nextToken.loc.end.line) {
            return true;
          }
          return false;
        }
        function isMultilines(node) {
          return node.loc.start.line !== node.loc.end.line;
        }
        function report(node, messageId, fix) {
          reportC(context, messages[messageId], messageId, {
            node,
            fix
          });
        }
        function trimTokenBeforeNewline(node, tokenBefore) {
          const isBracket = tokenBefore.value === "{" || tokenBefore.value === "[";
          return `${tokenBefore.value.trim()}${isBracket ? "" : " "}`;
        }
        function check(node, type) {
          if (!node || !jsxUtil.isJSX(node)) {
            return;
          }
          const sourceCode = getSourceCode(context);
          const option = getOption(type);
          if ((option === true || option === "parens") && !isParenthesized(context, node) && isMultilines(node)) {
            report(node, "missingParens", (fixer) => fixer.replaceText(node, `(${getText(context, node)})`));
          }
          if (option === "parens-new-line" && isMultilines(node)) {
            if (!isParenthesized(context, node)) {
              const tokenBefore = sourceCode.getTokenBefore(node, { includeComments: true });
              const tokenAfter = sourceCode.getTokenAfter(node, { includeComments: true });
              const start = node.loc.start;
              if (tokenBefore.loc.end.line < start.line) {
                report(
                  node,
                  "missingParens",
                  (fixer) => fixer.replaceTextRange(
                    [tokenBefore.range[0], tokenAfter && (tokenAfter.value === ";" || tokenAfter.value === "}") ? tokenAfter.range[0] : node.range[1]],
                    `${trimTokenBeforeNewline(node, tokenBefore)}(
${start.column > 0 ? " ".repeat(start.column) : ""}${getText(context, node)}
${start.column > 0 ? " ".repeat(start.column - 2) : ""})`
                  )
                );
              } else {
                report(node, "missingParens", (fixer) => fixer.replaceText(node, `(
${getText(context, node)}
)`));
              }
            } else {
              const needsOpening = needsOpeningNewLine(node);
              const needsClosing = needsClosingNewLine(node);
              if (needsOpening || needsClosing) {
                report(node, "parensOnNewLines", (fixer) => {
                  const text = getText(context, node);
                  let fixed = text;
                  if (needsOpening) {
                    fixed = `
${fixed}`;
                  }
                  if (needsClosing) {
                    fixed = `${fixed}
`;
                  }
                  return fixer.replaceText(node, fixed);
                });
              }
            }
          }
          if (option === "never" && isParenthesized(context, node)) {
            const tokenBefore = sourceCode.getTokenBefore(node);
            const tokenAfter = sourceCode.getTokenAfter(node);
            report(node, "extraParens", (fixer) => fixer.replaceTextRange(
              [tokenBefore.range[0], tokenAfter.range[1]],
              getText(context, node)
            ));
          }
        }
        return {
          VariableDeclarator(node) {
            const type = "declaration";
            if (!isEnabled(type)) {
              return;
            }
            if (!isEnabled("condition") && node.init && node.init.type === "ConditionalExpression") {
              check(node.init.consequent, type);
              check(node.init.alternate, type);
              return;
            }
            check(node.init, type);
          },
          AssignmentExpression(node) {
            const type = "assignment";
            if (!isEnabled(type)) {
              return;
            }
            if (!isEnabled("condition") && node.right.type === "ConditionalExpression") {
              check(node.right.consequent, type);
              check(node.right.alternate, type);
              return;
            }
            check(node.right, type);
          },
          ReturnStatement(node) {
            const type = "return";
            if (isEnabled(type)) {
              check(node.argument, type);
            }
          },
          "ArrowFunctionExpression:exit": (node) => {
            const arrowBody = node.body;
            const type = "arrow";
            if (isEnabled(type) && arrowBody.type !== "BlockStatement") {
              check(arrowBody, type);
            }
          },
          ConditionalExpression(node) {
            const type = "condition";
            if (isEnabled(type)) {
              check(node.consequent, type);
              check(node.alternate, type);
            }
          },
          LogicalExpression(node) {
            const type = "logical";
            if (isEnabled(type)) {
              check(node.right, type);
            }
          },
          JSXAttribute(node) {
            const type = "prop";
            if (isEnabled(type) && node.value && node.value.type === "JSXExpressionContainer") {
              check(node.value.expression, type);
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-invalid-html-attribute.js
var require_no_invalid_html_attribute = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-invalid-html-attribute.js"(exports, module) {
    "use strict";
    var matchAll = require_string_prototype2();
    var docsUrl = require_docsUrl();
    var report = require_report();
    var rel = /* @__PURE__ */ new Map([
      ["alternate", /* @__PURE__ */ new Set(["link", "area", "a"])],
      ["apple-touch-icon", /* @__PURE__ */ new Set(["link"])],
      ["apple-touch-startup-image", /* @__PURE__ */ new Set(["link"])],
      ["author", /* @__PURE__ */ new Set(["link", "area", "a"])],
      ["bookmark", /* @__PURE__ */ new Set(["area", "a"])],
      ["canonical", /* @__PURE__ */ new Set(["link"])],
      ["dns-prefetch", /* @__PURE__ */ new Set(["link"])],
      ["external", /* @__PURE__ */ new Set(["area", "a", "form"])],
      ["help", /* @__PURE__ */ new Set(["link", "area", "a", "form"])],
      ["icon", /* @__PURE__ */ new Set(["link"])],
      ["license", /* @__PURE__ */ new Set(["link", "area", "a", "form"])],
      ["manifest", /* @__PURE__ */ new Set(["link"])],
      ["mask-icon", /* @__PURE__ */ new Set(["link"])],
      ["modulepreload", /* @__PURE__ */ new Set(["link"])],
      ["next", /* @__PURE__ */ new Set(["link", "area", "a", "form"])],
      ["nofollow", /* @__PURE__ */ new Set(["area", "a", "form"])],
      ["noopener", /* @__PURE__ */ new Set(["area", "a", "form"])],
      ["noreferrer", /* @__PURE__ */ new Set(["area", "a", "form"])],
      ["opener", /* @__PURE__ */ new Set(["area", "a", "form"])],
      ["pingback", /* @__PURE__ */ new Set(["link"])],
      ["preconnect", /* @__PURE__ */ new Set(["link"])],
      ["prefetch", /* @__PURE__ */ new Set(["link"])],
      ["preload", /* @__PURE__ */ new Set(["link"])],
      ["prerender", /* @__PURE__ */ new Set(["link"])],
      ["prev", /* @__PURE__ */ new Set(["link", "area", "a", "form"])],
      ["search", /* @__PURE__ */ new Set(["link", "area", "a", "form"])],
      ["shortcut", /* @__PURE__ */ new Set(["link"])],
      // generally allowed but needs pair with "icon"
      ["shortcut icon", /* @__PURE__ */ new Set(["link"])],
      ["stylesheet", /* @__PURE__ */ new Set(["link"])],
      ["tag", /* @__PURE__ */ new Set(["area", "a"])]
    ]);
    var pairs = /* @__PURE__ */ new Map([
      ["shortcut", /* @__PURE__ */ new Set(["icon"])]
    ]);
    var VALID_VALUES = /* @__PURE__ */ new Map([
      ["rel", rel]
    ]);
    var VALID_PAIR_VALUES = /* @__PURE__ */ new Map([
      ["rel", pairs]
    ]);
    var HTML_ELEMENTS = /* @__PURE__ */ new Set([
      "a",
      "abbr",
      "acronym",
      "address",
      "applet",
      "area",
      "article",
      "aside",
      "audio",
      "b",
      "base",
      "basefont",
      "bdi",
      "bdo",
      "bgsound",
      "big",
      "blink",
      "blockquote",
      "body",
      "br",
      "button",
      "canvas",
      "caption",
      "center",
      "cite",
      "code",
      "col",
      "colgroup",
      "content",
      "data",
      "datalist",
      "dd",
      "del",
      "details",
      "dfn",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "em",
      "embed",
      "fieldset",
      "figcaption",
      "figure",
      "font",
      "footer",
      "form",
      "frame",
      "frameset",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hgroup",
      "hr",
      "html",
      "i",
      "iframe",
      "image",
      "img",
      "input",
      "ins",
      "kbd",
      "keygen",
      "label",
      "legend",
      "li",
      "link",
      "main",
      "map",
      "mark",
      "marquee",
      "math",
      "menu",
      "menuitem",
      "meta",
      "meter",
      "nav",
      "nobr",
      "noembed",
      "noframes",
      "noscript",
      "object",
      "ol",
      "optgroup",
      "option",
      "output",
      "p",
      "param",
      "picture",
      "plaintext",
      "portal",
      "pre",
      "progress",
      "q",
      "rb",
      "rp",
      "rt",
      "rtc",
      "ruby",
      "s",
      "samp",
      "script",
      "section",
      "select",
      "shadow",
      "slot",
      "small",
      "source",
      "spacer",
      "span",
      "strike",
      "strong",
      "style",
      "sub",
      "summary",
      "sup",
      "svg",
      "table",
      "tbody",
      "td",
      "template",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "title",
      "tr",
      "track",
      "tt",
      "u",
      "ul",
      "var",
      "video",
      "wbr",
      "xmp"
    ]);
    var COMPONENT_ATTRIBUTE_MAP = /* @__PURE__ */ new Map([
      ["rel", /* @__PURE__ */ new Set(["link", "a", "area", "form"])]
    ]);
    var messages = {
      emptyIsMeaningless: "An empty \u201C{{attributeName}}\u201D attribute is meaningless.",
      neverValid: "\u201C{{reportingValue}}\u201D is never a valid \u201C{{attributeName}}\u201D attribute value.",
      noEmpty: "An empty \u201C{{attributeName}}\u201D attribute is meaningless.",
      noMethod: "The \u201D{{attributeName}}\u201C attribute cannot be a method.",
      notAlone: "\u201C{{reportingValue}}\u201D must be directly followed by \u201C{{missingValue}}\u201D.",
      notPaired: "\u201C{{reportingValue}}\u201D can not be directly followed by \u201C{{secondValue}}\u201D without \u201C{{missingValue}}\u201D.",
      notValidFor: "\u201C{{reportingValue}}\u201D is not a valid \u201C{{attributeName}}\u201D attribute value for <{{elementName}}>.",
      onlyMeaningfulFor: "The \u201D{{attributeName}}\u201C attribute only has meaning on the tags: {{tagNames}}",
      onlyStrings: "\u201C{{attributeName}}\u201D attribute only supports strings.",
      spaceDelimited: "\u201D{{attributeName}}\u201C attribute values should be space delimited.",
      suggestRemoveDefault: '"remove {{attributeName}}"',
      suggestRemoveEmpty: '"remove empty attribute {{attributeName}}"',
      suggestRemoveInvalid: "\u201Cremove invalid attribute {{reportingValue}}\u201D",
      suggestRemoveWhitespaces: "remove whitespaces in \u201C{{attributeName}}\u201D",
      suggestRemoveNonString: "remove non-string value in \u201C{{attributeName}}\u201D"
    };
    function splitIntoRangedParts(node, regex) {
      const valueRangeStart = node.range[0] + 1;
      return Array.from(matchAll(node.value, regex), (match) => {
        const start = match.index + valueRangeStart;
        const end = start + match[0].length;
        return {
          reportingValue: `${match[1]}`,
          value: match[1],
          range: [start, end]
        };
      });
    }
    function checkLiteralValueNode(context, attributeName, node, parentNode, parentNodeName) {
      if (typeof node.value !== "string") {
        const data = { attributeName, reportingValue: node.value };
        report(context, messages.onlyStrings, "onlyStrings", {
          node,
          data,
          suggest: [{
            messageId: "suggestRemoveNonString",
            data,
            fix(fixer) {
              return fixer.remove(parentNode);
            }
          }]
        });
        return;
      }
      if (!node.value.trim()) {
        const data = { attributeName, reportingValue: node.value };
        report(context, messages.noEmpty, "noEmpty", {
          node,
          data,
          suggest: [{
            messageId: "suggestRemoveEmpty",
            data,
            fix(fixer) {
              return fixer.remove(node.parent);
            }
          }]
        });
        return;
      }
      const singleAttributeParts = splitIntoRangedParts(node, /(\S+)/g);
      for (const singlePart of singleAttributeParts) {
        const allowedTags = VALID_VALUES.get(attributeName).get(singlePart.value);
        const reportingValue = singlePart.reportingValue;
        if (!allowedTags) {
          const data = {
            attributeName,
            reportingValue
          };
          const suggest = [{
            messageId: "suggestRemoveInvalid",
            data,
            fix(fixer) {
              return fixer.removeRange(singlePart.range);
            }
          }];
          report(context, messages.neverValid, "neverValid", {
            node,
            data,
            suggest
          });
        } else if (!allowedTags.has(parentNodeName)) {
          const data = {
            attributeName,
            reportingValue,
            elementName: parentNodeName
          };
          const suggest = [{
            messageId: "suggestRemoveInvalid",
            data,
            fix(fixer) {
              return fixer.removeRange(singlePart.range);
            }
          }];
          report(context, messages.notValidFor, "notValidFor", {
            node,
            data,
            suggest
          });
        }
      }
      const allowedPairsForAttribute = VALID_PAIR_VALUES.get(attributeName);
      if (allowedPairsForAttribute) {
        const pairAttributeParts = splitIntoRangedParts(node, /(?=(\b\S+\s*\S+))/g);
        for (const pairPart of pairAttributeParts) {
          for (const allowedPair of allowedPairsForAttribute) {
            const pairing = allowedPair[0];
            const siblings = allowedPair[1];
            const attributes = pairPart.reportingValue.split(" ");
            const firstValue = attributes[0];
            const secondValue = attributes[1];
            if (firstValue === pairing) {
              const lastValue = attributes[attributes.length - 1];
              if (!siblings.has(lastValue)) {
                const message = secondValue ? messages.notPaired : messages.notAlone;
                const messageId = secondValue ? "notPaired" : "notAlone";
                report(context, message, messageId, {
                  node,
                  data: {
                    reportingValue: firstValue,
                    secondValue,
                    missingValue: Array.from(siblings).join(", ")
                  },
                  suggest: false
                });
              }
            }
          }
        }
      }
      const whitespaceParts = splitIntoRangedParts(node, /(\s+)/g);
      for (const whitespacePart of whitespaceParts) {
        const data = { attributeName };
        if (whitespacePart.range[0] === node.range[0] + 1 || whitespacePart.range[1] === node.range[1] - 1) {
          report(context, messages.spaceDelimited, "spaceDelimited", {
            node,
            data,
            suggest: [{
              messageId: "suggestRemoveWhitespaces",
              data,
              fix(fixer) {
                return fixer.removeRange(whitespacePart.range);
              }
            }]
          });
        } else if (whitespacePart.value !== " ") {
          report(context, messages.spaceDelimited, "spaceDelimited", {
            node,
            data,
            suggest: [{
              messageId: "suggestRemoveWhitespaces",
              data,
              fix(fixer) {
                return fixer.replaceTextRange(whitespacePart.range, " ");
              }
            }]
          });
        }
      }
    }
    var DEFAULT_ATTRIBUTES = ["rel"];
    function checkAttribute(context, node) {
      const attribute = node.name.name;
      const parentNodeName = node.parent.name.name;
      if (!COMPONENT_ATTRIBUTE_MAP.has(attribute) || !COMPONENT_ATTRIBUTE_MAP.get(attribute).has(parentNodeName)) {
        const tagNames = Array.from(
          COMPONENT_ATTRIBUTE_MAP.get(attribute).values(),
          (tagName) => `"<${tagName}>"`
        ).join(", ");
        const data = {
          attributeName: attribute,
          tagNames
        };
        report(context, messages.onlyMeaningfulFor, "onlyMeaningfulFor", {
          node: node.name,
          data,
          suggest: [{
            messageId: "suggestRemoveDefault",
            data,
            fix(fixer) {
              return fixer.remove(node);
            }
          }]
        });
        return;
      }
      function fix(fixer) {
        return fixer.remove(node);
      }
      if (!node.value) {
        const data = { attributeName: attribute };
        report(context, messages.emptyIsMeaningless, "emptyIsMeaningless", {
          node: node.name,
          data,
          suggest: [{
            messageId: "suggestRemoveEmpty",
            data,
            fix
          }]
        });
        return;
      }
      if (node.value.type === "Literal") {
        return checkLiteralValueNode(context, attribute, node.value, node, parentNodeName);
      }
      if (node.value.expression.type === "Literal") {
        return checkLiteralValueNode(context, attribute, node.value.expression, node, parentNodeName);
      }
      if (node.value.type !== "JSXExpressionContainer") {
        return;
      }
      if (node.value.expression.type === "ObjectExpression") {
        const data = { attributeName: attribute };
        report(context, messages.onlyStrings, "onlyStrings", {
          node: node.value,
          data,
          suggest: [{
            messageId: "suggestRemoveDefault",
            data,
            fix
          }]
        });
      } else if (node.value.expression.type === "Identifier" && node.value.expression.name === "undefined") {
        const data = { attributeName: attribute };
        report(context, messages.onlyStrings, "onlyStrings", {
          node: node.value,
          data,
          suggest: [{
            messageId: "suggestRemoveDefault",
            data,
            fix
          }]
        });
      }
    }
    function isValidCreateElement(node) {
      return node.callee && node.callee.type === "MemberExpression" && node.callee.object.name === "React" && node.callee.property.name === "createElement" && node.arguments.length > 0;
    }
    function checkPropValidValue(context, node, value, attribute) {
      const validTags = VALID_VALUES.get(attribute);
      if (value.type !== "Literal") {
        return;
      }
      const validTagSet = validTags.get(value.value);
      if (!validTagSet) {
        const data = {
          attributeName: attribute,
          reportingValue: value.value
        };
        report(context, messages.neverValid, "neverValid", {
          node: value,
          data,
          suggest: [{
            messageId: "suggestRemoveInvalid",
            data,
            fix(fixer) {
              return fixer.replaceText(value, value.raw.replace(value.value, ""));
            }
          }]
        });
      } else if (!validTagSet.has(node.arguments[0].value)) {
        report(context, messages.notValidFor, "notValidFor", {
          node: value,
          data: {
            attributeName: attribute,
            reportingValue: value.raw,
            elementName: node.arguments[0].value
          },
          suggest: false
        });
      }
    }
    function checkCreateProps(context, node, attribute) {
      const propsArg = node.arguments[1];
      if (!propsArg || propsArg.type !== "ObjectExpression") {
        return;
      }
      for (const prop of propsArg.properties) {
        if (!prop.key || prop.key.type !== "Identifier") {
          continue;
        }
        if (prop.key.name !== attribute) {
          continue;
        }
        if (!COMPONENT_ATTRIBUTE_MAP.get(attribute).has(node.arguments[0].value)) {
          const tagNames = Array.from(
            COMPONENT_ATTRIBUTE_MAP.get(attribute).values(),
            (tagName) => `"<${tagName}>"`
          ).join(", ");
          report(context, messages.onlyMeaningfulFor, "onlyMeaningfulFor", {
            node: prop.key,
            data: {
              attributeName: attribute,
              tagNames
            },
            suggest: false
          });
          continue;
        }
        if (prop.method) {
          report(context, messages.noMethod, "noMethod", {
            node: prop,
            data: {
              attributeName: attribute
            },
            suggest: false
          });
          continue;
        }
        if (prop.shorthand || prop.computed) {
          continue;
        }
        if (prop.value.type === "ArrayExpression") {
          for (const value of prop.value.elements) {
            checkPropValidValue(context, node, value, attribute);
          }
          continue;
        }
        checkPropValidValue(context, node, prop.value, attribute);
      }
    }
    module.exports = {
      meta: {
        docs: {
          description: "Disallow usage of invalid attributes",
          category: "Possible Errors",
          url: docsUrl("no-invalid-html-attribute")
        },
        messages,
        schema: [{
          type: "array",
          uniqueItems: true,
          items: {
            enum: ["rel"]
          }
        }],
        type: "suggestion",
        hasSuggestions: true
        // eslint-disable-line eslint-plugin/require-meta-has-suggestions
      },
      create(context) {
        return {
          JSXAttribute(node) {
            const attributes = new Set(context.options[0] || DEFAULT_ATTRIBUTES);
            if (!attributes.has(node.name.name)) {
              return;
            }
            if (!HTML_ELEMENTS.has(node.parent.name.name)) {
              return;
            }
            checkAttribute(context, node);
          },
          CallExpression(node) {
            if (!isValidCreateElement(node)) {
              return;
            }
            const elemNameArg = node.arguments[0];
            if (!elemNameArg || elemNameArg.type !== "Literal") {
              return;
            }
            if (!HTML_ELEMENTS.has(elemNameArg.value)) {
              return;
            }
            const attributes = new Set(context.options[0] || DEFAULT_ATTRIBUTES);
            for (const attribute of attributes) {
              checkCreateProps(context, node, attribute);
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-access-state-in-setstate.js
var require_no_access_state_in_setstate = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-access-state-in-setstate.js"(exports, module) {
    "use strict";
    var docsUrl = require_docsUrl();
    var componentUtil = require_componentUtil();
    var report = require_report();
    var getScope = require_eslint().getScope;
    var messages = {
      useCallback: "Use callback in setState when referencing the previous state."
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow when this.state is accessed within setState",
          category: "Possible Errors",
          recommended: false,
          url: docsUrl("no-access-state-in-setstate")
        },
        messages
      },
      create(context) {
        function isSetStateCall(node) {
          return node.type === "CallExpression" && node.callee.property && node.callee.property.name === "setState" && node.callee.object.type === "ThisExpression";
        }
        function isFirstArgumentInSetStateCall(current, node) {
          if (!isSetStateCall(current)) {
            return false;
          }
          while (node && node.parent !== current) {
            node = node.parent;
          }
          return current.arguments[0] === node;
        }
        function isClassComponent(node) {
          return !!(componentUtil.getParentES6Component(context, node) || componentUtil.getParentES5Component(context, node));
        }
        const methods = [];
        const vars = [];
        return {
          CallExpression(node) {
            if (!isClassComponent(node)) {
              return;
            }
            methods.forEach((method) => {
              if (node.callee.name === method.methodName) {
                let current2 = node.parent;
                while (current2.type !== "Program") {
                  if (current2.type === "MethodDefinition") {
                    methods.push({
                      methodName: current2.key.name,
                      node: method.node
                    });
                    break;
                  }
                  current2 = current2.parent;
                }
              }
            });
            let current = node.parent;
            while (current.type !== "Program") {
              if (isFirstArgumentInSetStateCall(current, node)) {
                const methodName = node.callee.name;
                methods.forEach((method) => {
                  if (method.methodName === methodName) {
                    report(context, messages.useCallback, "useCallback", {
                      node: method.node
                    });
                  }
                });
                break;
              }
              current = current.parent;
            }
          },
          MemberExpression(node) {
            if (node.property.name === "state" && node.object.type === "ThisExpression" && isClassComponent(node)) {
              let current = node;
              while (current.type !== "Program") {
                if (isFirstArgumentInSetStateCall(current, node)) {
                  report(context, messages.useCallback, "useCallback", {
                    node
                  });
                  break;
                }
                if (current.type === "MethodDefinition") {
                  methods.push({
                    methodName: current.key.name,
                    node
                  });
                  break;
                } else if (current.type === "FunctionExpression" && current.parent.key) {
                  methods.push({
                    methodName: current.parent.key.name,
                    node
                  });
                  break;
                }
                if (current.type === "VariableDeclarator") {
                  vars.push({
                    node,
                    scope: getScope(context, node),
                    variableName: current.id.name
                  });
                  break;
                }
                current = current.parent;
              }
            }
          },
          Identifier(node) {
            let current = node;
            while (current.parent.type === "BinaryExpression") {
              current = current.parent;
            }
            if (current.parent.value === current || current.parent.object === current) {
              while (current.type !== "Program") {
                if (isFirstArgumentInSetStateCall(current, node)) {
                  vars.filter((v) => v.scope === getScope(context, node) && v.variableName === node.name).forEach((v) => {
                    report(context, messages.useCallback, "useCallback", {
                      node: v.node
                    });
                  });
                }
                current = current.parent;
              }
            }
          },
          ObjectPattern(node) {
            const isDerivedFromThis = node.parent.init && node.parent.init.type === "ThisExpression";
            node.properties.forEach((property) => {
              if (property && property.key && property.key.name === "state" && isDerivedFromThis) {
                vars.push({
                  node: property.key,
                  scope: getScope(context, node),
                  variableName: property.key.name
                });
              }
            });
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-adjacent-inline-elements.js
var require_no_adjacent_inline_elements = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-adjacent-inline-elements.js"(exports, module) {
    "use strict";
    var docsUrl = require_docsUrl();
    var isCreateElement = require_isCreateElement();
    var report = require_report();
    var inlineNames = [
      "a",
      "b",
      "big",
      "i",
      "small",
      "tt",
      "abbr",
      "acronym",
      "cite",
      "code",
      "dfn",
      "em",
      "kbd",
      "strong",
      "samp",
      "time",
      "var",
      "bdo",
      "br",
      "img",
      "map",
      "object",
      "q",
      "script",
      "span",
      "sub",
      "sup",
      "button",
      "input",
      "label",
      "select",
      "textarea"
    ];
    var whitespaceRegex = /(?:^\s|\s$)/;
    function isInline(node) {
      if (node.type === "Literal") {
        const value = node.value;
        return !whitespaceRegex.test(value);
      }
      if (node.type === "JSXElement" && inlineNames.indexOf(node.openingElement.name.name) > -1) {
        return true;
      }
      if (node.type === "CallExpression" && inlineNames.indexOf(node.arguments[0].value) > -1) {
        return true;
      }
      return false;
    }
    var messages = {
      inlineElement: "Child elements which render as inline HTML elements should be separated by a space or wrapped in block level elements."
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow adjacent inline elements not separated by whitespace.",
          category: "Best Practices",
          recommended: false,
          url: docsUrl("no-adjacent-inline-elements")
        },
        schema: [],
        messages
      },
      create(context) {
        function validate(node, children) {
          let currentIsInline = false;
          let previousIsInline = false;
          if (!children) {
            return;
          }
          for (let i = 0; i < children.length; i++) {
            currentIsInline = isInline(children[i]);
            if (previousIsInline && currentIsInline) {
              report(context, messages.inlineElement, "inlineElement", {
                node
              });
              return;
            }
            previousIsInline = currentIsInline;
          }
        }
        return {
          JSXElement(node) {
            validate(node, node.children);
          },
          CallExpression(node) {
            if (!isCreateElement(context, node)) {
              return;
            }
            if (node.arguments.length < 2 || !node.arguments[2]) {
              return;
            }
            const children = node.arguments[2].elements;
            validate(node, children);
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-array-index-key.js
var require_no_array_index_key = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-array-index-key.js"(exports, module) {
    "use strict";
    var has = require_polyfill19()();
    var astUtil = require_ast();
    var docsUrl = require_docsUrl();
    var pragma = require_pragma();
    var report = require_report();
    var variableUtil = require_variable();
    function isCreateCloneElement(node, context) {
      if (!node) {
        return false;
      }
      if (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") {
        return node.object && node.object.name === pragma.getFromContext(context) && ["createElement", "cloneElement"].indexOf(node.property.name) !== -1;
      }
      if (node.type === "Identifier") {
        const variable = variableUtil.findVariableByName(context, node, node.name);
        if (variable && variable.type === "ImportSpecifier") {
          return variable.parent.source.value === "react";
        }
      }
      return false;
    }
    var messages = {
      noArrayIndex: "Do not use Array index in keys"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow usage of Array index in keys",
          category: "Best Practices",
          recommended: false,
          url: docsUrl("no-array-index-key")
        },
        messages,
        schema: []
      },
      create(context) {
        const indexParamNames = [];
        const iteratorFunctionsToIndexParamPosition = {
          every: 1,
          filter: 1,
          find: 1,
          findIndex: 1,
          flatMap: 1,
          forEach: 1,
          map: 1,
          reduce: 2,
          reduceRight: 2,
          some: 1
        };
        function isArrayIndex(node) {
          return node.type === "Identifier" && indexParamNames.indexOf(node.name) !== -1;
        }
        function isUsingReactChildren(node) {
          const callee = node.callee;
          if (!callee || !callee.property || !callee.object) {
            return null;
          }
          const isReactChildMethod = ["map", "forEach"].indexOf(callee.property.name) > -1;
          if (!isReactChildMethod) {
            return null;
          }
          const obj = callee.object;
          if (obj && obj.name === "Children") {
            return true;
          }
          if (obj && obj.object && obj.object.name === pragma.getFromContext(context)) {
            return true;
          }
          return false;
        }
        function getMapIndexParamName(node) {
          const callee = node.callee;
          if (callee.type !== "MemberExpression" && callee.type !== "OptionalMemberExpression") {
            return null;
          }
          if (callee.property.type !== "Identifier") {
            return null;
          }
          if (!has(iteratorFunctionsToIndexParamPosition, callee.property.name)) {
            return null;
          }
          const callbackArg = isUsingReactChildren(node) ? node.arguments[1] : node.arguments[0];
          if (!callbackArg) {
            return null;
          }
          if (!astUtil.isFunctionLikeExpression(callbackArg)) {
            return null;
          }
          const params = callbackArg.params;
          const indexParamPosition = iteratorFunctionsToIndexParamPosition[callee.property.name];
          if (params.length < indexParamPosition + 1) {
            return null;
          }
          return params[indexParamPosition].name;
        }
        function getIdentifiersFromBinaryExpression(side) {
          if (side.type === "Identifier") {
            return side;
          }
          if (side.type === "BinaryExpression") {
            const left = getIdentifiersFromBinaryExpression(side.left);
            const right = getIdentifiersFromBinaryExpression(side.right);
            return [].concat(left, right).filter(Boolean);
          }
          return null;
        }
        function checkPropValue(node) {
          if (isArrayIndex(node)) {
            report(context, messages.noArrayIndex, "noArrayIndex", {
              node
            });
            return;
          }
          if (node.type === "TemplateLiteral") {
            node.expressions.filter(isArrayIndex).forEach(() => {
              report(context, messages.noArrayIndex, "noArrayIndex", {
                node
              });
            });
            return;
          }
          if (node.type === "BinaryExpression") {
            const identifiers = getIdentifiersFromBinaryExpression(node);
            identifiers.filter(isArrayIndex).forEach(() => {
              report(context, messages.noArrayIndex, "noArrayIndex", {
                node
              });
            });
            return;
          }
          if (node.type === "CallExpression" && node.callee && node.callee.type === "MemberExpression" && node.callee.object && isArrayIndex(node.callee.object) && node.callee.property && node.callee.property.type === "Identifier" && node.callee.property.name === "toString") {
            report(context, messages.noArrayIndex, "noArrayIndex", {
              node
            });
            return;
          }
          if (node.type === "CallExpression" && node.callee && node.callee.type === "Identifier" && node.callee.name === "String" && Array.isArray(node.arguments) && node.arguments.length > 0 && isArrayIndex(node.arguments[0])) {
            report(context, messages.noArrayIndex, "noArrayIndex", {
              node: node.arguments[0]
            });
          }
        }
        function popIndex(node) {
          const mapIndexParamName = getMapIndexParamName(node);
          if (!mapIndexParamName) {
            return;
          }
          indexParamNames.pop();
        }
        return {
          "CallExpression, OptionalCallExpression"(node) {
            if (isCreateCloneElement(node.callee, context) && node.arguments.length > 1) {
              if (!indexParamNames.length) {
                return;
              }
              const props = node.arguments[1];
              if (props.type !== "ObjectExpression") {
                return;
              }
              props.properties.forEach((prop) => {
                if (!prop.key || prop.key.name !== "key") {
                  return;
                }
                checkPropValue(prop.value);
              });
              return;
            }
            const mapIndexParamName = getMapIndexParamName(node);
            if (!mapIndexParamName) {
              return;
            }
            indexParamNames.push(mapIndexParamName);
          },
          JSXAttribute(node) {
            if (node.name.name !== "key") {
              return;
            }
            if (!indexParamNames.length) {
              return;
            }
            const value = node.value;
            if (!value || value.type !== "JSXExpressionContainer") {
              return;
            }
            checkPropValue(value.expression);
          },
          "CallExpression:exit": popIndex,
          "OptionalCallExpression:exit": popIndex
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/lifecycleMethods.js
var require_lifecycleMethods = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/lifecycleMethods.js"(exports, module) {
    "use strict";
    module.exports = {
      instance: [
        "getDefaultProps",
        "getInitialState",
        "getChildContext",
        "componentWillMount",
        "UNSAFE_componentWillMount",
        "componentDidMount",
        "componentWillReceiveProps",
        "UNSAFE_componentWillReceiveProps",
        "shouldComponentUpdate",
        "componentWillUpdate",
        "UNSAFE_componentWillUpdate",
        "getSnapshotBeforeUpdate",
        "componentDidUpdate",
        "componentDidCatch",
        "componentWillUnmount",
        "render"
      ],
      static: [
        "getDerivedStateFromProps"
      ]
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-arrow-function-lifecycle.js
var require_no_arrow_function_lifecycle = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-arrow-function-lifecycle.js"(exports, module) {
    "use strict";
    var values = require_object3();
    var Components = require_Components();
    var astUtil = require_ast();
    var componentUtil = require_componentUtil();
    var docsUrl = require_docsUrl();
    var lifecycleMethods = require_lifecycleMethods();
    var report = require_report();
    var eslintUtil = require_eslint();
    var getSourceCode = eslintUtil.getSourceCode;
    var getText = eslintUtil.getText;
    function getRuleText(node) {
      const params = node.value.params.map((p) => p.name);
      if (node.type === "Property") {
        return `: function(${params.join(", ")}) `;
      }
      if (node.type === "ClassProperty" || node.type === "PropertyDefinition") {
        return `(${params.join(", ")}) `;
      }
      return null;
    }
    var messages = {
      lifecycle: "{{propertyName}} is a React lifecycle method, and should not be an arrow function or in a class field. Use an instance method instead."
    };
    module.exports = {
      meta: {
        docs: {
          description: "Lifecycle methods should be methods on the prototype, not class fields",
          category: "Best Practices",
          recommended: false,
          url: docsUrl("no-arrow-function-lifecycle")
        },
        messages,
        schema: [],
        fixable: "code"
      },
      create: Components.detect((context, components) => {
        function reportNoArrowFunctionLifecycle(properties) {
          properties.forEach((node) => {
            if (!node || !node.value) {
              return;
            }
            const propertyName = astUtil.getPropertyName(node);
            const nodeType = node.value.type;
            const isLifecycleMethod = (node.static && !componentUtil.isES5Component(node, context) ? lifecycleMethods.static : lifecycleMethods.instance).indexOf(propertyName) > -1;
            if (nodeType === "ArrowFunctionExpression" && isLifecycleMethod) {
              const body = node.value.body;
              const isBlockBody = body.type === "BlockStatement";
              const sourceCode = getSourceCode(context);
              let nextComment = [];
              let previousComment = [];
              let bodyRange;
              if (!isBlockBody) {
                const previousToken = sourceCode.getTokenBefore(body);
                if (sourceCode.getCommentsBefore) {
                  previousComment = sourceCode.getCommentsBefore(body);
                } else {
                  const potentialComment = sourceCode.getTokenBefore(body, { includeComments: true });
                  previousComment = previousToken === potentialComment ? [] : [potentialComment];
                }
                if (sourceCode.getCommentsAfter) {
                  nextComment = sourceCode.getCommentsAfter(body);
                } else {
                  const potentialComment = sourceCode.getTokenAfter(body, { includeComments: true });
                  const nextToken = sourceCode.getTokenAfter(body);
                  nextComment = nextToken === potentialComment ? [] : [potentialComment];
                }
                bodyRange = [
                  (previousComment.length > 0 ? previousComment[0] : body).range[0],
                  (nextComment.length > 0 ? nextComment[nextComment.length - 1] : body).range[1] + (node.value.body.type === "ObjectExpression" ? 1 : 0)
                  // to account for a wrapped end paren
                ];
              }
              const headRange = [
                node.key.range[1],
                (previousComment.length > 0 ? previousComment[0] : body).range[0]
              ];
              const hasSemi = node.value.expression && getText(context, node).slice(node.value.range[1] - node.range[0]) === ";";
              report(
                context,
                messages.lifecycle,
                "lifecycle",
                {
                  node,
                  data: {
                    propertyName
                  },
                  fix(fixer) {
                    if (!sourceCode.getCommentsAfter) {
                      return isBlockBody && fixer.replaceTextRange(headRange, getRuleText(node));
                    }
                    return [].concat(
                      fixer.replaceTextRange(headRange, getRuleText(node)),
                      isBlockBody ? [] : fixer.replaceTextRange(
                        [bodyRange[0], bodyRange[1] + (hasSemi ? 1 : 0)],
                        `{ return ${previousComment.map((x) => getText(context, x)).join("")}${getText(context, body)}${nextComment.map((x) => getText(context, x)).join("")}; }`
                      )
                    );
                  }
                }
              );
            }
          });
        }
        return {
          "Program:exit"() {
            values(components.list()).forEach((component) => {
              const properties = astUtil.getComponentProperties(component.node);
              reportNoArrowFunctionLifecycle(properties);
            });
          }
        };
      })
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-children-prop.js
var require_no_children_prop = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-children-prop.js"(exports, module) {
    "use strict";
    var docsUrl = require_docsUrl();
    var isCreateElement = require_isCreateElement();
    var report = require_report();
    function isCreateElementWithProps(node, context) {
      return isCreateElement(context, node) && node.arguments.length > 1 && node.arguments[1].type === "ObjectExpression";
    }
    var messages = {
      nestChildren: "Do not pass children as props. Instead, nest children between the opening and closing tags.",
      passChildrenAsArgs: "Do not pass children as props. Instead, pass them as additional arguments to React.createElement.",
      nestFunction: "Do not nest a function between the opening and closing tags. Instead, pass it as a prop.",
      passFunctionAsArgs: "Do not pass a function as an additional argument to React.createElement. Instead, pass it as a prop."
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow passing of children as props",
          category: "Best Practices",
          recommended: true,
          url: docsUrl("no-children-prop")
        },
        messages,
        schema: [{
          type: "object",
          properties: {
            allowFunctions: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }]
      },
      create(context) {
        const configuration = context.options[0] || {};
        function isFunction(node) {
          return configuration.allowFunctions && (node.type === "ArrowFunctionExpression" || node.type === "FunctionExpression");
        }
        return {
          JSXAttribute(node) {
            if (node.name.name !== "children") {
              return;
            }
            const value = node.value;
            if (value && value.type === "JSXExpressionContainer" && isFunction(value.expression)) {
              return;
            }
            report(context, messages.nestChildren, "nestChildren", {
              node
            });
          },
          CallExpression(node) {
            if (!isCreateElementWithProps(node, context)) {
              return;
            }
            const props = node.arguments[1].properties;
            const childrenProp = props.find((prop) => prop.key && prop.key.name === "children");
            if (childrenProp) {
              if (childrenProp.value && !isFunction(childrenProp.value)) {
                report(context, messages.passChildrenAsArgs, "passChildrenAsArgs", {
                  node
                });
              }
            } else if (node.arguments.length === 3) {
              const children = node.arguments[2];
              if (isFunction(children)) {
                report(context, messages.passFunctionAsArgs, "passFunctionAsArgs", {
                  node
                });
              }
            }
          },
          JSXElement(node) {
            const children = node.children;
            if (children && children.length === 1 && children[0].type === "JSXExpressionContainer") {
              if (isFunction(children[0].expression)) {
                report(context, messages.nestFunction, "nestFunction", {
                  node
                });
              }
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-danger.js
var require_no_danger = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-danger.js"(exports, module) {
    "use strict";
    var has = require_polyfill19()();
    var fromEntries = require_polyfill()();
    var docsUrl = require_docsUrl();
    var jsxUtil = require_jsx();
    var report = require_report();
    var DANGEROUS_PROPERTY_NAMES = [
      "dangerouslySetInnerHTML"
    ];
    var DANGEROUS_PROPERTIES = fromEntries(DANGEROUS_PROPERTY_NAMES.map((prop) => [prop, prop]));
    function isDangerous(name) {
      return has(DANGEROUS_PROPERTIES, name);
    }
    var messages = {
      dangerousProp: "Dangerous property '{{name}}' found"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow usage of dangerous JSX properties",
          category: "Best Practices",
          recommended: false,
          url: docsUrl("no-danger")
        },
        messages,
        schema: []
      },
      create(context) {
        return {
          JSXAttribute(node) {
            if (jsxUtil.isDOMComponent(node.parent) && isDangerous(node.name.name)) {
              report(context, messages.dangerousProp, "dangerousProp", {
                node,
                data: {
                  name: node.name.name
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-danger-with-children.js
var require_no_danger_with_children = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-danger-with-children.js"(exports, module) {
    "use strict";
    var variableUtil = require_variable();
    var jsxUtil = require_jsx();
    var docsUrl = require_docsUrl();
    var report = require_report();
    var messages = {
      dangerWithChildren: "Only set one of `children` or `props.dangerouslySetInnerHTML`"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow when a DOM element is using both children and dangerouslySetInnerHTML",
          category: "Possible Errors",
          recommended: true,
          url: docsUrl("no-danger-with-children")
        },
        messages,
        schema: []
        // no options
      },
      create(context) {
        function findSpreadVariable(node, name) {
          return variableUtil.variablesInScope(context, node).find((item) => item.name === name);
        }
        function findObjectProp(node, propName, seenProps) {
          if (!node.properties) {
            return false;
          }
          return node.properties.find((prop) => {
            if (prop.type === "Property") {
              return prop.key.name === propName;
            }
            if (prop.type === "ExperimentalSpreadProperty" || prop.type === "SpreadElement") {
              const variable = findSpreadVariable(node, prop.argument.name);
              if (variable && variable.defs.length && variable.defs[0].node.init) {
                if (seenProps.indexOf(prop.argument.name) > -1) {
                  return false;
                }
                const newSeenProps = seenProps.concat(prop.argument.name || []);
                return findObjectProp(variable.defs[0].node.init, propName, newSeenProps);
              }
            }
            return false;
          });
        }
        function findJsxProp(node, propName) {
          const attributes = node.openingElement.attributes;
          return attributes.find((attribute) => {
            if (attribute.type === "JSXSpreadAttribute") {
              const variable = findSpreadVariable(node, attribute.argument.name);
              if (variable && variable.defs.length && variable.defs[0].node.init) {
                return findObjectProp(variable.defs[0].node.init, propName, []);
              }
            }
            return attribute.name && attribute.name.name === propName;
          });
        }
        function isLineBreak(node) {
          const isLiteral = node.type === "Literal" || node.type === "JSXText";
          const isMultiline = node.loc.start.line !== node.loc.end.line;
          const isWhiteSpaces = jsxUtil.isWhiteSpaces(node.value);
          return isLiteral && isMultiline && isWhiteSpaces;
        }
        return {
          JSXElement(node) {
            let hasChildren = false;
            if (node.children.length && !isLineBreak(node.children[0])) {
              hasChildren = true;
            } else if (findJsxProp(node, "children")) {
              hasChildren = true;
            }
            if (node.openingElement.attributes && hasChildren && findJsxProp(node, "dangerouslySetInnerHTML")) {
              report(context, messages.dangerWithChildren, "dangerWithChildren", {
                node
              });
            }
          },
          CallExpression(node) {
            if (node.callee && node.callee.type === "MemberExpression" && node.callee.property.name === "createElement" && node.arguments.length > 1) {
              let hasChildren = false;
              let props = node.arguments[1];
              if (props.type === "Identifier") {
                const variable = variableUtil.variablesInScope(context, node).find((item) => item.name === props.name);
                if (variable && variable.defs.length && variable.defs[0].node.init) {
                  props = variable.defs[0].node.init;
                }
              }
              const dangerously = findObjectProp(props, "dangerouslySetInnerHTML", []);
              if (node.arguments.length === 2) {
                if (findObjectProp(props, "children", [])) {
                  hasChildren = true;
                }
              } else {
                hasChildren = true;
              }
              if (dangerously && hasChildren) {
                report(context, messages.dangerWithChildren, "dangerWithChildren", {
                  node
                });
              }
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-deprecated.js
var require_no_deprecated = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-deprecated.js"(exports, module) {
    "use strict";
    var entries = require_object2();
    var astUtil = require_ast();
    var componentUtil = require_componentUtil();
    var docsUrl = require_docsUrl();
    var pragmaUtil = require_pragma();
    var testReactVersion = require_version().testReactVersion;
    var report = require_report();
    var getText = require_eslint().getText;
    var MODULES = {
      react: ["React"],
      "react-addons-perf": ["ReactPerf", "Perf"],
      "react-dom": ["ReactDOM"],
      "react-dom/server": ["ReactDOMServer"]
    };
    function getDeprecated(pragma) {
      const deprecated = {};
      deprecated[`${pragma}.renderComponent`] = ["0.12.0", `${pragma}.render`];
      deprecated[`${pragma}.renderComponentToString`] = ["0.12.0", `${pragma}.renderToString`];
      deprecated[`${pragma}.renderComponentToStaticMarkup`] = ["0.12.0", `${pragma}.renderToStaticMarkup`];
      deprecated[`${pragma}.isValidComponent`] = ["0.12.0", `${pragma}.isValidElement`];
      deprecated[`${pragma}.PropTypes.component`] = ["0.12.0", `${pragma}.PropTypes.element`];
      deprecated[`${pragma}.PropTypes.renderable`] = ["0.12.0", `${pragma}.PropTypes.node`];
      deprecated[`${pragma}.isValidClass`] = ["0.12.0"];
      deprecated["this.transferPropsTo"] = ["0.12.0", "spread operator ({...})"];
      deprecated[`${pragma}.addons.classSet`] = ["0.13.0", "the npm module classnames"];
      deprecated[`${pragma}.addons.cloneWithProps`] = ["0.13.0", `${pragma}.cloneElement`];
      deprecated[`${pragma}.render`] = ["0.14.0", "ReactDOM.render"];
      deprecated[`${pragma}.unmountComponentAtNode`] = ["0.14.0", "ReactDOM.unmountComponentAtNode"];
      deprecated[`${pragma}.findDOMNode`] = ["0.14.0", "ReactDOM.findDOMNode"];
      deprecated[`${pragma}.renderToString`] = ["0.14.0", "ReactDOMServer.renderToString"];
      deprecated[`${pragma}.renderToStaticMarkup`] = ["0.14.0", "ReactDOMServer.renderToStaticMarkup"];
      deprecated[`${pragma}.addons.LinkedStateMixin`] = ["15.0.0"];
      deprecated["ReactPerf.printDOM"] = ["15.0.0", "ReactPerf.printOperations"];
      deprecated["Perf.printDOM"] = ["15.0.0", "Perf.printOperations"];
      deprecated["ReactPerf.getMeasurementsSummaryMap"] = ["15.0.0", "ReactPerf.getWasted"];
      deprecated["Perf.getMeasurementsSummaryMap"] = ["15.0.0", "Perf.getWasted"];
      deprecated[`${pragma}.createClass`] = ["15.5.0", "the npm module create-react-class"];
      deprecated[`${pragma}.addons.TestUtils`] = ["15.5.0", "ReactDOM.TestUtils"];
      deprecated[`${pragma}.PropTypes`] = ["15.5.0", "the npm module prop-types"];
      deprecated[`${pragma}.DOM`] = ["15.6.0", "the npm module react-dom-factories"];
      deprecated.componentWillMount = [
        "16.9.0",
        "UNSAFE_componentWillMount",
        "https://reactjs.org/docs/react-component.html#unsafe_componentwillmount. Use https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles to automatically update your components."
      ];
      deprecated.componentWillReceiveProps = [
        "16.9.0",
        "UNSAFE_componentWillReceiveProps",
        "https://reactjs.org/docs/react-component.html#unsafe_componentwillreceiveprops. Use https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles to automatically update your components."
      ];
      deprecated.componentWillUpdate = [
        "16.9.0",
        "UNSAFE_componentWillUpdate",
        "https://reactjs.org/docs/react-component.html#unsafe_componentwillupdate. Use https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles to automatically update your components."
      ];
      deprecated["ReactDOM.render"] = [
        "18.0.0",
        "createRoot",
        "https://reactjs.org/link/switch-to-createroot"
      ];
      deprecated["ReactDOM.hydrate"] = [
        "18.0.0",
        "hydrateRoot",
        "https://reactjs.org/link/switch-to-createroot"
      ];
      deprecated["ReactDOM.unmountComponentAtNode"] = [
        "18.0.0",
        "root.unmount",
        "https://reactjs.org/link/switch-to-createroot"
      ];
      deprecated["ReactDOMServer.renderToNodeStream"] = [
        "18.0.0",
        "renderToPipeableStream",
        "https://reactjs.org/docs/react-dom-server.html#rendertonodestream"
      ];
      return deprecated;
    }
    var messages = {
      deprecated: "{{oldMethod}} is deprecated since React {{version}}{{newMethod}}{{refs}}"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow usage of deprecated methods",
          category: "Best Practices",
          recommended: true,
          url: docsUrl("no-deprecated")
        },
        messages,
        schema: []
      },
      create(context) {
        const pragma = pragmaUtil.getFromContext(context);
        const deprecated = getDeprecated(pragma);
        function isDeprecated(method) {
          return deprecated && deprecated[method] && deprecated[method][0] && testReactVersion(context, `>= ${deprecated[method][0]}`);
        }
        function checkDeprecation(node, methodName, methodNode) {
          if (!isDeprecated(methodName)) {
            return;
          }
          const version = deprecated[methodName][0];
          const newMethod = deprecated[methodName][1];
          const refs = deprecated[methodName][2];
          report(context, messages.deprecated, "deprecated", {
            node: methodNode || node,
            data: {
              oldMethod: methodName,
              version,
              newMethod: newMethod ? `, use ${newMethod} instead` : "",
              refs: refs ? `, see ${refs}` : ""
            }
          });
        }
        function getReactModuleName(node) {
          let moduleName = false;
          if (!node.init) {
            return false;
          }
          entries(MODULES).some((entry) => {
            const key = entry[0];
            const moduleNames = entry[1];
            if (node.init.arguments && node.init.arguments.length > 0 && node.init.arguments[0] && key === node.init.arguments[0].value) {
              moduleName = MODULES[key][0];
            } else {
              moduleName = moduleNames.find((name) => name === node.init.name);
            }
            return moduleName;
          });
          return moduleName;
        }
        function getLifeCycleMethods(node) {
          const properties = astUtil.getComponentProperties(node);
          return properties.map((property) => ({
            name: astUtil.getPropertyName(property),
            node: astUtil.getPropertyNameNode(property)
          }));
        }
        function checkLifeCycleMethods(node) {
          if (componentUtil.isES5Component(node, context) || componentUtil.isES6Component(node, context)) {
            const methods = getLifeCycleMethods(node);
            methods.forEach((method) => checkDeprecation(node, method.name, method.node));
          }
        }
        return {
          MemberExpression(node) {
            checkDeprecation(node, getText(context, node));
          },
          ImportDeclaration(node) {
            const isReactImport = typeof MODULES[node.source.value] !== "undefined";
            if (!isReactImport) {
              return;
            }
            node.specifiers.filter((s) => s.imported).forEach((specifier) => {
              checkDeprecation(node, `${MODULES[node.source.value][0]}.${specifier.imported.name}`, specifier);
            });
          },
          VariableDeclarator(node) {
            const reactModuleName = getReactModuleName(node);
            const isRequire = node.init && node.init.callee && node.init.callee.name === "require";
            const isReactRequire = node.init && node.init.arguments && node.init.arguments.length && typeof MODULES[node.init.arguments[0].value] !== "undefined";
            const isDestructuring = node.id && node.id.type === "ObjectPattern";
            if (!(isDestructuring && reactModuleName) && !(isDestructuring && isRequire && isReactRequire)) {
              return;
            }
            node.id.properties.filter((p) => p.type !== "RestElement" && p.key).forEach((property) => {
              checkDeprecation(node, `${reactModuleName || pragma}.${property.key.name}`, property);
            });
          },
          ClassDeclaration: checkLifeCycleMethods,
          ClassExpression: checkLifeCycleMethods,
          ObjectExpression: checkLifeCycleMethods
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.findlast@1.2.5/node_modules/array.prototype.findlast/implementation.js
var require_implementation26 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.findlast@1.2.5/node_modules/array.prototype.findlast/implementation.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var Call = require_Call();
    var Get = require_Get();
    var IsCallable = require_IsCallable();
    var LengthOfArrayLike = require_LengthOfArrayLike2();
    var ToBoolean = require_ToBoolean();
    var ToObject = require_ToObject();
    var ToString = require_ToString();
    module.exports = function findLast(predicate) {
      var O = ToObject(this);
      var len = LengthOfArrayLike(O);
      if (!IsCallable(predicate)) {
        throw new $TypeError("predicate must be a function");
      }
      var thisArg;
      if (arguments.length > 1) {
        thisArg = arguments[1];
      }
      var k = len - 1;
      while (k >= 0) {
        var Pk = ToString(k);
        var kValue = Get(O, Pk);
        var testResult = ToBoolean(Call(predicate, thisArg, [kValue, k, O]));
        if (testResult) {
          return kValue;
        }
        k -= 1;
      }
      return void 0;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.findlast@1.2.5/node_modules/array.prototype.findlast/polyfill.js
var require_polyfill24 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.findlast@1.2.5/node_modules/array.prototype.findlast/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation26();
    module.exports = function getPolyfill() {
      return Array.prototype.findLast || implementation;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.findlast@1.2.5/node_modules/array.prototype.findlast/shim.js
var require_shim23 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.findlast@1.2.5/node_modules/array.prototype.findlast/shim.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var getPolyfill = require_polyfill24();
    var shimUnscopables = require_es_shim_unscopables();
    module.exports = function shimFindLast() {
      var polyfill = getPolyfill();
      define(
        Array.prototype,
        { findLast: polyfill },
        { findLast: function() {
          return Array.prototype.findLast !== polyfill;
        } }
      );
      shimUnscopables("findLast");
      return polyfill;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.findlast@1.2.5/node_modules/array.prototype.findlast/index.js
var require_array_prototype5 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/array.prototype.findlast@1.2.5/node_modules/array.prototype.findlast/index.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var callBind = require_call_bind();
    var callBound = require_callBound();
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var implementation = require_implementation26();
    var getPolyfill = require_polyfill24();
    var polyfill = getPolyfill();
    var shim = require_shim23();
    var $slice = callBound("Array.prototype.slice");
    var bound = callBind.apply(polyfill);
    var boundFindLast = function findLast(array, predicate) {
      RequireObjectCoercible(array);
      return bound(array, $slice(arguments, 1));
    };
    define(boundFindLast, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = boundFindLast;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/makeNoMethodSetStateRule.js
var require_makeNoMethodSetStateRule = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/makeNoMethodSetStateRule.js"(exports, module) {
    "use strict";
    var findLast = require_array_prototype5();
    var docsUrl = require_docsUrl();
    var report = require_report();
    var getAncestors = require_eslint().getAncestors;
    var testReactVersion = require_version().testReactVersion;
    function mapTitle(methodName) {
      const map = {
        componentDidMount: "did-mount",
        componentDidUpdate: "did-update",
        componentWillUpdate: "will-update"
      };
      const title = map[methodName];
      if (!title) {
        throw Error(`No docsUrl for '${methodName}'`);
      }
      return `no-${title}-set-state`;
    }
    var messages = {
      noSetState: "Do not use setState in {{name}}"
    };
    var methodNoopsAsOf = {
      componentDidMount: ">= 16.3.0",
      componentDidUpdate: ">= 16.3.0"
    };
    function shouldBeNoop(context, methodName) {
      return methodName in methodNoopsAsOf && testReactVersion(context, methodNoopsAsOf[methodName]) && !testReactVersion(context, "999.999.999");
    }
    module.exports = function makeNoMethodSetStateRule(methodName, shouldCheckUnsafeCb) {
      return {
        meta: {
          docs: {
            description: `Disallow usage of setState in ${methodName}`,
            category: "Best Practices",
            recommended: false,
            url: docsUrl(mapTitle(methodName))
          },
          messages,
          schema: [{
            enum: ["disallow-in-func"]
          }]
        },
        create(context) {
          const mode = context.options[0] || "allow-in-func";
          function nameMatches(name) {
            if (name === methodName) {
              return true;
            }
            if (typeof shouldCheckUnsafeCb === "function" && shouldCheckUnsafeCb(context)) {
              return name === `UNSAFE_${methodName}`;
            }
            return false;
          }
          if (shouldBeNoop(context, methodName)) {
            return {};
          }
          return {
            CallExpression(node) {
              const callee = node.callee;
              if (callee.type !== "MemberExpression" || callee.object.type !== "ThisExpression" || callee.property.name !== "setState") {
                return;
              }
              const ancestors = getAncestors(context, node);
              let depth = 0;
              findLast(ancestors, (ancestor) => {
                if (/Function(Expression|Declaration)$/.test(ancestor.type)) {
                  depth += 1;
                }
                if (ancestor.type !== "Property" && ancestor.type !== "MethodDefinition" && ancestor.type !== "ClassProperty" && ancestor.type !== "PropertyDefinition" || !nameMatches(ancestor.key.name) || mode !== "disallow-in-func" && depth > 1) {
                  return false;
                }
                report(context, messages.noSetState, "noSetState", {
                  node: callee,
                  data: {
                    name: ancestor.key.name
                  }
                });
                return true;
              });
            }
          };
        }
      };
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-did-mount-set-state.js
var require_no_did_mount_set_state = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-did-mount-set-state.js"(exports, module) {
    "use strict";
    var makeNoMethodSetStateRule = require_makeNoMethodSetStateRule();
    module.exports = makeNoMethodSetStateRule("componentDidMount");
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-did-update-set-state.js
var require_no_did_update_set_state = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-did-update-set-state.js"(exports, module) {
    "use strict";
    var makeNoMethodSetStateRule = require_makeNoMethodSetStateRule();
    module.exports = makeNoMethodSetStateRule("componentDidUpdate");
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-direct-mutation-state.js
var require_no_direct_mutation_state = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-direct-mutation-state.js"(exports, module) {
    "use strict";
    var values = require_object3();
    var Components = require_Components();
    var componentUtil = require_componentUtil();
    var docsUrl = require_docsUrl();
    var report = require_report();
    var messages = {
      noDirectMutation: "Do not mutate state directly. Use setState()."
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow direct mutation of this.state",
          category: "Possible Errors",
          recommended: true,
          url: docsUrl("no-direct-mutation-state")
        },
        messages
      },
      create: Components.detect((context, components, utils) => {
        function isValid(component) {
          return Boolean(component && !component.mutateSetState);
        }
        function reportMutations(component) {
          let mutation;
          for (let i = 0, j = component.mutations.length; i < j; i++) {
            mutation = component.mutations[i];
            report(context, messages.noDirectMutation, "noDirectMutation", {
              node: mutation
            });
          }
        }
        function getOuterMemberExpression(node) {
          while (node.object && node.object.property) {
            node = node.object;
          }
          return node;
        }
        function shouldIgnoreComponent(component) {
          return !component || component.inConstructor && !component.inCallExpression;
        }
        return {
          MethodDefinition(node) {
            if (node.kind === "constructor") {
              components.set(node, {
                inConstructor: true
              });
            }
          },
          CallExpression(node) {
            components.set(node, {
              inCallExpression: true
            });
          },
          AssignmentExpression(node) {
            const component = components.get(utils.getParentComponent(node));
            if (shouldIgnoreComponent(component) || !node.left || !node.left.object) {
              return;
            }
            const item = getOuterMemberExpression(node.left);
            if (componentUtil.isStateMemberExpression(item)) {
              const mutations = component && component.mutations || [];
              mutations.push(node.left.object);
              components.set(node, {
                mutateSetState: true,
                mutations
              });
            }
          },
          UpdateExpression(node) {
            const component = components.get(utils.getParentComponent(node));
            if (shouldIgnoreComponent(component) || node.argument.type !== "MemberExpression") {
              return;
            }
            const item = getOuterMemberExpression(node.argument);
            if (componentUtil.isStateMemberExpression(item)) {
              const mutations = component && component.mutations || [];
              mutations.push(item);
              components.set(node, {
                mutateSetState: true,
                mutations
              });
            }
          },
          "CallExpression:exit"(node) {
            components.set(node, {
              inCallExpression: false
            });
          },
          "MethodDefinition:exit"(node) {
            if (node.kind === "constructor") {
              components.set(node, {
                inConstructor: false
              });
            }
          },
          "Program:exit"() {
            values(components.list()).filter((component) => !isValid(component)).forEach((component) => {
              reportMutations(component);
            });
          }
        };
      })
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-find-dom-node.js
var require_no_find_dom_node = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-find-dom-node.js"(exports, module) {
    "use strict";
    var docsUrl = require_docsUrl();
    var report = require_report();
    var messages = {
      noFindDOMNode: "Do not use findDOMNode. It doesn\u2019t work with function components and is deprecated in StrictMode. See https://reactjs.org/docs/react-dom.html#finddomnode"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow usage of findDOMNode",
          category: "Best Practices",
          recommended: true,
          url: docsUrl("no-find-dom-node")
        },
        messages,
        schema: []
      },
      create(context) {
        return {
          CallExpression(node) {
            const callee = node.callee;
            const isfindDOMNode = callee.name === "findDOMNode" || callee.property && callee.property.name === "findDOMNode";
            if (!isfindDOMNode) {
              return;
            }
            report(context, messages.noFindDOMNode, "noFindDOMNode", {
              node: callee
            });
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-is-mounted.js
var require_no_is_mounted = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-is-mounted.js"(exports, module) {
    "use strict";
    var docsUrl = require_docsUrl();
    var getAncestors = require_eslint().getAncestors;
    var report = require_report();
    var messages = {
      noIsMounted: "Do not use isMounted"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow usage of isMounted",
          category: "Best Practices",
          recommended: true,
          url: docsUrl("no-is-mounted")
        },
        messages,
        schema: []
      },
      create(context) {
        return {
          CallExpression(node) {
            const callee = node.callee;
            if (callee.type !== "MemberExpression") {
              return;
            }
            if (callee.object.type !== "ThisExpression" || callee.property.name !== "isMounted") {
              return;
            }
            const ancestors = getAncestors(context, node);
            for (let i = 0, j = ancestors.length; i < j; i++) {
              if (ancestors[i].type === "Property" || ancestors[i].type === "MethodDefinition") {
                report(context, messages.noIsMounted, "noIsMounted", {
                  node: callee
                });
                break;
              }
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-multi-comp.js
var require_no_multi_comp = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-multi-comp.js"(exports, module) {
    "use strict";
    var values = require_object3();
    var Components = require_Components();
    var docsUrl = require_docsUrl();
    var report = require_report();
    var messages = {
      onlyOneComponent: "Declare only one React component per file"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow multiple component definition per file",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("no-multi-comp")
        },
        messages,
        schema: [{
          type: "object",
          properties: {
            ignoreStateless: {
              default: false,
              type: "boolean"
            }
          },
          additionalProperties: false
        }]
      },
      create: Components.detect((context, components, utils) => {
        const configuration = context.options[0] || {};
        const ignoreStateless = configuration.ignoreStateless || false;
        function isIgnored(component) {
          return ignoreStateless && (/Function/.test(component.node.type) || utils.isPragmaComponentWrapper(component.node));
        }
        return {
          "Program:exit"() {
            if (components.length() <= 1) {
              return;
            }
            values(components.list()).filter((component) => !isIgnored(component)).slice(1).forEach((component) => {
              report(context, messages.onlyOneComponent, "onlyOneComponent", {
                node: component.node
              });
            });
          }
        };
      })
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-namespace.js
var require_no_namespace = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-namespace.js"(exports, module) {
    "use strict";
    var elementType = require_elementType2();
    var docsUrl = require_docsUrl();
    var isCreateElement = require_isCreateElement();
    var report = require_report();
    var messages = {
      noNamespace: "React component {{name}} must not be in a namespace, as React does not support them"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce that namespaces are not used in React elements",
          category: "Possible Errors",
          recommended: false,
          url: docsUrl("no-namespace")
        },
        messages,
        schema: []
      },
      create(context) {
        return {
          CallExpression(node) {
            if (isCreateElement(context, node) && node.arguments.length > 0 && node.arguments[0].type === "Literal") {
              const name = node.arguments[0].value;
              if (typeof name !== "string" || name.indexOf(":") === -1)
                return void 0;
              report(context, messages.noNamespace, "noNamespace", {
                node,
                data: {
                  name
                }
              });
            }
          },
          JSXOpeningElement(node) {
            const name = elementType(node);
            if (typeof name !== "string" || name.indexOf(":") === -1)
              return void 0;
            report(context, messages.noNamespace, "noNamespace", {
              node,
              data: {
                name
              }
            });
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-set-state.js
var require_no_set_state = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-set-state.js"(exports, module) {
    "use strict";
    var values = require_object3();
    var Components = require_Components();
    var docsUrl = require_docsUrl();
    var report = require_report();
    var messages = {
      noSetState: "Do not use setState"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow usage of setState",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("no-set-state")
        },
        messages,
        schema: []
      },
      create: Components.detect((context, components, utils) => {
        function isValid(component) {
          return Boolean(component && !component.useSetState);
        }
        function reportSetStateUsages(component) {
          let setStateUsage;
          for (let i = 0, j = component.setStateUsages.length; i < j; i++) {
            setStateUsage = component.setStateUsages[i];
            report(context, messages.noSetState, "noSetState", {
              node: setStateUsage
            });
          }
        }
        return {
          CallExpression(node) {
            const callee = node.callee;
            if (callee.type !== "MemberExpression" || callee.object.type !== "ThisExpression" || callee.property.name !== "setState") {
              return;
            }
            const component = components.get(utils.getParentComponent(node));
            const setStateUsages = component && component.setStateUsages || [];
            setStateUsages.push(callee);
            components.set(node, {
              useSetState: true,
              setStateUsages
            });
          },
          "Program:exit"() {
            values(components.list()).filter((component) => !isValid(component)).forEach((component) => {
              reportSetStateUsages(component);
            });
          }
        };
      })
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-string-refs.js
var require_no_string_refs = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-string-refs.js"(exports, module) {
    "use strict";
    var componentUtil = require_componentUtil();
    var docsUrl = require_docsUrl();
    var report = require_report();
    var messages = {
      thisRefsDeprecated: "Using this.refs is deprecated.",
      stringInRefDeprecated: "Using string literals in ref attributes is deprecated."
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow using string references",
          category: "Best Practices",
          recommended: true,
          url: docsUrl("no-string-refs")
        },
        messages,
        schema: [{
          type: "object",
          properties: {
            noTemplateLiterals: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }]
      },
      create(context) {
        const detectTemplateLiterals = context.options[0] ? context.options[0].noTemplateLiterals : false;
        function isRefsUsage(node) {
          return !!((componentUtil.getParentES6Component(context, node) || componentUtil.getParentES5Component(context, node)) && node.object.type === "ThisExpression" && node.property.name === "refs");
        }
        function isRefAttribute(node) {
          return !!(node.type === "JSXAttribute" && node.name && node.name.name === "ref");
        }
        function containsStringLiteral(node) {
          return !!(node.value && node.value.type === "Literal" && typeof node.value.value === "string");
        }
        function containsStringExpressionContainer(node) {
          return !!(node.value && node.value.type === "JSXExpressionContainer" && node.value.expression && (node.value.expression.type === "Literal" && typeof node.value.expression.value === "string" || node.value.expression.type === "TemplateLiteral" && detectTemplateLiterals));
        }
        return {
          MemberExpression(node) {
            if (isRefsUsage(node)) {
              report(context, messages.thisRefsDeprecated, "thisRefsDeprecated", {
                node
              });
            }
          },
          JSXAttribute(node) {
            if (isRefAttribute(node) && (containsStringLiteral(node) || containsStringExpressionContainer(node))) {
              report(context, messages.stringInRefDeprecated, "stringInRefDeprecated", {
                node
              });
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-redundant-should-component-update.js
var require_no_redundant_should_component_update = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-redundant-should-component-update.js"(exports, module) {
    "use strict";
    var astUtil = require_ast();
    var componentUtil = require_componentUtil();
    var docsUrl = require_docsUrl();
    var report = require_report();
    var messages = {
      noShouldCompUpdate: "{{component}} does not need shouldComponentUpdate when extending React.PureComponent."
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow usage of shouldComponentUpdate when extending React.PureComponent",
          category: "Possible Errors",
          recommended: false,
          url: docsUrl("no-redundant-should-component-update")
        },
        messages,
        schema: []
      },
      create(context) {
        function hasShouldComponentUpdate(node) {
          const properties = astUtil.getComponentProperties(node);
          return properties.some((property) => {
            const name = astUtil.getPropertyName(property);
            return name === "shouldComponentUpdate";
          });
        }
        function getNodeName(node) {
          if (node.id) {
            return node.id.name;
          }
          if (node.parent && node.parent.id) {
            return node.parent.id.name;
          }
          return "";
        }
        function checkForViolation(node) {
          if (componentUtil.isPureComponent(node, context)) {
            const hasScu = hasShouldComponentUpdate(node);
            if (hasScu) {
              const className = getNodeName(node);
              report(context, messages.noShouldCompUpdate, "noShouldCompUpdate", {
                node,
                data: {
                  component: className
                }
              });
            }
          }
        }
        return {
          ClassDeclaration: checkForViolation,
          ClassExpression: checkForViolation
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-render-return-value.js
var require_no_render_return_value = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-render-return-value.js"(exports, module) {
    "use strict";
    var testReactVersion = require_version().testReactVersion;
    var docsUrl = require_docsUrl();
    var report = require_report();
    var messages = {
      noReturnValue: "Do not depend on the return value from {{node}}.render"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow usage of the return value of ReactDOM.render",
          category: "Best Practices",
          recommended: true,
          url: docsUrl("no-render-return-value")
        },
        messages,
        schema: []
      },
      create(context) {
        let calleeObjectName = /^ReactDOM$/;
        if (testReactVersion(context, ">= 15.0.0")) {
          calleeObjectName = /^ReactDOM$/;
        } else if (testReactVersion(context, "^0.14.0")) {
          calleeObjectName = /^React(DOM)?$/;
        } else if (testReactVersion(context, "^0.13.0")) {
          calleeObjectName = /^React$/;
        }
        return {
          CallExpression(node) {
            const callee = node.callee;
            const parent = node.parent;
            if (callee.type !== "MemberExpression") {
              return;
            }
            if (callee.object.type !== "Identifier" || !calleeObjectName.test(callee.object.name) || callee.property.name !== "render") {
              return;
            }
            if (parent.type === "VariableDeclarator" || parent.type === "Property" || parent.type === "ReturnStatement" || parent.type === "ArrowFunctionExpression" || parent.type === "AssignmentExpression") {
              report(context, messages.noReturnValue, "noReturnValue", {
                node: callee,
                data: {
                  node: callee.object.name
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-this-in-sfc.js
var require_no_this_in_sfc = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-this-in-sfc.js"(exports, module) {
    "use strict";
    var Components = require_Components();
    var docsUrl = require_docsUrl();
    var report = require_report();
    var messages = {
      noThisInSFC: "Stateless functional components should not use `this`"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow `this` from being used in stateless functional components",
          category: "Possible Errors",
          recommended: false,
          url: docsUrl("no-this-in-sfc")
        },
        messages,
        schema: []
      },
      create: Components.detect((context, components, utils) => ({
        MemberExpression(node) {
          if (node.object.type === "ThisExpression") {
            const component = components.get(utils.getParentStatelessComponent(node));
            if (!component || component.node && component.node.parent && component.node.parent.type === "Property") {
              return;
            }
            report(context, messages.noThisInSFC, "noThisInSFC", {
              node
            });
          }
        }
      }))
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/react-is@16.13.1/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/react-is@16.13.1/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/react-is@16.13.1/node_modules/react-is/index.js
var require_react_is = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/react-is@16.13.1/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object-assign@4.1.1/node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/object-assign@4.1.1/node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-typos.js
var require_no_typos = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-typos.js"(exports, module) {
    "use strict";
    var PROP_TYPES = Object.keys(require_prop_types());
    var Components = require_Components();
    var docsUrl = require_docsUrl();
    var componentUtil = require_componentUtil();
    var report = require_report();
    var lifecycleMethods = require_lifecycleMethods();
    var STATIC_CLASS_PROPERTIES = ["propTypes", "contextTypes", "childContextTypes", "defaultProps"];
    var messages = {
      typoPropTypeChain: "Typo in prop type chain qualifier: {{name}}",
      typoPropType: "Typo in declared prop type: {{name}}",
      typoStaticClassProp: "Typo in static class property declaration",
      typoPropDeclaration: "Typo in property declaration",
      typoLifecycleMethod: "Typo in component lifecycle method declaration: {{actual}} should be {{expected}}",
      staticLifecycleMethod: "Lifecycle method should be static: {{method}}",
      noPropTypesBinding: "`'prop-types'` imported without a local `PropTypes` binding.",
      noReactBinding: "`'react'` imported without a local `React` binding."
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow common typos",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("no-typos")
        },
        messages,
        schema: []
      },
      create: Components.detect((context, components, utils) => {
        let propTypesPackageName = null;
        let reactPackageName = null;
        function checkValidPropTypeQualifier(node) {
          if (node.name !== "isRequired") {
            report(context, messages.typoPropTypeChain, "typoPropTypeChain", {
              node,
              data: { name: node.name }
            });
          }
        }
        function checkValidPropType(node) {
          if (node.name && !PROP_TYPES.some((propTypeName) => propTypeName === node.name)) {
            report(context, messages.typoPropType, "typoPropType", {
              node,
              data: { name: node.name }
            });
          }
        }
        function isPropTypesPackage(node) {
          return node.type === "Identifier" && node.name === propTypesPackageName || node.type === "MemberExpression" && node.property.name === "PropTypes" && node.object.name === reactPackageName;
        }
        function checkValidCallExpression(node) {
          const callee = node.callee;
          if (callee.type === "MemberExpression" && callee.property.name === "shape") {
            checkValidPropObject(node.arguments[0]);
          } else if (callee.type === "MemberExpression" && callee.property.name === "oneOfType") {
            const args = node.arguments[0];
            if (args && args.type === "ArrayExpression") {
              args.elements.forEach((el) => {
                checkValidProp(el);
              });
            }
          }
        }
        function checkValidProp(node) {
          if (!propTypesPackageName && !reactPackageName || !node) {
            return;
          }
          if (node.type === "MemberExpression") {
            if (node.object.type === "MemberExpression" && isPropTypesPackage(node.object.object)) {
              checkValidPropType(node.object.property);
              checkValidPropTypeQualifier(node.property);
            } else if (isPropTypesPackage(node.object) && node.property.name !== "isRequired") {
              checkValidPropType(node.property);
            } else if (node.object.type === "CallExpression") {
              checkValidPropTypeQualifier(node.property);
              checkValidCallExpression(node.object);
            }
          } else if (node.type === "CallExpression") {
            checkValidCallExpression(node);
          }
        }
        function checkValidPropObject(node) {
          if (node && node.type === "ObjectExpression") {
            node.properties.forEach((prop) => checkValidProp(prop.value));
          }
        }
        function reportErrorIfPropertyCasingTypo(propertyValue, propertyKey, isClassProperty) {
          const propertyName = propertyKey.name;
          if (propertyName === "propTypes" || propertyName === "contextTypes" || propertyName === "childContextTypes") {
            checkValidPropObject(propertyValue);
          }
          STATIC_CLASS_PROPERTIES.forEach((CLASS_PROP) => {
            if (propertyName && CLASS_PROP.toLowerCase() === propertyName.toLowerCase() && CLASS_PROP !== propertyName) {
              const messageId = isClassProperty ? "typoStaticClassProp" : "typoPropDeclaration";
              report(context, messages[messageId], messageId, {
                node: propertyKey
              });
            }
          });
        }
        function reportErrorIfLifecycleMethodCasingTypo(node) {
          const key = node.key;
          let nodeKeyName = key.name;
          if (key.type === "Literal") {
            nodeKeyName = key.value;
          }
          if (key.type === "PrivateName" || node.computed && typeof nodeKeyName !== "string") {
            return;
          }
          lifecycleMethods.static.forEach((method) => {
            if (!node.static && nodeKeyName && nodeKeyName.toLowerCase() === method.toLowerCase()) {
              report(context, messages.staticLifecycleMethod, "staticLifecycleMethod", {
                node,
                data: {
                  method: nodeKeyName
                }
              });
            }
          });
          lifecycleMethods.instance.concat(lifecycleMethods.static).forEach((method) => {
            if (nodeKeyName && method.toLowerCase() === nodeKeyName.toLowerCase() && method !== nodeKeyName) {
              report(context, messages.typoLifecycleMethod, "typoLifecycleMethod", {
                node,
                data: { actual: nodeKeyName, expected: method }
              });
            }
          });
        }
        return {
          ImportDeclaration(node) {
            if (node.source && node.source.value === "prop-types") {
              if (node.specifiers.length > 0) {
                propTypesPackageName = node.specifiers[0].local.name;
              } else {
                report(context, messages.noPropTypesBinding, "noPropTypesBinding", {
                  node
                });
              }
            } else if (node.source && node.source.value === "react") {
              if (node.specifiers.length > 0) {
                reactPackageName = node.specifiers[0].local.name;
              } else {
                report(context, messages.noReactBinding, "noReactBinding", {
                  node
                });
              }
              if (node.specifiers.length >= 1) {
                const propTypesSpecifier = node.specifiers.find((specifier) => specifier.imported && specifier.imported.name === "PropTypes");
                if (propTypesSpecifier) {
                  propTypesPackageName = propTypesSpecifier.local.name;
                }
              }
            }
          },
          "ClassProperty, PropertyDefinition"(node) {
            if (!node.static || !componentUtil.isES6Component(node.parent.parent, context)) {
              return;
            }
            reportErrorIfPropertyCasingTypo(node.value, node.key, true);
          },
          MemberExpression(node) {
            const propertyName = node.property.name;
            if (!propertyName || STATIC_CLASS_PROPERTIES.map((prop) => prop.toLocaleLowerCase()).indexOf(propertyName.toLowerCase()) === -1) {
              return;
            }
            const relatedComponent = utils.getRelatedComponent(node);
            if (relatedComponent && (componentUtil.isES6Component(relatedComponent.node, context) || relatedComponent.node.type !== "ClassDeclaration" && utils.isReturningJSX(relatedComponent.node)) && (node.parent && node.parent.type === "AssignmentExpression" && node.parent.right)) {
              reportErrorIfPropertyCasingTypo(node.parent.right, node.property, true);
            }
          },
          MethodDefinition(node) {
            if (!componentUtil.isES6Component(node.parent.parent, context)) {
              return;
            }
            reportErrorIfLifecycleMethodCasingTypo(node);
          },
          ObjectExpression(node) {
            const component = componentUtil.isES5Component(node, context) && components.get(node);
            if (!component) {
              return;
            }
            node.properties.filter((property) => property.type !== "SpreadElement").forEach((property) => {
              reportErrorIfPropertyCasingTypo(property.value, property.key, false);
              reportErrorIfLifecycleMethodCasingTypo(property);
            });
          }
        };
      })
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-unescaped-entities.js
var require_no_unescaped_entities = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-unescaped-entities.js"(exports, module) {
    "use strict";
    var docsUrl = require_docsUrl();
    var getSourceCode = require_eslint().getSourceCode;
    var jsxUtil = require_jsx();
    var report = require_report();
    var DEFAULTS = [{
      char: ">",
      alternatives: ["&gt;"]
    }, {
      char: '"',
      alternatives: ["&quot;", "&ldquo;", "&#34;", "&rdquo;"]
    }, {
      char: "'",
      alternatives: ["&apos;", "&lsquo;", "&#39;", "&rsquo;"]
    }, {
      char: "}",
      alternatives: ["&#125;"]
    }];
    var messages = {
      unescapedEntity: "HTML entity, `{{entity}}` , must be escaped.",
      unescapedEntityAlts: "`{{entity}}` can be escaped with {{alts}}."
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow unescaped HTML entities from appearing in markup",
          category: "Possible Errors",
          recommended: true,
          url: docsUrl("no-unescaped-entities")
        },
        messages,
        schema: [{
          type: "object",
          properties: {
            forbid: {
              type: "array",
              items: {
                anyOf: [{
                  type: "string"
                }, {
                  type: "object",
                  properties: {
                    char: {
                      type: "string"
                    },
                    alternatives: {
                      type: "array",
                      uniqueItems: true,
                      items: {
                        type: "string"
                      }
                    }
                  }
                }]
              }
            }
          },
          additionalProperties: false
        }]
      },
      create(context) {
        function reportInvalidEntity(node) {
          const configuration = context.options[0] || {};
          const entities = configuration.forbid || DEFAULTS;
          for (let i = node.loc.start.line; i <= node.loc.end.line; i++) {
            let rawLine = getSourceCode(context).lines[i - 1];
            let start = 0;
            let end = rawLine.length;
            if (i === node.loc.start.line) {
              start = node.loc.start.column;
            }
            if (i === node.loc.end.line) {
              end = node.loc.end.column;
            }
            rawLine = rawLine.slice(start, end);
            for (let j = 0; j < entities.length; j++) {
              for (let index = 0; index < rawLine.length; index++) {
                const c = rawLine[index];
                if (typeof entities[j] === "string") {
                  if (c === entities[j]) {
                    report(context, messages.unescapedEntity, "unescapedEntity", {
                      node,
                      loc: { line: i, column: start + index },
                      data: {
                        entity: entities[j]
                      }
                    });
                  }
                } else if (c === entities[j].char) {
                  report(context, messages.unescapedEntityAlts, "unescapedEntityAlts", {
                    node,
                    loc: { line: i, column: start + index },
                    data: {
                      entity: entities[j].char,
                      alts: entities[j].alternatives.map((alt) => `\`${alt}\``).join(", ")
                    }
                  });
                }
              }
            }
          }
        }
        return {
          "Literal, JSXText"(node) {
            if (jsxUtil.isJSX(node.parent)) {
              reportInvalidEntity(node);
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-unknown-property.js
var require_no_unknown_property = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-unknown-property.js"(exports, module) {
    "use strict";
    var has = require_polyfill19()();
    var docsUrl = require_docsUrl();
    var getText = require_eslint().getText;
    var testReactVersion = require_version().testReactVersion;
    var report = require_report();
    var DEFAULTS = {
      ignore: [],
      requireDataLowercase: false
    };
    var DOM_ATTRIBUTE_NAMES = {
      "accept-charset": "acceptCharset",
      class: "className",
      "http-equiv": "httpEquiv",
      crossorigin: "crossOrigin",
      for: "htmlFor",
      nomodule: "noModule"
    };
    var ATTRIBUTE_TAGS_MAP = {
      abbr: ["th", "td"],
      charset: ["meta"],
      checked: ["input"],
      // image is required for SVG support, all other tags are HTML.
      crossOrigin: ["script", "img", "video", "audio", "link", "image"],
      displaystyle: ["math"],
      // https://html.spec.whatwg.org/multipage/links.html#downloading-resources
      download: ["a", "area"],
      fill: [
        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill
        // Fill color
        "altGlyph",
        "circle",
        "ellipse",
        "g",
        "line",
        "marker",
        "mask",
        "path",
        "polygon",
        "polyline",
        "rect",
        "svg",
        "symbol",
        "text",
        "textPath",
        "tref",
        "tspan",
        "use",
        // Animation final state
        "animate",
        "animateColor",
        "animateMotion",
        "animateTransform",
        "set"
      ],
      focusable: ["svg"],
      imageSizes: ["link"],
      imageSrcSet: ["link"],
      property: ["meta"],
      viewBox: ["marker", "pattern", "svg", "symbol", "view"],
      as: ["link"],
      align: ["applet", "caption", "col", "colgroup", "hr", "iframe", "img", "table", "tbody", "td", "tfoot", "th", "thead", "tr"],
      // deprecated, but known
      valign: ["tr", "td", "th", "thead", "tbody", "tfoot", "colgroup", "col"],
      // deprecated, but known
      noModule: ["script"],
      // Media events allowed only on audio and video tags, see https://github.com/facebook/react/blob/256aefbea1449869620fb26f6ec695536ab453f5/CHANGELOG.md#notable-enhancements
      onAbort: ["audio", "video"],
      onCancel: ["dialog"],
      onCanPlay: ["audio", "video"],
      onCanPlayThrough: ["audio", "video"],
      onClose: ["dialog"],
      onDurationChange: ["audio", "video"],
      onEmptied: ["audio", "video"],
      onEncrypted: ["audio", "video"],
      onEnded: ["audio", "video"],
      onError: ["audio", "video", "img", "link", "source", "script", "picture", "iframe"],
      onLoad: ["script", "img", "link", "picture", "iframe", "object", "source"],
      onLoadedData: ["audio", "video"],
      onLoadedMetadata: ["audio", "video"],
      onLoadStart: ["audio", "video"],
      onPause: ["audio", "video"],
      onPlay: ["audio", "video"],
      onPlaying: ["audio", "video"],
      onProgress: ["audio", "video"],
      onRateChange: ["audio", "video"],
      onResize: ["audio", "video"],
      onSeeked: ["audio", "video"],
      onSeeking: ["audio", "video"],
      onStalled: ["audio", "video"],
      onSuspend: ["audio", "video"],
      onTimeUpdate: ["audio", "video"],
      onVolumeChange: ["audio", "video"],
      onWaiting: ["audio", "video"],
      autoPictureInPicture: ["video"],
      controls: ["audio", "video"],
      controlsList: ["audio", "video"],
      disablePictureInPicture: ["video"],
      disableRemotePlayback: ["audio", "video"],
      loop: ["audio", "video"],
      muted: ["audio", "video"],
      playsInline: ["video"],
      allowFullScreen: ["iframe", "video"],
      webkitAllowFullScreen: ["iframe", "video"],
      mozAllowFullScreen: ["iframe", "video"],
      poster: ["video"],
      preload: ["audio", "video"],
      scrolling: ["iframe"],
      returnValue: ["dialog"],
      webkitDirectory: ["input"]
    };
    var SVGDOM_ATTRIBUTE_NAMES = {
      "accent-height": "accentHeight",
      "alignment-baseline": "alignmentBaseline",
      "arabic-form": "arabicForm",
      "baseline-shift": "baselineShift",
      "cap-height": "capHeight",
      "clip-path": "clipPath",
      "clip-rule": "clipRule",
      "color-interpolation": "colorInterpolation",
      "color-interpolation-filters": "colorInterpolationFilters",
      "color-profile": "colorProfile",
      "color-rendering": "colorRendering",
      "dominant-baseline": "dominantBaseline",
      "enable-background": "enableBackground",
      "fill-opacity": "fillOpacity",
      "fill-rule": "fillRule",
      "flood-color": "floodColor",
      "flood-opacity": "floodOpacity",
      "font-family": "fontFamily",
      "font-size": "fontSize",
      "font-size-adjust": "fontSizeAdjust",
      "font-stretch": "fontStretch",
      "font-style": "fontStyle",
      "font-variant": "fontVariant",
      "font-weight": "fontWeight",
      "glyph-name": "glyphName",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      "horiz-adv-x": "horizAdvX",
      "horiz-origin-x": "horizOriginX",
      "image-rendering": "imageRendering",
      "letter-spacing": "letterSpacing",
      "lighting-color": "lightingColor",
      "marker-end": "markerEnd",
      "marker-mid": "markerMid",
      "marker-start": "markerStart",
      "overline-position": "overlinePosition",
      "overline-thickness": "overlineThickness",
      "paint-order": "paintOrder",
      "panose-1": "panose1",
      "pointer-events": "pointerEvents",
      "rendering-intent": "renderingIntent",
      "shape-rendering": "shapeRendering",
      "stop-color": "stopColor",
      "stop-opacity": "stopOpacity",
      "strikethrough-position": "strikethroughPosition",
      "strikethrough-thickness": "strikethroughThickness",
      "stroke-dasharray": "strokeDasharray",
      "stroke-dashoffset": "strokeDashoffset",
      "stroke-linecap": "strokeLinecap",
      "stroke-linejoin": "strokeLinejoin",
      "stroke-miterlimit": "strokeMiterlimit",
      "stroke-opacity": "strokeOpacity",
      "stroke-width": "strokeWidth",
      "text-anchor": "textAnchor",
      "text-decoration": "textDecoration",
      "text-rendering": "textRendering",
      "underline-position": "underlinePosition",
      "underline-thickness": "underlineThickness",
      "unicode-bidi": "unicodeBidi",
      "unicode-range": "unicodeRange",
      "units-per-em": "unitsPerEm",
      "v-alphabetic": "vAlphabetic",
      "v-hanging": "vHanging",
      "v-ideographic": "vIdeographic",
      "v-mathematical": "vMathematical",
      "vector-effect": "vectorEffect",
      "vert-adv-y": "vertAdvY",
      "vert-origin-x": "vertOriginX",
      "vert-origin-y": "vertOriginY",
      "word-spacing": "wordSpacing",
      "writing-mode": "writingMode",
      "x-height": "xHeight",
      "xlink:actuate": "xlinkActuate",
      "xlink:arcrole": "xlinkArcrole",
      "xlink:href": "xlinkHref",
      "xlink:role": "xlinkRole",
      "xlink:show": "xlinkShow",
      "xlink:title": "xlinkTitle",
      "xlink:type": "xlinkType",
      "xml:base": "xmlBase",
      "xml:lang": "xmlLang",
      "xml:space": "xmlSpace"
    };
    var DOM_PROPERTY_NAMES_ONE_WORD = [
      // Global attributes - can be used on any HTML/DOM element
      // See https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes
      "dir",
      "draggable",
      "hidden",
      "id",
      "lang",
      "nonce",
      "part",
      "slot",
      "style",
      "title",
      "translate",
      "inert",
      // Element specific attributes
      // See https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes (includes global attributes too)
      // To be considered if these should be added also to ATTRIBUTE_TAGS_MAP
      "accept",
      "action",
      "allow",
      "alt",
      "as",
      "async",
      "buffered",
      "capture",
      "challenge",
      "cite",
      "code",
      "cols",
      "content",
      "coords",
      "csp",
      "data",
      "decoding",
      "default",
      "defer",
      "disabled",
      "form",
      "headers",
      "height",
      "high",
      "href",
      "icon",
      "importance",
      "integrity",
      "kind",
      "label",
      "language",
      "loading",
      "list",
      "loop",
      "low",
      "manifest",
      "max",
      "media",
      "method",
      "min",
      "multiple",
      "muted",
      "name",
      "open",
      "optimum",
      "pattern",
      "ping",
      "placeholder",
      "poster",
      "preload",
      "profile",
      "rel",
      "required",
      "reversed",
      "role",
      "rows",
      "sandbox",
      "scope",
      "seamless",
      "selected",
      "shape",
      "size",
      "sizes",
      "span",
      "src",
      "start",
      "step",
      "summary",
      "target",
      "type",
      "value",
      "width",
      "wmode",
      "wrap",
      // SVG attributes
      // See https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute
      "accumulate",
      "additive",
      "alphabetic",
      "amplitude",
      "ascent",
      "azimuth",
      "bbox",
      "begin",
      "bias",
      "by",
      "clip",
      "color",
      "cursor",
      "cx",
      "cy",
      "d",
      "decelerate",
      "descent",
      "direction",
      "display",
      "divisor",
      "dur",
      "dx",
      "dy",
      "elevation",
      "end",
      "exponent",
      "fill",
      "filter",
      "format",
      "from",
      "fr",
      "fx",
      "fy",
      "g1",
      "g2",
      "hanging",
      "height",
      "hreflang",
      "ideographic",
      "in",
      "in2",
      "intercept",
      "k",
      "k1",
      "k2",
      "k3",
      "k4",
      "kerning",
      "local",
      "mask",
      "mode",
      "offset",
      "opacity",
      "operator",
      "order",
      "orient",
      "orientation",
      "origin",
      "overflow",
      "path",
      "ping",
      "points",
      "r",
      "radius",
      "rel",
      "restart",
      "result",
      "rotate",
      "rx",
      "ry",
      "scale",
      "seed",
      "slope",
      "spacing",
      "speed",
      "stemh",
      "stemv",
      "string",
      "stroke",
      "to",
      "transform",
      "u1",
      "u2",
      "unicode",
      "values",
      "version",
      "visibility",
      "widths",
      "x",
      "x1",
      "x2",
      "xmlns",
      "y",
      "y1",
      "y2",
      "z",
      // OpenGraph meta tag attributes
      "property",
      // React specific attributes
      "ref",
      "key",
      "children",
      // Non-standard
      "results",
      "security",
      // Video specific
      "controls",
      // popovers
      "popover",
      "popovertarget",
      "popovertargetaction"
    ];
    var DOM_PROPERTY_NAMES_TWO_WORDS = [
      // Global attributes - can be used on any HTML/DOM element
      // See https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes
      "accessKey",
      "autoCapitalize",
      "autoFocus",
      "contentEditable",
      "enterKeyHint",
      "exportParts",
      "inputMode",
      "itemID",
      "itemRef",
      "itemProp",
      "itemScope",
      "itemType",
      "spellCheck",
      "tabIndex",
      // Element specific attributes
      // See https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes (includes global attributes too)
      // To be considered if these should be added also to ATTRIBUTE_TAGS_MAP
      "acceptCharset",
      "autoComplete",
      "autoPlay",
      "border",
      "cellPadding",
      "cellSpacing",
      "classID",
      "codeBase",
      "colSpan",
      "contextMenu",
      "dateTime",
      "encType",
      "formAction",
      "formEncType",
      "formMethod",
      "formNoValidate",
      "formTarget",
      "frameBorder",
      "hrefLang",
      "httpEquiv",
      "imageSizes",
      "imageSrcSet",
      "isMap",
      "keyParams",
      "keyType",
      "marginHeight",
      "marginWidth",
      "maxLength",
      "mediaGroup",
      "minLength",
      "noValidate",
      "onAnimationEnd",
      "onAnimationIteration",
      "onAnimationStart",
      "onBlur",
      "onChange",
      "onClick",
      "onContextMenu",
      "onCopy",
      "onCompositionEnd",
      "onCompositionStart",
      "onCompositionUpdate",
      "onCut",
      "onDoubleClick",
      "onDrag",
      "onDragEnd",
      "onDragEnter",
      "onDragExit",
      "onDragLeave",
      "onError",
      "onFocus",
      "onInput",
      "onKeyDown",
      "onKeyPress",
      "onKeyUp",
      "onLoad",
      "onWheel",
      "onDragOver",
      "onDragStart",
      "onDrop",
      "onMouseDown",
      "onMouseEnter",
      "onMouseLeave",
      "onMouseMove",
      "onMouseOut",
      "onMouseOver",
      "onMouseUp",
      "onPaste",
      "onScroll",
      "onSelect",
      "onSubmit",
      "onToggle",
      "onTransitionEnd",
      "radioGroup",
      "readOnly",
      "referrerPolicy",
      "rowSpan",
      "srcDoc",
      "srcLang",
      "srcSet",
      "useMap",
      "fetchPriority",
      // SVG attributes
      // See https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute
      "crossOrigin",
      "accentHeight",
      "alignmentBaseline",
      "arabicForm",
      "attributeName",
      "attributeType",
      "baseFrequency",
      "baselineShift",
      "baseProfile",
      "calcMode",
      "capHeight",
      "clipPathUnits",
      "clipPath",
      "clipRule",
      "colorInterpolation",
      "colorInterpolationFilters",
      "colorProfile",
      "colorRendering",
      "contentScriptType",
      "contentStyleType",
      "diffuseConstant",
      "dominantBaseline",
      "edgeMode",
      "enableBackground",
      "fillOpacity",
      "fillRule",
      "filterRes",
      "filterUnits",
      "floodColor",
      "floodOpacity",
      "fontFamily",
      "fontSize",
      "fontSizeAdjust",
      "fontStretch",
      "fontStyle",
      "fontVariant",
      "fontWeight",
      "glyphName",
      "glyphOrientationHorizontal",
      "glyphOrientationVertical",
      "glyphRef",
      "gradientTransform",
      "gradientUnits",
      "horizAdvX",
      "horizOriginX",
      "imageRendering",
      "kernelMatrix",
      "kernelUnitLength",
      "keyPoints",
      "keySplines",
      "keyTimes",
      "lengthAdjust",
      "letterSpacing",
      "lightingColor",
      "limitingConeAngle",
      "markerEnd",
      "markerMid",
      "markerStart",
      "markerHeight",
      "markerUnits",
      "markerWidth",
      "maskContentUnits",
      "maskUnits",
      "mathematical",
      "numOctaves",
      "overlinePosition",
      "overlineThickness",
      "panose1",
      "paintOrder",
      "pathLength",
      "patternContentUnits",
      "patternTransform",
      "patternUnits",
      "pointerEvents",
      "pointsAtX",
      "pointsAtY",
      "pointsAtZ",
      "preserveAlpha",
      "preserveAspectRatio",
      "primitiveUnits",
      "referrerPolicy",
      "refX",
      "refY",
      "rendering-intent",
      "repeatCount",
      "repeatDur",
      "requiredExtensions",
      "requiredFeatures",
      "shapeRendering",
      "specularConstant",
      "specularExponent",
      "spreadMethod",
      "startOffset",
      "stdDeviation",
      "stitchTiles",
      "stopColor",
      "stopOpacity",
      "strikethroughPosition",
      "strikethroughThickness",
      "strokeDasharray",
      "strokeDashoffset",
      "strokeLinecap",
      "strokeLinejoin",
      "strokeMiterlimit",
      "strokeOpacity",
      "strokeWidth",
      "surfaceScale",
      "systemLanguage",
      "tableValues",
      "targetX",
      "targetY",
      "textAnchor",
      "textDecoration",
      "textRendering",
      "textLength",
      "transformOrigin",
      "underlinePosition",
      "underlineThickness",
      "unicodeBidi",
      "unicodeRange",
      "unitsPerEm",
      "vAlphabetic",
      "vHanging",
      "vIdeographic",
      "vMathematical",
      "vectorEffect",
      "vertAdvY",
      "vertOriginX",
      "vertOriginY",
      "viewBox",
      "viewTarget",
      "wordSpacing",
      "writingMode",
      "xHeight",
      "xChannelSelector",
      "xlinkActuate",
      "xlinkArcrole",
      "xlinkHref",
      "xlinkRole",
      "xlinkShow",
      "xlinkTitle",
      "xlinkType",
      "xmlBase",
      "xmlLang",
      "xmlnsXlink",
      "xmlSpace",
      "yChannelSelector",
      "zoomAndPan",
      // Safari/Apple specific, no listing available
      "autoCorrect",
      // https://stackoverflow.com/questions/47985384/html-autocorrect-for-text-input-is-not-working
      "autoSave",
      // https://stackoverflow.com/questions/25456396/what-is-autosave-attribute-supposed-to-do-how-do-i-use-it
      // React specific attributes https://reactjs.org/docs/dom-elements.html#differences-in-attributes
      "className",
      "dangerouslySetInnerHTML",
      "defaultValue",
      "defaultChecked",
      "htmlFor",
      // Events' capture events
      "onBeforeInput",
      "onChange",
      "onInvalid",
      "onReset",
      "onTouchCancel",
      "onTouchEnd",
      "onTouchMove",
      "onTouchStart",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "onAbort",
      "onCanPlay",
      "onCanPlayThrough",
      "onDurationChange",
      "onEmptied",
      "onEncrypted",
      "onEnded",
      "onLoadedData",
      "onLoadedMetadata",
      "onLoadStart",
      "onPause",
      "onPlay",
      "onPlaying",
      "onProgress",
      "onRateChange",
      "onResize",
      "onSeeked",
      "onSeeking",
      "onStalled",
      "onSuspend",
      "onTimeUpdate",
      "onVolumeChange",
      "onWaiting",
      "onCopyCapture",
      "onCutCapture",
      "onPasteCapture",
      "onCompositionEndCapture",
      "onCompositionStartCapture",
      "onCompositionUpdateCapture",
      "onFocusCapture",
      "onBlurCapture",
      "onChangeCapture",
      "onBeforeInputCapture",
      "onInputCapture",
      "onResetCapture",
      "onSubmitCapture",
      "onInvalidCapture",
      "onLoadCapture",
      "onErrorCapture",
      "onKeyDownCapture",
      "onKeyPressCapture",
      "onKeyUpCapture",
      "onAbortCapture",
      "onCanPlayCapture",
      "onCanPlayThroughCapture",
      "onDurationChangeCapture",
      "onEmptiedCapture",
      "onEncryptedCapture",
      "onEndedCapture",
      "onLoadedDataCapture",
      "onLoadedMetadataCapture",
      "onLoadStartCapture",
      "onPauseCapture",
      "onPlayCapture",
      "onPlayingCapture",
      "onProgressCapture",
      "onRateChangeCapture",
      "onSeekedCapture",
      "onSeekingCapture",
      "onStalledCapture",
      "onSuspendCapture",
      "onTimeUpdateCapture",
      "onVolumeChangeCapture",
      "onWaitingCapture",
      "onSelectCapture",
      "onTouchCancelCapture",
      "onTouchEndCapture",
      "onTouchMoveCapture",
      "onTouchStartCapture",
      "onScrollCapture",
      "onWheelCapture",
      "onAnimationEndCapture",
      "onAnimationIteration",
      "onAnimationStartCapture",
      "onTransitionEndCapture",
      "onAuxClick",
      "onAuxClickCapture",
      "onClickCapture",
      "onContextMenuCapture",
      "onDoubleClickCapture",
      "onDragCapture",
      "onDragEndCapture",
      "onDragEnterCapture",
      "onDragExitCapture",
      "onDragLeaveCapture",
      "onDragOverCapture",
      "onDragStartCapture",
      "onDropCapture",
      "onMouseDown",
      "onMouseDownCapture",
      "onMouseMoveCapture",
      "onMouseOutCapture",
      "onMouseOverCapture",
      "onMouseUpCapture",
      // Video specific
      "autoPictureInPicture",
      "controlsList",
      "disablePictureInPicture",
      "disableRemotePlayback"
    ];
    var DOM_PROPERTIES_IGNORE_CASE = ["charset", "allowFullScreen", "webkitAllowFullScreen", "mozAllowFullScreen", "webkitDirectory"];
    var ARIA_PROPERTIES = [
      // See https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes
      // Global attributes
      "aria-atomic",
      "aria-braillelabel",
      "aria-brailleroledescription",
      "aria-busy",
      "aria-controls",
      "aria-current",
      "aria-describedby",
      "aria-description",
      "aria-details",
      "aria-disabled",
      "aria-dropeffect",
      "aria-errormessage",
      "aria-flowto",
      "aria-grabbed",
      "aria-haspopup",
      "aria-hidden",
      "aria-invalid",
      "aria-keyshortcuts",
      "aria-label",
      "aria-labelledby",
      "aria-live",
      "aria-owns",
      "aria-relevant",
      "aria-roledescription",
      // Widget attributes
      "aria-autocomplete",
      "aria-checked",
      "aria-expanded",
      "aria-level",
      "aria-modal",
      "aria-multiline",
      "aria-multiselectable",
      "aria-orientation",
      "aria-placeholder",
      "aria-pressed",
      "aria-readonly",
      "aria-required",
      "aria-selected",
      "aria-sort",
      "aria-valuemax",
      "aria-valuemin",
      "aria-valuenow",
      "aria-valuetext",
      // Relationship attributes
      "aria-activedescendant",
      "aria-colcount",
      "aria-colindex",
      "aria-colindextext",
      "aria-colspan",
      "aria-posinset",
      "aria-rowcount",
      "aria-rowindex",
      "aria-rowindextext",
      "aria-rowspan",
      "aria-setsize"
    ];
    var REACT_ON_PROPS = [
      "onGotPointerCapture",
      "onGotPointerCaptureCapture",
      "onLostPointerCapture",
      "onLostPointerCapture",
      "onLostPointerCaptureCapture",
      "onPointerCancel",
      "onPointerCancelCapture",
      "onPointerDown",
      "onPointerDownCapture",
      "onPointerEnter",
      "onPointerEnterCapture",
      "onPointerLeave",
      "onPointerLeaveCapture",
      "onPointerMove",
      "onPointerMoveCapture",
      "onPointerOut",
      "onPointerOutCapture",
      "onPointerOver",
      "onPointerOverCapture",
      "onPointerUp",
      "onPointerUpCapture"
    ];
    function getDOMPropertyNames(context) {
      const ALL_DOM_PROPERTY_NAMES = DOM_PROPERTY_NAMES_TWO_WORDS.concat(DOM_PROPERTY_NAMES_ONE_WORD);
      if (!testReactVersion(context, ">= 16.1.0")) {
        return ALL_DOM_PROPERTY_NAMES.concat("allowTransparency");
      }
      if (testReactVersion(context, ">= 16.4.0")) {
        return ALL_DOM_PROPERTY_NAMES.concat(REACT_ON_PROPS);
      }
      return ALL_DOM_PROPERTY_NAMES;
    }
    function isValidHTMLTagInJSX(childNode) {
      const tagConvention = /^[a-z][^-]*$/;
      if (tagConvention.test(childNode.parent.name.name)) {
        return !childNode.parent.attributes.some((attrNode) => attrNode.type === "JSXAttribute" && attrNode.name.type === "JSXIdentifier" && attrNode.name.name === "is");
      }
      return false;
    }
    function normalizeAttributeCase(name) {
      return DOM_PROPERTIES_IGNORE_CASE.find((element) => element.toLowerCase() === name.toLowerCase()) || name;
    }
    function isValidDataAttribute(name) {
      return !/^data-xml/i.test(name) && /^data-[^:]*$/.test(name);
    }
    function hasUpperCaseCharacter(name) {
      return name.toLowerCase() !== name;
    }
    function isValidAriaAttribute(name) {
      return ARIA_PROPERTIES.some((element) => element === name);
    }
    function getTagName(node) {
      if (node && node.parent && node.parent.name && node.parent.name) {
        return node.parent.name.name;
      }
      return null;
    }
    function tagNameHasDot(node) {
      return !!(node.parent && node.parent.name && node.parent.name.type === "JSXMemberExpression");
    }
    function getStandardName(name, context) {
      if (has(DOM_ATTRIBUTE_NAMES, name)) {
        return DOM_ATTRIBUTE_NAMES[name];
      }
      if (has(SVGDOM_ATTRIBUTE_NAMES, name)) {
        return SVGDOM_ATTRIBUTE_NAMES[name];
      }
      const names = getDOMPropertyNames(context);
      return names.find((element) => element.toLowerCase() === name.toLowerCase());
    }
    var messages = {
      invalidPropOnTag: "Invalid property '{{name}}' found on tag '{{tagName}}', but it is only allowed on: {{allowedTags}}",
      unknownPropWithStandardName: "Unknown property '{{name}}' found, use '{{standardName}}' instead",
      unknownProp: "Unknown property '{{name}}' found",
      dataLowercaseRequired: "React does not recognize data-* props with uppercase characters on a DOM element. Found '{{name}}', use '{{lowerCaseName}}' instead"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow usage of unknown DOM property",
          category: "Possible Errors",
          recommended: true,
          url: docsUrl("no-unknown-property")
        },
        fixable: "code",
        messages,
        schema: [{
          type: "object",
          properties: {
            ignore: {
              type: "array",
              items: {
                type: "string"
              }
            },
            requireDataLowercase: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }]
      },
      create(context) {
        function getIgnoreConfig() {
          return context.options[0] && context.options[0].ignore || DEFAULTS.ignore;
        }
        function getRequireDataLowercase() {
          return context.options[0] && typeof context.options[0].requireDataLowercase !== "undefined" ? !!context.options[0].requireDataLowercase : DEFAULTS.requireDataLowercase;
        }
        return {
          JSXAttribute(node) {
            const ignoreNames = getIgnoreConfig();
            const actualName = getText(context, node.name);
            if (ignoreNames.indexOf(actualName) >= 0) {
              return;
            }
            const name = normalizeAttributeCase(actualName);
            if (tagNameHasDot(node)) {
              return;
            }
            if (isValidDataAttribute(name)) {
              if (getRequireDataLowercase() && hasUpperCaseCharacter(name)) {
                report(context, messages.dataLowercaseRequired, "dataLowercaseRequired", {
                  node,
                  data: {
                    name: actualName,
                    lowerCaseName: actualName.toLowerCase()
                  }
                });
              }
              return;
            }
            if (isValidAriaAttribute(name)) {
              return;
            }
            const tagName = getTagName(node);
            if (tagName === "fbt" || tagName === "fbs") {
              return;
            }
            if (!isValidHTMLTagInJSX(node)) {
              return;
            }
            const allowedTags = has(ATTRIBUTE_TAGS_MAP, name) ? ATTRIBUTE_TAGS_MAP[name] : null;
            if (tagName && allowedTags) {
              if (allowedTags.indexOf(tagName) === -1) {
                report(context, messages.invalidPropOnTag, "invalidPropOnTag", {
                  node,
                  data: {
                    name: actualName,
                    tagName,
                    allowedTags: allowedTags.join(", ")
                  }
                });
              }
              return;
            }
            const standardName = getStandardName(name, context);
            const hasStandardNameButIsNotUsed = standardName && standardName !== name;
            const usesStandardName = standardName && standardName === name;
            if (usesStandardName) {
              return;
            }
            if (hasStandardNameButIsNotUsed) {
              report(context, messages.unknownPropWithStandardName, "unknownPropWithStandardName", {
                node,
                data: {
                  name: actualName,
                  standardName
                },
                fix(fixer) {
                  return fixer.replaceText(node.name, standardName);
                }
              });
              return;
            }
            report(context, messages.unknownProp, "unknownProp", {
              node,
              data: {
                name: actualName
              }
            });
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-unsafe.js
var require_no_unsafe = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-unsafe.js"(exports, module) {
    "use strict";
    var astUtil = require_ast();
    var componentUtil = require_componentUtil();
    var docsUrl = require_docsUrl();
    var testReactVersion = require_version().testReactVersion;
    var report = require_report();
    var messages = {
      unsafeMethod: "{{method}} is unsafe for use in async rendering. Update the component to use {{newMethod}} instead. {{details}}"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow usage of unsafe lifecycle methods",
          category: "Best Practices",
          recommended: false,
          url: docsUrl("no-unsafe")
        },
        messages,
        schema: [
          {
            type: "object",
            properties: {
              checkAliases: {
                default: false,
                type: "boolean"
              }
            },
            additionalProperties: false
          }
        ]
      },
      create(context) {
        const config = context.options[0] || {};
        const checkAliases = config.checkAliases || false;
        const isApplicable = testReactVersion(context, ">= 16.3.0");
        if (!isApplicable) {
          return {};
        }
        const unsafe = {
          UNSAFE_componentWillMount: {
            newMethod: "componentDidMount",
            details: "See https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html."
          },
          UNSAFE_componentWillReceiveProps: {
            newMethod: "getDerivedStateFromProps",
            details: "See https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html."
          },
          UNSAFE_componentWillUpdate: {
            newMethod: "componentDidUpdate",
            details: "See https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html."
          }
        };
        if (checkAliases) {
          unsafe.componentWillMount = unsafe.UNSAFE_componentWillMount;
          unsafe.componentWillReceiveProps = unsafe.UNSAFE_componentWillReceiveProps;
          unsafe.componentWillUpdate = unsafe.UNSAFE_componentWillUpdate;
        }
        function getUnsafeMethods() {
          return Object.keys(unsafe);
        }
        function isUnsafe(method) {
          const unsafeMethods = getUnsafeMethods();
          return unsafeMethods.indexOf(method) !== -1;
        }
        function checkUnsafe(node, method) {
          if (!isUnsafe(method)) {
            return;
          }
          const meta = unsafe[method];
          const newMethod = meta.newMethod;
          const details = meta.details;
          const propertyNode = astUtil.getComponentProperties(node).find((property) => astUtil.getPropertyName(property) === method);
          report(context, messages.unsafeMethod, "unsafeMethod", {
            node: propertyNode,
            data: {
              method,
              newMethod,
              details
            }
          });
        }
        function getLifeCycleMethods(node) {
          const properties = astUtil.getComponentProperties(node);
          return properties.map((property) => astUtil.getPropertyName(property));
        }
        function checkLifeCycleMethods(node) {
          if (componentUtil.isES5Component(node, context) || componentUtil.isES6Component(node, context)) {
            const methods = getLifeCycleMethods(node);
            methods.sort((a, b) => a.localeCompare(b)).forEach((method) => checkUnsafe(node, method));
          }
        }
        return {
          ClassDeclaration: checkLifeCycleMethods,
          ClassExpression: checkLifeCycleMethods,
          ObjectExpression: checkLifeCycleMethods
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-unstable-nested-components.js
var require_no_unstable_nested_components = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-unstable-nested-components.js"(exports, module) {
    "use strict";
    var Components = require_Components();
    var docsUrl = require_docsUrl();
    var isCreateElement = require_isCreateElement();
    var report = require_report();
    var COMPONENT_AS_PROPS_INFO = " If you want to allow component creation in props, set allowAsProps option to true.";
    var HOOK_REGEXP = /^use[A-Z0-9].*$/;
    function generateErrorMessageWithParentName(parentName) {
      return `Do not define components during render. React will see a new component type on every render and destroy the entire subtree\u2019s DOM nodes and state (https://reactjs.org/docs/reconciliation.html#elements-of-different-types). Instead, move this component definition out of the parent component${parentName ? ` \u201C${parentName}\u201D ` : " "}and pass data as props.`;
    }
    function startsWithRender(text) {
      return (text || "").startsWith("render");
    }
    function getClosestMatchingParent(node, context, matcher) {
      if (!node || !node.parent || node.parent.type === "Program") {
        return;
      }
      if (matcher(node.parent, context)) {
        return node.parent;
      }
      return getClosestMatchingParent(node.parent, context, matcher);
    }
    function isCreateElementMatcher(node, context) {
      return node && node.type === "CallExpression" && isCreateElement(context, node);
    }
    function isObjectExpressionMatcher(node) {
      return node && node.type === "ObjectExpression";
    }
    function isJSXExpressionContainerMatcher(node) {
      return node && node.type === "JSXExpressionContainer";
    }
    function isJSXAttributeOfExpressionContainerMatcher(node) {
      return node && node.type === "JSXAttribute" && node.value && node.value.type === "JSXExpressionContainer";
    }
    function isPropertyOfObjectExpressionMatcher(node) {
      return node && node.parent && node.parent.type === "Property";
    }
    function isCallExpressionMatcher(node) {
      return node && node.type === "CallExpression";
    }
    function isMapCall(node) {
      return node && node.callee && node.callee.property && node.callee.property.name === "map";
    }
    function isReturnStatementOfHook(node, context) {
      if (!node || !node.parent || node.parent.type !== "ReturnStatement") {
        return false;
      }
      const callExpression = getClosestMatchingParent(node, context, isCallExpressionMatcher);
      return callExpression && callExpression.callee && HOOK_REGEXP.test(callExpression.callee.name);
    }
    function isComponentInRenderProp(node, context) {
      if (node && node.parent && node.parent.type === "Property" && node.parent.key && startsWithRender(node.parent.key.name)) {
        return true;
      }
      if (node && node.parent && node.parent.type === "JSXExpressionContainer" && node.parent.parent && node.parent.parent.type === "JSXElement") {
        return true;
      }
      const jsxExpressionContainer = getClosestMatchingParent(node, context, isJSXExpressionContainerMatcher);
      if (jsxExpressionContainer && jsxExpressionContainer.parent && jsxExpressionContainer.parent.type === "JSXAttribute" && jsxExpressionContainer.parent.name && jsxExpressionContainer.parent.name.type === "JSXIdentifier") {
        const propName = jsxExpressionContainer.parent.name.name;
        if (startsWithRender(propName)) {
          return true;
        }
        if (propName === "children") {
          return true;
        }
      }
      return false;
    }
    function isDirectValueOfRenderProperty(node) {
      return node && node.parent && node.parent.type === "Property" && node.parent.key && node.parent.key.type === "Identifier" && startsWithRender(node.parent.key.name);
    }
    function resolveComponentName(node) {
      const parentName = node.id && node.id.name;
      if (parentName)
        return parentName;
      return node.type === "ArrowFunctionExpression" && node.parent && node.parent.id && node.parent.id.name;
    }
    module.exports = {
      meta: {
        docs: {
          description: "Disallow creating unstable components inside components",
          category: "Possible Errors",
          recommended: false,
          url: docsUrl("no-unstable-nested-components")
        },
        schema: [{
          type: "object",
          properties: {
            customValidators: {
              type: "array",
              items: {
                type: "string"
              }
            },
            allowAsProps: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }]
      },
      create: Components.detect((context, components, utils) => {
        const allowAsProps = context.options.some((option) => option && option.allowAsProps);
        function isInsideRenderMethod(node) {
          const parentComponent = utils.getParentComponent(node);
          if (!parentComponent || parentComponent.type !== "ClassDeclaration") {
            return false;
          }
          return node && node.parent && node.parent.type === "MethodDefinition" && node.parent.key && node.parent.key.name === "render";
        }
        function isFunctionComponentInsideClassComponent(node) {
          const parentComponent = utils.getParentComponent(node);
          const parentStatelessComponent = utils.getParentStatelessComponent(node);
          return parentComponent && parentStatelessComponent && parentComponent.type === "ClassDeclaration" && utils.getStatelessComponent(parentStatelessComponent) && utils.isReturningJSX(node);
        }
        function isComponentInsideCreateElementsProp(node) {
          if (!components.get(node)) {
            return false;
          }
          const createElementParent = getClosestMatchingParent(node, context, isCreateElementMatcher);
          return createElementParent && createElementParent.arguments && createElementParent.arguments[1] === getClosestMatchingParent(node, context, isObjectExpressionMatcher);
        }
        function isComponentInProp(node) {
          if (isPropertyOfObjectExpressionMatcher(node)) {
            return utils.isReturningJSX(node);
          }
          const jsxAttribute = getClosestMatchingParent(node, context, isJSXAttributeOfExpressionContainerMatcher);
          if (!jsxAttribute) {
            return isComponentInsideCreateElementsProp(node);
          }
          return utils.isReturningJSX(node);
        }
        function isStatelessComponentReturningNull(node) {
          const component = utils.getStatelessComponent(node);
          return component && !utils.isReturningJSX(component);
        }
        function validate(node) {
          if (!node || !node.parent) {
            return;
          }
          const isDeclaredInsideProps = isComponentInProp(node);
          if (!components.get(node) && !isFunctionComponentInsideClassComponent(node) && !isDeclaredInsideProps) {
            return;
          }
          if (
            // Support allowAsProps option
            isDeclaredInsideProps && (allowAsProps || isComponentInRenderProp(node, context)) || isMapCall(node) || isMapCall(node.parent) || isReturnStatementOfHook(node, context) || isDirectValueOfRenderProperty(node) || isInsideRenderMethod(node) || isStatelessComponentReturningNull(node)
          ) {
            return;
          }
          const parentComponent = getClosestMatchingParent(
            node,
            context,
            (nodeToMatch) => components.get(nodeToMatch)
          );
          if (parentComponent) {
            const parentName = resolveComponentName(parentComponent);
            if (parentName && parentName[0] === parentName[0].toLowerCase()) {
              return;
            }
            let message = generateErrorMessageWithParentName(parentName);
            if (isDeclaredInsideProps && !allowAsProps) {
              message += COMPONENT_AS_PROPS_INFO;
            }
            report(context, message, null, {
              node
            });
          }
        }
        return {
          FunctionDeclaration(node) {
            validate(node);
          },
          ArrowFunctionExpression(node) {
            validate(node);
          },
          FunctionExpression(node) {
            validate(node);
          },
          ClassDeclaration(node) {
            validate(node);
          },
          CallExpression(node) {
            validate(node);
          }
        };
      })
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-unused-class-component-methods.js
var require_no_unused_class_component_methods = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-unused-class-component-methods.js"(exports, module) {
    "use strict";
    var docsUrl = require_docsUrl();
    var componentUtil = require_componentUtil();
    var report = require_report();
    var LIFECYCLE_METHODS = /* @__PURE__ */ new Set([
      "constructor",
      "componentDidCatch",
      "componentDidMount",
      "componentDidUpdate",
      "componentWillMount",
      "componentWillReceiveProps",
      "componentWillUnmount",
      "componentWillUpdate",
      "getChildContext",
      "getSnapshotBeforeUpdate",
      "render",
      "shouldComponentUpdate",
      "UNSAFE_componentWillMount",
      "UNSAFE_componentWillReceiveProps",
      "UNSAFE_componentWillUpdate"
    ]);
    var ES6_LIFECYCLE = /* @__PURE__ */ new Set([
      "state"
    ]);
    var ES5_LIFECYCLE = /* @__PURE__ */ new Set([
      "getInitialState",
      "getDefaultProps",
      "mixins"
    ]);
    function isKeyLiteralLike(node, property) {
      return property.type === "Literal" || property.type === "TemplateLiteral" && property.expressions.length === 0 || node.computed === false && property.type === "Identifier";
    }
    function uncast(node) {
      while (node.type === "TypeCastExpression") {
        node = node.expression;
      }
      return node;
    }
    function getName(node) {
      node = uncast(node);
      const type = node.type;
      if (type === "Identifier") {
        return node.name;
      }
      if (type === "Literal") {
        return String(node.value);
      }
      if (type === "TemplateLiteral" && node.expressions.length === 0) {
        return node.quasis[0].value.raw;
      }
      return null;
    }
    function isThisExpression(node) {
      return uncast(node).type === "ThisExpression";
    }
    function getInitialClassInfo(node, isClass) {
      return {
        classNode: node,
        isClass,
        // Set of nodes where properties were defined.
        properties: /* @__PURE__ */ new Set(),
        // Set of names of properties that we've seen used.
        usedProperties: /* @__PURE__ */ new Set(),
        inStatic: false
      };
    }
    var messages = {
      unused: 'Unused method or property "{{name}}"',
      unusedWithClass: 'Unused method or property "{{name}}" of class "{{className}}"'
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow declaring unused methods of component class",
          category: "Best Practices",
          recommended: false,
          url: docsUrl("no-unused-class-component-methods")
        },
        messages,
        schema: []
      },
      create: (context) => {
        let classInfo = null;
        function addProperty(node) {
          classInfo.properties.add(node);
        }
        function addUsedProperty(node) {
          const name = getName(node);
          if (name) {
            classInfo.usedProperties.add(name);
          }
        }
        function reportUnusedProperties() {
          for (const node of classInfo.properties) {
            const name = getName(node);
            if (!classInfo.usedProperties.has(name) && !LIFECYCLE_METHODS.has(name) && (classInfo.isClass ? !ES6_LIFECYCLE.has(name) : !ES5_LIFECYCLE.has(name))) {
              const className = classInfo.classNode.id && classInfo.classNode.id.name || "";
              const messageID = className ? "unusedWithClass" : "unused";
              report(
                context,
                messages[messageID],
                messageID,
                {
                  node,
                  data: {
                    name,
                    className
                  }
                }
              );
            }
          }
        }
        function exitMethod() {
          if (!classInfo || !classInfo.inStatic) {
            return;
          }
          classInfo.inStatic = false;
        }
        return {
          ClassDeclaration(node) {
            if (componentUtil.isES6Component(node, context)) {
              classInfo = getInitialClassInfo(node, true);
            }
          },
          ObjectExpression(node) {
            if (componentUtil.isES5Component(node, context)) {
              classInfo = getInitialClassInfo(node, false);
            }
          },
          "ClassDeclaration:exit"() {
            if (!classInfo) {
              return;
            }
            reportUnusedProperties();
            classInfo = null;
          },
          "ObjectExpression:exit"(node) {
            if (!classInfo || classInfo.classNode !== node) {
              return;
            }
            reportUnusedProperties();
            classInfo = null;
          },
          Property(node) {
            if (!classInfo || classInfo.classNode !== node.parent) {
              return;
            }
            if (isKeyLiteralLike(node, node.key)) {
              addProperty(node.key);
            }
          },
          "ClassProperty, MethodDefinition, PropertyDefinition"(node) {
            if (!classInfo) {
              return;
            }
            if (node.static) {
              classInfo.inStatic = true;
              return;
            }
            if (isKeyLiteralLike(node, node.key)) {
              addProperty(node.key);
            }
          },
          "ClassProperty:exit": exitMethod,
          "MethodDefinition:exit": exitMethod,
          "PropertyDefinition:exit": exitMethod,
          MemberExpression(node) {
            if (!classInfo || classInfo.inStatic) {
              return;
            }
            if (isThisExpression(node.object) && isKeyLiteralLike(node, node.property)) {
              if (node.parent.type === "AssignmentExpression" && node.parent.left === node) {
                addProperty(node.property);
              } else {
                addUsedProperty(node.property);
              }
            }
          },
          VariableDeclarator(node) {
            if (!classInfo || classInfo.inStatic) {
              return;
            }
            if (node.init && isThisExpression(node.init) && node.id.type === "ObjectPattern") {
              node.id.properties.filter((prop) => prop.type === "Property" && isKeyLiteralLike(prop, prop.key)).forEach((prop) => {
                addUsedProperty(prop.key);
              });
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-unused-prop-types.js
var require_no_unused_prop_types = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-unused-prop-types.js"(exports, module) {
    "use strict";
    var values = require_object3();
    var Components = require_Components();
    var docsUrl = require_docsUrl();
    var report = require_report();
    var messages = {
      unusedPropType: "'{{name}}' PropType is defined but prop is never used"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow definitions of unused propTypes",
          category: "Best Practices",
          recommended: false,
          url: docsUrl("no-unused-prop-types")
        },
        messages,
        schema: [{
          type: "object",
          properties: {
            ignore: {
              type: "array",
              items: {
                type: "string"
              },
              uniqueItems: true
            },
            customValidators: {
              type: "array",
              items: {
                type: "string"
              }
            },
            skipShapeProps: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }]
      },
      create: Components.detect((context, components) => {
        const defaults = { skipShapeProps: true, customValidators: [], ignore: [] };
        const configuration = Object.assign({}, defaults, context.options[0] || {});
        function isIgnored(name) {
          return configuration.ignore.indexOf(name) !== -1;
        }
        function mustBeValidated(component) {
          return Boolean(
            component && !component.ignoreUnusedPropTypesValidation
          );
        }
        function isPropUsed(node, prop) {
          const usedPropTypes = node.usedPropTypes || [];
          for (let i = 0, l = usedPropTypes.length; i < l; i++) {
            const usedProp = usedPropTypes[i];
            if (prop.type === "shape" || prop.type === "exact" || prop.name === "__ANY_KEY__" || usedProp.name === prop.name) {
              return true;
            }
          }
          return false;
        }
        function reportUnusedPropType(component, props) {
          if (props === true) {
            return;
          }
          Object.keys(props || {}).forEach((key) => {
            const prop = props[key];
            if (prop === true) {
              return;
            }
            if ((prop.type === "shape" || prop.type === "exact") && configuration.skipShapeProps) {
              return;
            }
            if (prop.node && prop.node.typeAnnotation && prop.node.typeAnnotation.typeAnnotation && prop.node.typeAnnotation.typeAnnotation.type === "TSNeverKeyword") {
              return;
            }
            if (prop.node && !isIgnored(prop.fullName) && !isPropUsed(component, prop)) {
              report(context, messages.unusedPropType, "unusedPropType", {
                node: prop.node.key || prop.node,
                data: {
                  name: prop.fullName
                }
              });
            }
            if (prop.children) {
              reportUnusedPropType(component, prop.children);
            }
          });
        }
        function reportUnusedPropTypes(component) {
          reportUnusedPropType(component, component.declaredPropTypes);
        }
        return {
          "Program:exit"() {
            values(components.list()).filter((component) => mustBeValidated(component)).forEach((component) => {
              reportUnusedPropTypes(component);
            });
          }
        };
      })
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-unused-state.js
var require_no_unused_state = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-unused-state.js"(exports, module) {
    "use strict";
    var docsUrl = require_docsUrl();
    var ast = require_ast();
    var componentUtil = require_componentUtil();
    var report = require_report();
    var getScope = require_eslint().getScope;
    function uncast(node) {
      while (node.type === "TypeCastExpression") {
        node = node.expression;
      }
      return node;
    }
    function getName(node) {
      node = uncast(node);
      const type = node.type;
      if (type === "Identifier") {
        return node.name;
      }
      if (type === "Literal") {
        return String(node.value);
      }
      if (type === "TemplateLiteral" && node.expressions.length === 0) {
        return node.quasis[0].value.raw;
      }
      return null;
    }
    function isThisExpression(node) {
      return ast.unwrapTSAsExpression(uncast(node)).type === "ThisExpression";
    }
    function getInitialClassInfo() {
      return {
        // Set of nodes where state fields were defined.
        stateFields: /* @__PURE__ */ new Set(),
        // Set of names of state fields that we've seen used.
        usedStateFields: /* @__PURE__ */ new Set(),
        // Names of local variables that may be pointing to this.state. To
        // track this properly, we would need to keep track of all locals,
        // shadowing, assignments, etc. To keep things simple, we only
        // maintain one set of aliases per method and accept that it will
        // produce some false negatives.
        aliases: null
      };
    }
    function isSetStateCall(node) {
      const unwrappedCalleeNode = ast.unwrapTSAsExpression(node.callee);
      return unwrappedCalleeNode.type === "MemberExpression" && isThisExpression(unwrappedCalleeNode.object) && getName(unwrappedCalleeNode.property) === "setState";
    }
    var messages = {
      unusedStateField: "Unused state field: '{{name}}'"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow definitions of unused state",
          category: "Best Practices",
          recommended: false,
          url: docsUrl("no-unused-state")
        },
        messages,
        schema: []
      },
      create(context) {
        let classInfo = null;
        function isStateParameterReference(node) {
          const classMethods = [
            "shouldComponentUpdate",
            "componentWillUpdate",
            "UNSAFE_componentWillUpdate",
            "getSnapshotBeforeUpdate",
            "componentDidUpdate"
          ];
          let scope = getScope(context, node);
          while (scope) {
            const parent = scope.block && scope.block.parent;
            if (parent && parent.type === "MethodDefinition" && (parent.static && parent.key.name === "getDerivedStateFromProps" || classMethods.indexOf(parent.key.name) !== -1) && parent.value.type === "FunctionExpression" && parent.value.params[1] && parent.value.params[1].name === node.name) {
              return true;
            }
            scope = scope.upper;
          }
          return false;
        }
        function isStateReference(node) {
          node = uncast(node);
          const isDirectStateReference = node.type === "MemberExpression" && isThisExpression(node.object) && node.property.name === "state";
          const isAliasedStateReference = node.type === "Identifier" && classInfo.aliases && classInfo.aliases.has(node.name);
          return isDirectStateReference || isAliasedStateReference || isStateParameterReference(node);
        }
        function addStateFields(node) {
          node.properties.filter((prop) => prop.type === "Property" && (prop.key.type === "Literal" || prop.key.type === "TemplateLiteral" && prop.key.expressions.length === 0 || prop.computed === false && prop.key.type === "Identifier") && getName(prop.key) !== null).forEach((prop) => {
            classInfo.stateFields.add(prop);
          });
        }
        function addUsedStateField(node) {
          if (!classInfo) {
            return;
          }
          const name = getName(node);
          if (name) {
            classInfo.usedStateFields.add(name);
          }
        }
        function handleStateDestructuring(node) {
          for (const prop of node.properties) {
            if (prop.type === "Property") {
              addUsedStateField(prop.key);
            } else if ((prop.type === "ExperimentalRestProperty" || prop.type === "RestElement") && classInfo.aliases) {
              classInfo.aliases.add(getName(prop.argument));
            }
          }
        }
        function handleAssignment(left, right) {
          const unwrappedRight = ast.unwrapTSAsExpression(right);
          switch (left.type) {
            case "Identifier":
              if (isStateReference(unwrappedRight) && classInfo.aliases) {
                classInfo.aliases.add(left.name);
              }
              break;
            case "ObjectPattern":
              if (isStateReference(unwrappedRight)) {
                handleStateDestructuring(left);
              } else if (isThisExpression(unwrappedRight) && classInfo.aliases) {
                for (const prop of left.properties) {
                  if (prop.type === "Property" && getName(prop.key) === "state") {
                    const name = getName(prop.value);
                    if (name) {
                      classInfo.aliases.add(name);
                    } else if (prop.value.type === "ObjectPattern") {
                      handleStateDestructuring(prop.value);
                    }
                  }
                }
              }
              break;
            default:
          }
        }
        function reportUnusedFields() {
          for (const node of classInfo.stateFields) {
            const name = getName(node.key);
            if (!classInfo.usedStateFields.has(name)) {
              report(context, messages.unusedStateField, "unusedStateField", {
                node,
                data: {
                  name
                }
              });
            }
          }
        }
        function handleES6ComponentEnter(node) {
          if (componentUtil.isES6Component(node, context)) {
            classInfo = getInitialClassInfo();
          }
        }
        function handleES6ComponentExit() {
          if (!classInfo) {
            return;
          }
          reportUnusedFields();
          classInfo = null;
        }
        function isGDSFP(node) {
          const name = getName(node.key);
          if (!node.static || name !== "getDerivedStateFromProps" || !node.value || !node.value.params || node.value.params.length < 2) {
            return false;
          }
          return true;
        }
        return {
          ClassDeclaration: handleES6ComponentEnter,
          "ClassDeclaration:exit": handleES6ComponentExit,
          ClassExpression: handleES6ComponentEnter,
          "ClassExpression:exit": handleES6ComponentExit,
          ObjectExpression(node) {
            if (componentUtil.isES5Component(node, context)) {
              classInfo = getInitialClassInfo();
            }
          },
          "ObjectExpression:exit"(node) {
            if (!classInfo) {
              return;
            }
            if (componentUtil.isES5Component(node, context)) {
              reportUnusedFields();
              classInfo = null;
            }
          },
          CallExpression(node) {
            if (!classInfo) {
              return;
            }
            const unwrappedNode = ast.unwrapTSAsExpression(node);
            const unwrappedArgumentNode = ast.unwrapTSAsExpression(unwrappedNode.arguments[0]);
            if (isSetStateCall(unwrappedNode) && unwrappedNode.arguments.length > 0 && unwrappedArgumentNode.type === "ObjectExpression") {
              addStateFields(unwrappedArgumentNode);
            } else if (isSetStateCall(unwrappedNode) && unwrappedNode.arguments.length > 0 && unwrappedArgumentNode.type === "ArrowFunctionExpression") {
              const unwrappedBodyNode = ast.unwrapTSAsExpression(unwrappedArgumentNode.body);
              if (unwrappedBodyNode.type === "ObjectExpression") {
                addStateFields(unwrappedBodyNode);
              }
              if (unwrappedArgumentNode.params.length > 0 && classInfo.aliases) {
                const firstParam = unwrappedArgumentNode.params[0];
                if (firstParam.type === "ObjectPattern") {
                  handleStateDestructuring(firstParam);
                } else {
                  classInfo.aliases.add(getName(firstParam));
                }
              }
            }
          },
          "ClassProperty, PropertyDefinition"(node) {
            if (!classInfo) {
              return;
            }
            const unwrappedValueNode = ast.unwrapTSAsExpression(node.value);
            const name = getName(node.key);
            if (name === "state" && !node.static && unwrappedValueNode && unwrappedValueNode.type === "ObjectExpression") {
              addStateFields(unwrappedValueNode);
            }
            if (!node.static && unwrappedValueNode && unwrappedValueNode.type === "ArrowFunctionExpression") {
              classInfo.aliases = /* @__PURE__ */ new Set();
            }
          },
          "ClassProperty:exit"(node) {
            if (classInfo && !node.static && node.value && node.value.type === "ArrowFunctionExpression") {
              classInfo.aliases = null;
            }
          },
          "PropertyDefinition, ClassProperty"(node) {
            if (!isGDSFP(node)) {
              return;
            }
            const childScope = getScope(context, node).childScopes.find((x) => x.block === node.value);
            if (!childScope) {
              return;
            }
            const scope = childScope.variableScope.childScopes.find((x) => x.block === node.value);
            const stateArg = node.value.params[1];
            if (!scope || !scope.variables) {
              return;
            }
            const argVar = scope.variables.find((x) => x.name === stateArg.name);
            if (argVar) {
              const stateRefs = argVar.references;
              stateRefs.forEach((ref) => {
                const identifier = ref.identifier;
                if (identifier && identifier.parent && identifier.parent.type === "MemberExpression") {
                  addUsedStateField(identifier.parent.property);
                }
              });
            }
          },
          "PropertyDefinition:exit"(node) {
            if (classInfo && !node.static && node.value && node.value.type === "ArrowFunctionExpression" && !isGDSFP(node)) {
              classInfo.aliases = null;
            }
          },
          MethodDefinition() {
            if (!classInfo) {
              return;
            }
            classInfo.aliases = /* @__PURE__ */ new Set();
          },
          "MethodDefinition:exit"() {
            if (!classInfo) {
              return;
            }
            classInfo.aliases = null;
          },
          FunctionExpression(node) {
            if (!classInfo) {
              return;
            }
            const parent = node.parent;
            if (!componentUtil.isES5Component(parent.parent, context)) {
              return;
            }
            if (parent.key.name === "getInitialState") {
              const body = node.body.body;
              const lastBodyNode = body[body.length - 1];
              if (lastBodyNode.type === "ReturnStatement" && lastBodyNode.argument.type === "ObjectExpression") {
                addStateFields(lastBodyNode.argument);
              }
            } else {
              classInfo.aliases = /* @__PURE__ */ new Set();
            }
          },
          AssignmentExpression(node) {
            if (!classInfo) {
              return;
            }
            const unwrappedLeft = ast.unwrapTSAsExpression(node.left);
            const unwrappedRight = ast.unwrapTSAsExpression(node.right);
            if (unwrappedLeft.type === "MemberExpression" && isThisExpression(unwrappedLeft.object) && getName(unwrappedLeft.property) === "state" && unwrappedRight.type === "ObjectExpression") {
              let fn = node;
              while (fn.type !== "FunctionExpression" && fn.parent) {
                fn = fn.parent;
              }
              if (fn.parent && fn.parent.type === "MethodDefinition" && fn.parent.kind === "constructor") {
                addStateFields(unwrappedRight);
              }
            } else {
              handleAssignment(unwrappedLeft, unwrappedRight);
            }
          },
          VariableDeclarator(node) {
            if (!classInfo || !node.init) {
              return;
            }
            handleAssignment(node.id, node.init);
          },
          "MemberExpression, OptionalMemberExpression"(node) {
            if (!classInfo) {
              return;
            }
            if (isStateReference(ast.unwrapTSAsExpression(node.object))) {
              if (node.computed && node.property.type !== "Literal") {
                classInfo = null;
                return;
              }
              addUsedStateField(node.property);
            } else if (isStateReference(node) && node.parent.type === "CallExpression") {
              classInfo = null;
            }
          },
          JSXSpreadAttribute(node) {
            if (classInfo && isStateReference(node.argument)) {
              classInfo = null;
            }
          },
          "ExperimentalSpreadProperty, SpreadElement"(node) {
            if (classInfo && isStateReference(node.argument)) {
              classInfo = null;
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-object-type-as-default-prop.js
var require_no_object_type_as_default_prop = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-object-type-as-default-prop.js"(exports, module) {
    "use strict";
    var values = require_object3();
    var Components = require_Components();
    var docsUrl = require_docsUrl();
    var report = require_report();
    var FORBIDDEN_TYPES_MAP = {
      ArrowFunctionExpression: "arrow function",
      FunctionExpression: "function expression",
      ObjectExpression: "object literal",
      ArrayExpression: "array literal",
      ClassExpression: "class expression",
      NewExpression: "construction expression",
      JSXElement: "JSX element"
    };
    var FORBIDDEN_TYPES = new Set(Object.keys(FORBIDDEN_TYPES_MAP));
    var MESSAGE_ID = "forbiddenTypeDefaultParam";
    var messages = {
      [MESSAGE_ID]: "{{propName}} has a/an {{forbiddenType}} as default prop. This could lead to potential infinite render loop in React. Use a variable reference instead of {{forbiddenType}}."
    };
    function hasUsedObjectDestructuringSyntax(params) {
      return params != null && params.length === 1 && params[0].type === "ObjectPattern";
    }
    function verifyDefaultPropsDestructuring(context, properties) {
      properties.filter((prop) => prop.type === "Property" && prop.value.type === "AssignmentPattern").forEach((prop) => {
        const propName = prop.key.name;
        const propDefaultValue = prop.value;
        const propDefaultValueType = propDefaultValue.right.type;
        if (propDefaultValueType === "Literal" && propDefaultValue.right.regex != null) {
          report(context, messages[MESSAGE_ID], MESSAGE_ID, {
            node: propDefaultValue,
            data: {
              propName,
              forbiddenType: "regex literal"
            }
          });
        } else if (propDefaultValueType === "CallExpression" && propDefaultValue.right.callee.type === "Identifier" && propDefaultValue.right.callee.name === "Symbol") {
          report(context, messages[MESSAGE_ID], MESSAGE_ID, {
            node: propDefaultValue,
            data: {
              propName,
              forbiddenType: "Symbol literal"
            }
          });
        } else if (FORBIDDEN_TYPES.has(propDefaultValueType)) {
          report(context, messages[MESSAGE_ID], MESSAGE_ID, {
            node: propDefaultValue,
            data: {
              propName,
              forbiddenType: FORBIDDEN_TYPES_MAP[propDefaultValueType]
            }
          });
        }
      });
    }
    module.exports = {
      meta: {
        docs: {
          description: "Disallow usage of referential-type variables as default param in functional component",
          category: "Best Practices",
          recommended: false,
          url: docsUrl("no-object-type-as-default-prop")
        },
        messages
      },
      create: Components.detect((context, components) => ({
        "Program:exit"() {
          const list = components.list();
          values(list).filter((component) => hasUsedObjectDestructuringSyntax(component.node.params)).forEach((component) => {
            const node = component.node;
            const properties = node.params[0].properties;
            verifyDefaultPropsDestructuring(context, properties);
          });
        }
      }))
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-will-update-set-state.js
var require_no_will_update_set_state = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/no-will-update-set-state.js"(exports, module) {
    "use strict";
    var makeNoMethodSetStateRule = require_makeNoMethodSetStateRule();
    var testReactVersion = require_version().testReactVersion;
    module.exports = makeNoMethodSetStateRule(
      "componentWillUpdate",
      (context) => testReactVersion(context, ">= 16.3.0")
    );
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/prefer-es6-class.js
var require_prefer_es6_class = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/prefer-es6-class.js"(exports, module) {
    "use strict";
    var componentUtil = require_componentUtil();
    var docsUrl = require_docsUrl();
    var report = require_report();
    var messages = {
      shouldUseES6Class: "Component should use es6 class instead of createClass",
      shouldUseCreateClass: "Component should use createClass instead of es6 class"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce ES5 or ES6 class for React Components",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("prefer-es6-class")
        },
        messages,
        schema: [{
          enum: ["always", "never"]
        }]
      },
      create(context) {
        const configuration = context.options[0] || "always";
        return {
          ObjectExpression(node) {
            if (componentUtil.isES5Component(node, context) && configuration === "always") {
              report(context, messages.shouldUseES6Class, "shouldUseES6Class", {
                node
              });
            }
          },
          ClassDeclaration(node) {
            if (componentUtil.isES6Component(node, context) && configuration === "never") {
              report(context, messages.shouldUseCreateClass, "shouldUseCreateClass", {
                node
              });
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/prefer-exact-props.js
var require_prefer_exact_props = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/prefer-exact-props.js"(exports, module) {
    "use strict";
    var Components = require_Components();
    var docsUrl = require_docsUrl();
    var propsUtil = require_props();
    var propWrapperUtil = require_propWrapper();
    var variableUtil = require_variable();
    var report = require_report();
    var getText = require_eslint().getText;
    var messages = {
      propTypes: "Component propTypes should be exact by using {{exactPropWrappers}}.",
      flow: "Component flow props should be set with exact objects."
    };
    module.exports = {
      meta: {
        docs: {
          description: "Prefer exact proptype definitions",
          category: "Possible Errors",
          recommended: false,
          url: docsUrl("prefer-exact-props")
        },
        messages,
        schema: []
      },
      create: Components.detect((context, components, utils) => {
        const typeAliases = {};
        const exactWrappers = propWrapperUtil.getExactPropWrapperFunctions(context);
        function getPropTypesErrorMessage() {
          const formattedWrappers = propWrapperUtil.formatPropWrapperFunctions(exactWrappers);
          const message = exactWrappers.size > 1 ? `one of ${formattedWrappers}` : formattedWrappers;
          return { exactPropWrappers: message };
        }
        function isNonExactObjectTypeAnnotation(node) {
          return node && node.type === "ObjectTypeAnnotation" && node.properties.length > 0 && !node.exact;
        }
        function hasNonExactObjectTypeAnnotation(node) {
          const typeAnnotation = node.typeAnnotation;
          return typeAnnotation && typeAnnotation.typeAnnotation && isNonExactObjectTypeAnnotation(typeAnnotation.typeAnnotation);
        }
        function hasGenericTypeAnnotation(node) {
          const typeAnnotation = node.typeAnnotation;
          return typeAnnotation && typeAnnotation.typeAnnotation && typeAnnotation.typeAnnotation.type === "GenericTypeAnnotation";
        }
        function isNonEmptyObjectExpression(node) {
          return node && node.type === "ObjectExpression" && node.properties.length > 0;
        }
        function isNonExactPropWrapperFunction(node) {
          return node && node.type === "CallExpression" && !propWrapperUtil.isExactPropWrapperFunction(context, getText(context, node.callee));
        }
        function reportPropTypesError(node) {
          report(context, messages.propTypes, "propTypes", {
            node,
            data: getPropTypesErrorMessage()
          });
        }
        function reportFlowError(node) {
          report(context, messages.flow, "flow", {
            node
          });
        }
        return {
          TypeAlias(node) {
            typeAliases[node.id.name] = node;
          },
          "ClassProperty, PropertyDefinition"(node) {
            if (!propsUtil.isPropTypesDeclaration(node)) {
              return;
            }
            if (hasNonExactObjectTypeAnnotation(node)) {
              reportFlowError(node);
            } else if (exactWrappers.size > 0 && isNonEmptyObjectExpression(node.value)) {
              reportPropTypesError(node);
            } else if (exactWrappers.size > 0 && isNonExactPropWrapperFunction(node.value)) {
              reportPropTypesError(node);
            }
          },
          Identifier(node) {
            if (!utils.getStatelessComponent(node.parent)) {
              return;
            }
            if (hasNonExactObjectTypeAnnotation(node)) {
              reportFlowError(node);
            } else if (hasGenericTypeAnnotation(node)) {
              const identifier = node.typeAnnotation.typeAnnotation.id.name;
              const typeAlias = typeAliases[identifier];
              const propsDefinition = typeAlias ? typeAlias.right : null;
              if (isNonExactObjectTypeAnnotation(propsDefinition)) {
                reportFlowError(node);
              }
            }
          },
          MemberExpression(node) {
            if (!propsUtil.isPropTypesDeclaration(node) || exactWrappers.size === 0) {
              return;
            }
            const right = node.parent.right;
            if (isNonEmptyObjectExpression(right)) {
              reportPropTypesError(node);
            } else if (isNonExactPropWrapperFunction(right)) {
              reportPropTypesError(node);
            } else if (right.type === "Identifier") {
              const identifier = right.name;
              const propsDefinition = variableUtil.findVariableByName(context, node, identifier);
              if (isNonEmptyObjectExpression(propsDefinition)) {
                reportPropTypesError(node);
              } else if (isNonExactPropWrapperFunction(propsDefinition)) {
                reportPropTypesError(node);
              }
            }
          }
        };
      })
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/prefer-read-only-props.js
var require_prefer_read_only_props = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/prefer-read-only-props.js"(exports, module) {
    "use strict";
    var flatMap = require_array_prototype();
    var values = require_object3();
    var Components = require_Components();
    var docsUrl = require_docsUrl();
    var report = require_report();
    function isFlowPropertyType(node) {
      return node.type === "ObjectTypeProperty";
    }
    function isTypescriptPropertyType(node) {
      return node.type === "TSPropertySignature";
    }
    function isCovariant(node) {
      return node.variance && node.variance.kind === "plus" || node.parent && node.parent.parent && node.parent.parent.parent && node.parent.parent.parent.id && node.parent.parent.parent.id.name === "$ReadOnly";
    }
    function isReadonly(node) {
      return node.typeAnnotation && node.typeAnnotation.parent && node.typeAnnotation.parent.readonly;
    }
    var messages = {
      readOnlyProp: "Prop '{{name}}' should be read-only."
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce that props are read-only",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("prefer-read-only-props")
        },
        fixable: "code",
        messages,
        schema: []
      },
      create: Components.detect((context, components) => {
        function reportReadOnlyProp(prop, propName, fixer) {
          report(context, messages.readOnlyProp, "readOnlyProp", {
            node: prop.node,
            data: {
              name: propName
            },
            fix: fixer
          });
        }
        return {
          "Program:exit"() {
            flatMap(
              values(components.list()),
              (component) => component.declaredPropTypes || []
            ).forEach((declaredPropTypes) => {
              Object.keys(declaredPropTypes).forEach((propName) => {
                const prop = declaredPropTypes[propName];
                if (!prop.node) {
                  return;
                }
                if (isFlowPropertyType(prop.node)) {
                  if (!isCovariant(prop.node)) {
                    reportReadOnlyProp(prop, propName, (fixer) => {
                      if (!prop.node.variance) {
                        return fixer.insertTextBefore(prop.node, "+");
                      }
                      return fixer.replaceText(prop.node.variance, "+");
                    });
                  }
                  return;
                }
                if (isTypescriptPropertyType(prop.node)) {
                  if (!isReadonly(prop.node)) {
                    reportReadOnlyProp(prop, propName, (fixer) => fixer.insertTextBefore(prop.node, "readonly "));
                  }
                }
              });
            });
          }
        };
      })
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/prefer-stateless-function.js
var require_prefer_stateless_function = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/prefer-stateless-function.js"(exports, module) {
    "use strict";
    var values = require_object3();
    var Components = require_Components();
    var testReactVersion = require_version().testReactVersion;
    var astUtil = require_ast();
    var componentUtil = require_componentUtil();
    var docsUrl = require_docsUrl();
    var report = require_report();
    var eslintUtil = require_eslint();
    var getScope = eslintUtil.getScope;
    var getText = eslintUtil.getText;
    var messages = {
      componentShouldBePure: "Component should be written as a pure function"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce stateless components to be written as a pure function",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("prefer-stateless-function")
        },
        messages,
        schema: [{
          type: "object",
          properties: {
            ignorePureComponents: {
              default: false,
              type: "boolean"
            }
          },
          additionalProperties: false
        }]
      },
      create: Components.detect((context, components, utils) => {
        const configuration = context.options[0] || {};
        const ignorePureComponents = configuration.ignorePureComponents || false;
        function isSingleSuperCall(body) {
          return body.length === 1 && body[0].type === "ExpressionStatement" && body[0].expression.type === "CallExpression" && body[0].expression.callee.type === "Super";
        }
        function isSimple(node) {
          return node.type === "Identifier" || node.type === "RestElement";
        }
        function isSpreadArguments(superArgs) {
          return superArgs.length === 1 && superArgs[0].type === "SpreadElement" && superArgs[0].argument.type === "Identifier" && superArgs[0].argument.name === "arguments";
        }
        function isValidIdentifierPair(ctorParam, superArg) {
          return ctorParam.type === "Identifier" && superArg.type === "Identifier" && ctorParam.name === superArg.name;
        }
        function isValidRestSpreadPair(ctorParam, superArg) {
          return ctorParam.type === "RestElement" && superArg.type === "SpreadElement" && isValidIdentifierPair(ctorParam.argument, superArg.argument);
        }
        function isValidPair(ctorParam, superArg) {
          return isValidIdentifierPair(ctorParam, superArg) || isValidRestSpreadPair(ctorParam, superArg);
        }
        function isPassingThrough(ctorParams, superArgs) {
          if (ctorParams.length !== superArgs.length) {
            return false;
          }
          for (let i = 0; i < ctorParams.length; ++i) {
            if (!isValidPair(ctorParams[i], superArgs[i])) {
              return false;
            }
          }
          return true;
        }
        function isRedundantSuperCall(body, ctorParams) {
          return isSingleSuperCall(body) && ctorParams.every(isSimple) && (isSpreadArguments(body[0].expression.arguments) || isPassingThrough(ctorParams, body[0].expression.arguments));
        }
        function hasOtherProperties(node) {
          const properties = astUtil.getComponentProperties(node);
          return properties.some((property) => {
            const name = astUtil.getPropertyName(property);
            const isDisplayName = name === "displayName";
            const isPropTypes = name === "propTypes" || name === "props" && property.typeAnnotation;
            const contextTypes = name === "contextTypes";
            const defaultProps = name === "defaultProps";
            const isUselessConstructor = property.kind === "constructor" && !!property.value.body && isRedundantSuperCall(property.value.body.body, property.value.params);
            const isRender = name === "render";
            return !isDisplayName && !isPropTypes && !contextTypes && !defaultProps && !isUselessConstructor && !isRender;
          });
        }
        function markSCUAsDeclared(node) {
          components.set(node, {
            hasSCU: true
          });
        }
        function markChildContextTypesAsDeclared(node) {
          components.set(node, {
            hasChildContextTypes: true
          });
        }
        function markThisAsUsed(node) {
          components.set(node, {
            useThis: true
          });
        }
        function markPropsOrContextAsUsed(node) {
          components.set(node, {
            usePropsOrContext: true
          });
        }
        function markRefAsUsed(node) {
          components.set(node, {
            useRef: true
          });
        }
        function markReturnAsInvalid(node) {
          components.set(node, {
            invalidReturn: true
          });
        }
        function markDecoratorsAsUsed(node) {
          components.set(node, {
            useDecorators: true
          });
        }
        function visitClass(node) {
          if (ignorePureComponents && componentUtil.isPureComponent(node, context)) {
            markSCUAsDeclared(node);
          }
          if (node.decorators && node.decorators.length) {
            markDecoratorsAsUsed(node);
          }
        }
        return {
          ClassDeclaration: visitClass,
          ClassExpression: visitClass,
          // Mark `this` destructuring as a usage of `this`
          VariableDeclarator(node) {
            if (!node.id || node.id.type !== "ObjectPattern" || !node.init || node.init.type !== "ThisExpression") {
              return;
            }
            const useThis = node.id.properties.some((property) => {
              const name = astUtil.getPropertyName(property);
              return name !== "props" && name !== "context";
            });
            if (!useThis) {
              markPropsOrContextAsUsed(node);
              return;
            }
            markThisAsUsed(node);
          },
          // Mark `this` usage
          MemberExpression(node) {
            if (node.object.type !== "ThisExpression") {
              if (node.property && node.property.name === "childContextTypes") {
                const component = utils.getRelatedComponent(node);
                if (!component) {
                  return;
                }
                markChildContextTypesAsDeclared(component.node);
              }
              return;
            }
            if ((node.property.name || node.property.value) === "props" || (node.property.name || node.property.value) === "context") {
              markPropsOrContextAsUsed(node);
              return;
            }
            markThisAsUsed(node);
          },
          // Mark `ref` usage
          JSXAttribute(node) {
            const name = getText(context, node.name);
            if (name !== "ref") {
              return;
            }
            markRefAsUsed(node);
          },
          // Mark `render` that do not return some JSX
          ReturnStatement(node) {
            let blockNode;
            let scope = getScope(context, node);
            while (scope) {
              blockNode = scope.block && scope.block.parent;
              if (blockNode && (blockNode.type === "MethodDefinition" || blockNode.type === "Property")) {
                break;
              }
              scope = scope.upper;
            }
            const isRender = blockNode && blockNode.key && blockNode.key.name === "render";
            const allowNull = testReactVersion(context, ">= 15.0.0");
            const isReturningJSX = utils.isReturningJSX(node, !allowNull);
            const isReturningNull = node.argument && (node.argument.value === null || node.argument.value === false);
            if (!isRender || allowNull && (isReturningJSX || isReturningNull) || !allowNull && isReturningJSX) {
              return;
            }
            markReturnAsInvalid(node);
          },
          "Program:exit"() {
            const list = components.list();
            values(list).filter((component) => !hasOtherProperties(component.node) && !component.useThis && !component.useRef && !component.invalidReturn && !component.hasChildContextTypes && !component.useDecorators && !component.hasSCU && (componentUtil.isES5Component(component.node, context) || componentUtil.isES6Component(component.node, context))).forEach((component) => {
              report(context, messages.componentShouldBePure, "componentShouldBePure", {
                node: component.node
              });
            });
          }
        };
      })
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/prop-types.js
var require_prop_types2 = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/prop-types.js"(exports, module) {
    "use strict";
    var values = require_object3();
    var Components = require_Components();
    var docsUrl = require_docsUrl();
    var report = require_report();
    var messages = {
      missingPropType: "'{{name}}' is missing in props validation"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow missing props validation in a React component definition",
          category: "Best Practices",
          recommended: true,
          url: docsUrl("prop-types")
        },
        messages,
        schema: [{
          type: "object",
          properties: {
            ignore: {
              type: "array",
              items: {
                type: "string"
              }
            },
            customValidators: {
              type: "array",
              items: {
                type: "string"
              }
            },
            skipUndeclared: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }]
      },
      create: Components.detect((context, components) => {
        const configuration = context.options[0] || {};
        const ignored = configuration.ignore || [];
        const skipUndeclared = configuration.skipUndeclared || false;
        function isIgnored(name) {
          return ignored.indexOf(name) !== -1;
        }
        function mustBeValidated(component) {
          const isSkippedByConfig = skipUndeclared && typeof component.declaredPropTypes === "undefined";
          return !!(component && component.usedPropTypes && !component.ignorePropsValidation && !isSkippedByConfig);
        }
        function internalIsDeclaredInComponent(declaredPropTypes, keyList) {
          for (let i = 0, j = keyList.length; i < j; i++) {
            const key = keyList[i];
            const propType = declaredPropTypes && // Check if this key is declared
            (declaredPropTypes[key] || declaredPropTypes.__ANY_KEY__);
            if (!propType) {
              return key === "__COMPUTED_PROP__";
            }
            if (typeof propType === "object" && !propType.type) {
              return true;
            }
            if (propType.children === true || propType.containsUnresolvedSpread || propType.containsIndexers) {
              return true;
            }
            if (propType.acceptedProperties) {
              return key in propType.acceptedProperties;
            }
            if (propType.type === "union") {
              if (i + 1 >= j) {
                return true;
              }
              const unionTypes = propType.children;
              const unionPropType = {};
              for (let k = 0, z = unionTypes.length; k < z; k++) {
                unionPropType[key] = unionTypes[k];
                const isValid = internalIsDeclaredInComponent(
                  unionPropType,
                  keyList.slice(i)
                );
                if (isValid) {
                  return true;
                }
              }
              return false;
            }
            declaredPropTypes = propType.children;
          }
          return true;
        }
        function isDeclaredInComponent(node, names) {
          while (node) {
            const component = components.get(node);
            const isDeclared = component && component.confidence >= 2 && internalIsDeclaredInComponent(component.declaredPropTypes || {}, names);
            if (isDeclared) {
              return true;
            }
            node = node.parent;
          }
          return false;
        }
        function reportUndeclaredPropTypes(component) {
          const undeclareds = component.usedPropTypes.filter((propType) => propType.node && !isIgnored(propType.allNames[0]) && !isDeclaredInComponent(component.node, propType.allNames));
          undeclareds.forEach((propType) => {
            report(context, messages.missingPropType, "missingPropType", {
              node: propType.node,
              data: {
                name: propType.allNames.join(".").replace(/\.__COMPUTED_PROP__/g, "[]")
              }
            });
          });
        }
        function checkNestedComponent(component, list) {
          const componentIsMemo = component.node.callee && component.node.callee.name === "memo";
          const argumentIsForwardRef = component.node.arguments && component.node.arguments[0].callee && component.node.arguments[0].callee.name === "forwardRef";
          if (componentIsMemo && argumentIsForwardRef) {
            const forwardComponent = list.find(
              (innerComponent) => innerComponent.node.range[0] === component.node.arguments[0].range[0] && innerComponent.node.range[0] === component.node.arguments[0].range[0]
            );
            const isValidated = mustBeValidated(forwardComponent);
            const isIgnorePropsValidation = forwardComponent.ignorePropsValidation;
            return isIgnorePropsValidation || isValidated;
          }
        }
        return {
          "Program:exit"() {
            const list = components.list();
            values(list).filter((component) => mustBeValidated(component)).forEach((component) => {
              if (checkNestedComponent(component, values(list)))
                return;
              reportUndeclaredPropTypes(component);
            });
          }
        };
      })
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/react-in-jsx-scope.js
var require_react_in_jsx_scope = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/react-in-jsx-scope.js"(exports, module) {
    "use strict";
    var variableUtil = require_variable();
    var pragmaUtil = require_pragma();
    var docsUrl = require_docsUrl();
    var report = require_report();
    var messages = {
      notInScope: "'{{name}}' must be in scope when using JSX"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow missing React when using JSX",
          category: "Possible Errors",
          recommended: true,
          url: docsUrl("react-in-jsx-scope")
        },
        messages,
        schema: []
      },
      create(context) {
        const pragma = pragmaUtil.getFromContext(context);
        function checkIfReactIsInScope(node) {
          const variables = variableUtil.variablesInScope(context, node);
          if (variableUtil.findVariable(variables, pragma)) {
            return;
          }
          report(context, messages.notInScope, "notInScope", {
            node,
            data: {
              name: pragma
            }
          });
        }
        return {
          JSXOpeningElement: checkIfReactIsInScope,
          JSXOpeningFragment: checkIfReactIsInScope
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/require-default-props.js
var require_require_default_props = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/require-default-props.js"(exports, module) {
    "use strict";
    var entries = require_object2();
    var values = require_object3();
    var Components = require_Components();
    var docsUrl = require_docsUrl();
    var astUtil = require_ast();
    var report = require_report();
    var messages = {
      noDefaultWithRequired: 'propType "{{name}}" is required and should not have a defaultProps declaration.',
      shouldHaveDefault: 'propType "{{name}}" is not required, but has no corresponding defaultProps declaration.',
      noDefaultPropsWithFunction: "Don\u2019t use defaultProps with function components.",
      shouldAssignObjectDefault: 'propType "{{name}}" is not required, but has no corresponding default argument value.',
      destructureInSignature: "Must destructure props in the function signature to initialize an optional prop."
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce a defaultProps definition for every prop that is not a required prop",
          category: "Best Practices",
          url: docsUrl("require-default-props")
        },
        messages,
        schema: [{
          type: "object",
          properties: {
            forbidDefaultForRequired: {
              type: "boolean"
            },
            classes: {
              enum: ["defaultProps", "ignore"]
            },
            functions: {
              enum: ["defaultArguments", "defaultProps", "ignore"]
            },
            /**
             * @deprecated
             */
            ignoreFunctionalComponents: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }]
      },
      create: Components.detect((context, components) => {
        const configuration = context.options[0] || {};
        const forbidDefaultForRequired = configuration.forbidDefaultForRequired || false;
        const classes = configuration.classes || "defaultProps";
        const functions = configuration.ignoreFunctionalComponents ? "ignore" : configuration.functions || "defaultProps";
        function reportPropTypesWithoutDefault(propTypes, defaultProps) {
          entries(propTypes).forEach((propType) => {
            const propName = propType[0];
            const prop = propType[1];
            if (!prop.node) {
              return;
            }
            if (prop.isRequired) {
              if (forbidDefaultForRequired && defaultProps[propName]) {
                report(context, messages.noDefaultWithRequired, "noDefaultWithRequired", {
                  node: prop.node,
                  data: { name: propName }
                });
              }
              return;
            }
            if (defaultProps[propName]) {
              return;
            }
            report(context, messages.shouldHaveDefault, "shouldHaveDefault", {
              node: prop.node,
              data: { name: propName }
            });
          });
        }
        function reportFunctionComponent(componentNode, declaredPropTypes, defaultProps) {
          if (defaultProps) {
            report(context, messages.noDefaultPropsWithFunction, "noDefaultPropsWithFunction", {
              node: componentNode
            });
          }
          const props = componentNode.params[0];
          const propTypes = declaredPropTypes;
          if (!props) {
            return;
          }
          if (props.type === "Identifier") {
            const hasOptionalProp = values(propTypes).some((propType) => !propType.isRequired);
            if (hasOptionalProp) {
              report(context, messages.destructureInSignature, "destructureInSignature", {
                node: props
              });
            }
          } else if (props.type === "ObjectPattern") {
            props.properties.filter((prop) => {
              if (prop.type === "RestElement" || prop.type === "ExperimentalRestProperty") {
                return false;
              }
              const propType = propTypes[prop.key.name];
              if (!propType || propType.isRequired) {
                return false;
              }
              return prop.value.type !== "AssignmentPattern";
            }).forEach((prop) => {
              report(context, messages.shouldAssignObjectDefault, "shouldAssignObjectDefault", {
                node: prop,
                data: { name: prop.key.name }
              });
            });
          }
        }
        return {
          "Program:exit"() {
            const list = components.list();
            values(list).filter((component) => {
              if (functions === "ignore" && astUtil.isFunctionLike(component.node)) {
                return false;
              }
              if (classes === "ignore" && astUtil.isClass(component.node)) {
                return false;
              }
              if (component.defaultProps === "unresolved") {
                return false;
              }
              return component.declaredPropTypes !== void 0;
            }).forEach((component) => {
              if (functions === "defaultArguments" && astUtil.isFunctionLike(component.node)) {
                reportFunctionComponent(
                  component.node,
                  component.declaredPropTypes,
                  component.defaultProps
                );
              } else {
                reportPropTypesWithoutDefault(
                  component.declaredPropTypes,
                  component.defaultProps || {}
                );
              }
            });
          }
        };
      })
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/require-optimization.js
var require_require_optimization = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/require-optimization.js"(exports, module) {
    "use strict";
    var values = require_object3();
    var Components = require_Components();
    var componentUtil = require_componentUtil();
    var docsUrl = require_docsUrl();
    var report = require_report();
    var getScope = require_eslint().getScope;
    var messages = {
      noShouldComponentUpdate: "Component is not optimized. Please add a shouldComponentUpdate method."
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce React components to have a shouldComponentUpdate method",
          category: "Best Practices",
          recommended: false,
          url: docsUrl("require-optimization")
        },
        messages,
        schema: [{
          type: "object",
          properties: {
            allowDecorators: {
              type: "array",
              items: {
                type: "string"
              }
            }
          },
          additionalProperties: false
        }]
      },
      create: Components.detect((context, components) => {
        const configuration = context.options[0] || {};
        const allowDecorators = configuration.allowDecorators || [];
        function hasPureRenderDecorator(node) {
          if (node.decorators && node.decorators.length) {
            for (let i = 0, l = node.decorators.length; i < l; i++) {
              if (node.decorators[i].expression && node.decorators[i].expression.callee && node.decorators[i].expression.callee.object && node.decorators[i].expression.callee.object.name === "reactMixin" && node.decorators[i].expression.callee.property && node.decorators[i].expression.callee.property.name === "decorate" && node.decorators[i].expression.arguments && node.decorators[i].expression.arguments.length && node.decorators[i].expression.arguments[0].name === "PureRenderMixin") {
                return true;
              }
            }
          }
          return false;
        }
        function hasCustomDecorator(node) {
          const allowLength = allowDecorators.length;
          if (allowLength && node.decorators && node.decorators.length) {
            for (let i = 0; i < allowLength; i++) {
              for (let j = 0, l = node.decorators.length; j < l; j++) {
                if (node.decorators[j].expression && node.decorators[j].expression.name === allowDecorators[i]) {
                  return true;
                }
              }
            }
          }
          return false;
        }
        function isSCUDeclared(node) {
          return Boolean(
            node && node.name === "shouldComponentUpdate"
          );
        }
        function isPureRenderDeclared(node) {
          let hasPR = false;
          if (node.value && node.value.elements) {
            for (let i = 0, l = node.value.elements.length; i < l; i++) {
              if (node.value.elements[i] && node.value.elements[i].name === "PureRenderMixin") {
                hasPR = true;
                break;
              }
            }
          }
          return Boolean(
            node && node.key.name === "mixins" && hasPR
          );
        }
        function markSCUAsDeclared(node) {
          components.set(node, {
            hasSCU: true
          });
        }
        function reportMissingOptimization(component) {
          report(context, messages.noShouldComponentUpdate, "noShouldComponentUpdate", {
            node: component.node
          });
        }
        function isFunctionInClass(node) {
          let blockNode;
          let scope = getScope(context, node);
          while (scope) {
            blockNode = scope.block;
            if (blockNode && blockNode.type === "ClassDeclaration") {
              return true;
            }
            scope = scope.upper;
          }
          return false;
        }
        return {
          ArrowFunctionExpression(node) {
            if (isFunctionInClass(node)) {
              return;
            }
            markSCUAsDeclared(node);
          },
          ClassDeclaration(node) {
            if (!(hasPureRenderDecorator(node) || hasCustomDecorator(node) || componentUtil.isPureComponent(node, context))) {
              return;
            }
            markSCUAsDeclared(node);
          },
          FunctionDeclaration(node) {
            if (isFunctionInClass(node)) {
              return;
            }
            markSCUAsDeclared(node);
          },
          FunctionExpression(node) {
            if (isFunctionInClass(node)) {
              return;
            }
            markSCUAsDeclared(node);
          },
          MethodDefinition(node) {
            if (!isSCUDeclared(node.key)) {
              return;
            }
            markSCUAsDeclared(node);
          },
          ObjectExpression(node) {
            const found = node.properties.some((property) => property.key && (isSCUDeclared(property.key) || isPureRenderDeclared(property)));
            if (found) {
              markSCUAsDeclared(node);
            }
          },
          "Program:exit"() {
            values(components.list()).filter((component) => !component.hasSCU).forEach((component) => {
              reportMissingOptimization(component);
            });
          }
        };
      })
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/require-render-return.js
var require_require_render_return = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/require-render-return.js"(exports, module) {
    "use strict";
    var values = require_object3();
    var Components = require_Components();
    var astUtil = require_ast();
    var componentUtil = require_componentUtil();
    var docsUrl = require_docsUrl();
    var report = require_report();
    var getAncestors = require_eslint().getAncestors;
    var messages = {
      noRenderReturn: "Your render method should have a return statement"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce ES5 or ES6 class for returning value in render function",
          category: "Possible Errors",
          recommended: true,
          url: docsUrl("require-render-return")
        },
        messages,
        schema: []
      },
      create: Components.detect((context, components) => {
        function markReturnStatementPresent(node) {
          components.set(node, {
            hasReturnStatement: true
          });
        }
        function findRenderMethod(node) {
          const properties = astUtil.getComponentProperties(node);
          return properties.filter((property) => astUtil.getPropertyName(property) === "render" && property.value).find((property) => astUtil.isFunctionLikeExpression(property.value));
        }
        return {
          ReturnStatement(node) {
            const ancestors = getAncestors(context, node).reverse();
            let depth = 0;
            ancestors.forEach((ancestor) => {
              if (/Function(Expression|Declaration)$/.test(ancestor.type)) {
                depth += 1;
              }
              if (/(MethodDefinition|Property|ClassProperty|PropertyDefinition)$/.test(ancestor.type) && astUtil.getPropertyName(ancestor) === "render" && depth <= 1) {
                markReturnStatementPresent(node);
              }
            });
          },
          ArrowFunctionExpression(node) {
            if (node.expression === false || astUtil.getPropertyName(node.parent) !== "render") {
              return;
            }
            markReturnStatementPresent(node);
          },
          "Program:exit"() {
            values(components.list()).filter((component) => findRenderMethod(component.node) && !component.hasReturnStatement && (componentUtil.isES5Component(component.node, context) || componentUtil.isES6Component(component.node, context))).forEach((component) => {
              report(context, messages.noRenderReturn, "noRenderReturn", {
                node: findRenderMethod(component.node)
              });
            });
          }
        };
      })
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/self-closing-comp.js
var require_self_closing_comp = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/self-closing-comp.js"(exports, module) {
    "use strict";
    var docsUrl = require_docsUrl();
    var jsxUtil = require_jsx();
    var report = require_report();
    var optionDefaults = { component: true, html: true };
    var messages = {
      notSelfClosing: "Empty components are self-closing"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Disallow extra closing tags for components without children",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("self-closing-comp")
        },
        fixable: "code",
        messages,
        schema: [{
          type: "object",
          properties: {
            component: {
              default: optionDefaults.component,
              type: "boolean"
            },
            html: {
              default: optionDefaults.html,
              type: "boolean"
            }
          },
          additionalProperties: false
        }]
      },
      create(context) {
        function isComponent(node) {
          return node.name && (node.name.type === "JSXIdentifier" || node.name.type === "JSXMemberExpression") && !jsxUtil.isDOMComponent(node);
        }
        function childrenIsEmpty(node) {
          return node.parent.children.length === 0;
        }
        function childrenIsMultilineSpaces(node) {
          const childrens = node.parent.children;
          return childrens.length === 1 && (childrens[0].type === "Literal" || childrens[0].type === "JSXText") && childrens[0].value.indexOf("\n") !== -1 && childrens[0].value.replace(/(?!\xA0)\s/g, "") === "";
        }
        function isShouldBeSelfClosed(node) {
          const configuration = Object.assign({}, optionDefaults, context.options[0]);
          return (configuration.component && isComponent(node) || configuration.html && jsxUtil.isDOMComponent(node)) && !node.selfClosing && (childrenIsEmpty(node) || childrenIsMultilineSpaces(node));
        }
        return {
          JSXOpeningElement(node) {
            if (!isShouldBeSelfClosed(node)) {
              return;
            }
            report(context, messages.notSelfClosing, "notSelfClosing", {
              node,
              fix(fixer) {
                const openingElementEnding = node.range[1] - 1;
                const closingElementEnding = node.parent.closingElement.range[1];
                const range = [openingElementEnding, closingElementEnding];
                return fixer.replaceTextRange(range, " />");
              }
            });
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/sort-comp.js
var require_sort_comp = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/sort-comp.js"(exports, module) {
    "use strict";
    var has = require_polyfill19()();
    var entries = require_object2();
    var values = require_object3();
    var arrayIncludes = require_array_includes();
    var Components = require_Components();
    var astUtil = require_ast();
    var docsUrl = require_docsUrl();
    var report = require_report();
    var defaultConfig = {
      order: [
        "static-methods",
        "lifecycle",
        "everything-else",
        "render"
      ],
      groups: {
        lifecycle: [
          "displayName",
          "propTypes",
          "contextTypes",
          "childContextTypes",
          "mixins",
          "statics",
          "defaultProps",
          "constructor",
          "getDefaultProps",
          "state",
          "getInitialState",
          "getChildContext",
          "getDerivedStateFromProps",
          "componentWillMount",
          "UNSAFE_componentWillMount",
          "componentDidMount",
          "componentWillReceiveProps",
          "UNSAFE_componentWillReceiveProps",
          "shouldComponentUpdate",
          "componentWillUpdate",
          "UNSAFE_componentWillUpdate",
          "getSnapshotBeforeUpdate",
          "componentDidUpdate",
          "componentDidCatch",
          "componentWillUnmount"
        ]
      }
    };
    function getMethodsOrder(userConfig) {
      userConfig = userConfig || {};
      const groups = Object.assign({}, defaultConfig.groups, userConfig.groups);
      const order = userConfig.order || defaultConfig.order;
      let config = [];
      let entry;
      for (let i = 0, j = order.length; i < j; i++) {
        entry = order[i];
        if (has(groups, entry)) {
          config = config.concat(groups[entry]);
        } else {
          config.push(entry);
        }
      }
      return config;
    }
    var messages = {
      unsortedProps: "{{propA}} should be placed {{position}} {{propB}}"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce component methods order",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("sort-comp")
        },
        messages,
        schema: [{
          type: "object",
          properties: {
            order: {
              type: "array",
              items: {
                type: "string"
              }
            },
            groups: {
              type: "object",
              patternProperties: {
                "^.*$": {
                  type: "array",
                  items: {
                    type: "string"
                  }
                }
              }
            }
          },
          additionalProperties: false
        }]
      },
      create: Components.detect((context, components) => {
        const errors = {};
        const methodsOrder = getMethodsOrder(context.options[0]);
        const regExpRegExp = /\/(.*)\/([gimsuy]*)/;
        function getRefPropIndexes(method) {
          const methodGroupIndexes = [];
          methodsOrder.forEach((currentGroup, groupIndex) => {
            if (currentGroup === "getters") {
              if (method.getter) {
                methodGroupIndexes.push(groupIndex);
              }
            } else if (currentGroup === "setters") {
              if (method.setter) {
                methodGroupIndexes.push(groupIndex);
              }
            } else if (currentGroup === "type-annotations") {
              if (method.typeAnnotation) {
                methodGroupIndexes.push(groupIndex);
              }
            } else if (currentGroup === "static-variables") {
              if (method.staticVariable) {
                methodGroupIndexes.push(groupIndex);
              }
            } else if (currentGroup === "static-methods") {
              if (method.staticMethod) {
                methodGroupIndexes.push(groupIndex);
              }
            } else if (currentGroup === "instance-variables") {
              if (method.instanceVariable) {
                methodGroupIndexes.push(groupIndex);
              }
            } else if (currentGroup === "instance-methods") {
              if (method.instanceMethod) {
                methodGroupIndexes.push(groupIndex);
              }
            } else if (arrayIncludes([
              "displayName",
              "propTypes",
              "contextTypes",
              "childContextTypes",
              "mixins",
              "statics",
              "defaultProps",
              "constructor",
              "getDefaultProps",
              "state",
              "getInitialState",
              "getChildContext",
              "getDerivedStateFromProps",
              "componentWillMount",
              "UNSAFE_componentWillMount",
              "componentDidMount",
              "componentWillReceiveProps",
              "UNSAFE_componentWillReceiveProps",
              "shouldComponentUpdate",
              "componentWillUpdate",
              "UNSAFE_componentWillUpdate",
              "getSnapshotBeforeUpdate",
              "componentDidUpdate",
              "componentDidCatch",
              "componentWillUnmount",
              "render"
            ], currentGroup)) {
              if (currentGroup === method.name) {
                methodGroupIndexes.push(groupIndex);
              }
            } else {
              const isRegExp = currentGroup.match(regExpRegExp);
              if (isRegExp) {
                const isMatching = new RegExp(isRegExp[1], isRegExp[2]).test(method.name);
                if (isMatching) {
                  methodGroupIndexes.push(groupIndex);
                }
              } else if (currentGroup === method.name) {
                methodGroupIndexes.push(groupIndex);
              }
            }
          });
          if (methodGroupIndexes.length === 0) {
            const everythingElseIndex = methodsOrder.indexOf("everything-else");
            if (everythingElseIndex !== -1) {
              methodGroupIndexes.push(everythingElseIndex);
            } else {
              methodGroupIndexes.push(Infinity);
            }
          }
          return methodGroupIndexes;
        }
        function getPropertyName(node) {
          if (node.kind === "get") {
            return "getter functions";
          }
          if (node.kind === "set") {
            return "setter functions";
          }
          return astUtil.getPropertyName(node);
        }
        function storeError(propA, propB) {
          if (!errors[propA.index]) {
            errors[propA.index] = {
              node: propA.node,
              score: 0,
              closest: {
                distance: Infinity,
                ref: {
                  node: null,
                  index: 0
                }
              }
            };
          }
          errors[propA.index].score += 1;
          if (getPropertyName(errors[propA.index].node) !== getPropertyName(propA.node)) {
            return;
          }
          if (Math.abs(propA.index - propB.index) > errors[propA.index].closest.distance) {
            return;
          }
          errors[propA.index].closest.distance = Math.abs(propA.index - propB.index);
          errors[propA.index].closest.ref.node = propB.node;
          errors[propA.index].closest.ref.index = propB.index;
        }
        function dedupeErrors() {
          for (const i in errors) {
            if (has(errors, i)) {
              const index = errors[i].closest.ref.index;
              if (errors[index]) {
                if (errors[i].score > errors[index].score) {
                  delete errors[index];
                } else {
                  delete errors[i];
                }
              }
            }
          }
        }
        function reportErrors() {
          dedupeErrors();
          entries(errors).forEach((entry) => {
            const nodeA = entry[1].node;
            const nodeB = entry[1].closest.ref.node;
            const indexA = entry[0];
            const indexB = entry[1].closest.ref.index;
            report(context, messages.unsortedProps, "unsortedProps", {
              node: nodeA,
              data: {
                propA: getPropertyName(nodeA),
                propB: getPropertyName(nodeB),
                position: indexA < indexB ? "before" : "after"
              }
            });
          });
        }
        function comparePropsOrder(propertiesInfos, propA, propB) {
          let i;
          let j;
          let k;
          let l;
          let refIndexA;
          let refIndexB;
          const refIndexesA = getRefPropIndexes(propA);
          const refIndexesB = getRefPropIndexes(propB);
          const classIndexA = propertiesInfos.indexOf(propA);
          const classIndexB = propertiesInfos.indexOf(propB);
          for (i = 0, j = refIndexesA.length; i < j; i++) {
            refIndexA = refIndexesA[i];
            for (k = 0, l = refIndexesB.length; k < l; k++) {
              refIndexB = refIndexesB[k];
              if (
                // Comparing the same properties
                refIndexA === refIndexB || refIndexA < refIndexB && classIndexA < classIndexB || refIndexA > refIndexB && classIndexA > classIndexB
              ) {
                return {
                  correct: true,
                  indexA: classIndexA,
                  indexB: classIndexB
                };
              }
            }
          }
          return {
            correct: false,
            indexA: refIndexA,
            indexB: refIndexB
          };
        }
        function checkPropsOrder(properties) {
          const propertiesInfos = properties.map((node) => ({
            name: getPropertyName(node),
            getter: node.kind === "get",
            setter: node.kind === "set",
            staticVariable: node.static && (node.type === "ClassProperty" || node.type === "PropertyDefinition") && (!node.value || !astUtil.isFunctionLikeExpression(node.value)),
            staticMethod: node.static && (node.type === "ClassProperty" || node.type === "PropertyDefinition" || node.type === "MethodDefinition") && node.value && astUtil.isFunctionLikeExpression(node.value),
            instanceVariable: !node.static && (node.type === "ClassProperty" || node.type === "PropertyDefinition") && (!node.value || !astUtil.isFunctionLikeExpression(node.value)),
            instanceMethod: !node.static && (node.type === "ClassProperty" || node.type === "PropertyDefinition") && node.value && astUtil.isFunctionLikeExpression(node.value),
            typeAnnotation: !!node.typeAnnotation && node.value === null
          }));
          propertiesInfos.forEach((propA, i) => {
            propertiesInfos.forEach((propB, k) => {
              if (i === k) {
                return;
              }
              const order = comparePropsOrder(propertiesInfos, propA, propB);
              if (!order.correct) {
                storeError({
                  node: properties[i],
                  index: order.indexA
                }, {
                  node: properties[k],
                  index: order.indexB
                });
              }
            });
          });
        }
        return {
          "Program:exit"() {
            values(components.list()).forEach((component) => {
              const properties = astUtil.getComponentProperties(component.node);
              checkPropsOrder(properties);
            });
            reportErrors();
          }
        };
      }),
      defaultConfig
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/sort-default-props.js
var require_sort_default_props = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/sort-default-props.js"(exports, module) {
    "use strict";
    var variableUtil = require_variable();
    var docsUrl = require_docsUrl();
    var report = require_report();
    var eslintUtil = require_eslint();
    var getFirstTokens = eslintUtil.getFirstTokens;
    var getText = eslintUtil.getText;
    var messages = {
      propsNotSorted: "Default prop types declarations should be sorted alphabetically"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce defaultProps declarations alphabetical sorting",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("sort-default-props")
        },
        // fixable: 'code',
        messages,
        schema: [{
          type: "object",
          properties: {
            ignoreCase: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }]
      },
      create(context) {
        const configuration = context.options[0] || {};
        const ignoreCase = configuration.ignoreCase || false;
        function getPropertyName(node) {
          if (node.key || ["MethodDefinition", "Property"].indexOf(node.type) !== -1) {
            return node.key.name;
          }
          if (node.type === "MemberExpression") {
            return node.property.name;
          }
          if (node.type === "ClassProperty") {
            const tokens = getFirstTokens(context, node, 2);
            return tokens[1] && tokens[1].type === "Identifier" ? tokens[1].value : tokens[0].value;
          }
          return "";
        }
        function isDefaultPropsDeclaration(node) {
          const propName = getPropertyName(node);
          return propName === "defaultProps" || propName === "getDefaultProps";
        }
        function getKey(node) {
          return getText(context, node.key || node.argument);
        }
        function findVariableByName(node, name) {
          const variable = variableUtil.variablesInScope(context, node).find((item) => item.name === name);
          if (!variable || !variable.defs[0] || !variable.defs[0].node) {
            return null;
          }
          if (variable.defs[0].node.type === "TypeAlias") {
            return variable.defs[0].node.right;
          }
          return variable.defs[0].node.init;
        }
        function checkSorted(declarations) {
          declarations.reduce((prev, curr, idx, decls) => {
            if (/Spread(?:Property|Element)$/.test(curr.type)) {
              return decls[idx + 1];
            }
            let prevPropName = getKey(prev);
            let currentPropName = getKey(curr);
            if (ignoreCase) {
              prevPropName = prevPropName.toLowerCase();
              currentPropName = currentPropName.toLowerCase();
            }
            if (currentPropName < prevPropName) {
              report(context, messages.propsNotSorted, "propsNotSorted", {
                node: curr
                // fix
              });
              return prev;
            }
            return curr;
          }, declarations[0]);
        }
        function checkNode(node) {
          if (!node) {
            return;
          }
          if (node.type === "ObjectExpression") {
            checkSorted(node.properties);
          } else if (node.type === "Identifier") {
            const propTypesObject = findVariableByName(node, node.name);
            if (propTypesObject && propTypesObject.properties) {
              checkSorted(propTypesObject.properties);
            }
          }
        }
        return {
          "ClassProperty, PropertyDefinition"(node) {
            if (!isDefaultPropsDeclaration(node)) {
              return;
            }
            checkNode(node.value);
          },
          MemberExpression(node) {
            if (!isDefaultPropsDeclaration(node)) {
              return;
            }
            checkNode(node.parent.right);
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/propTypesSort.js
var require_propTypesSort = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/util/propTypesSort.js"(exports, module) {
    "use strict";
    var toSorted = require_array_prototype4();
    var astUtil = require_ast();
    var eslintUtil = require_eslint();
    var getSourceCode = eslintUtil.getSourceCode;
    var getText = eslintUtil.getText;
    function getValueName(node) {
      return node.type === "Property" && node.value.property && node.value.property.name;
    }
    function isRequiredProp(node) {
      return getValueName(node) === "isRequired";
    }
    function isCallbackPropName(propName) {
      return /^on[A-Z]/.test(propName);
    }
    function isShapeProp(node) {
      return Boolean(
        node && node.callee && node.callee.property && node.callee.property.name === "shape"
      );
    }
    function getShapeProperties(node) {
      return node.arguments && node.arguments[0] && node.arguments[0].properties;
    }
    function sorter(a, b, context, ignoreCase, requiredFirst, callbacksLast, noSortAlphabetically) {
      const aKey = String(astUtil.getKeyValue(context, a));
      const bKey = String(astUtil.getKeyValue(context, b));
      if (requiredFirst) {
        if (isRequiredProp(a) && !isRequiredProp(b)) {
          return -1;
        }
        if (!isRequiredProp(a) && isRequiredProp(b)) {
          return 1;
        }
      }
      if (callbacksLast) {
        if (isCallbackPropName(aKey) && !isCallbackPropName(bKey)) {
          return 1;
        }
        if (!isCallbackPropName(aKey) && isCallbackPropName(bKey)) {
          return -1;
        }
      }
      if (!noSortAlphabetically) {
        if (ignoreCase) {
          return aKey.localeCompare(bKey);
        }
        if (aKey < bKey) {
          return -1;
        }
        if (aKey > bKey) {
          return 1;
        }
      }
      return 0;
    }
    var commentnodeMap = /* @__PURE__ */ new WeakMap();
    function fixPropTypesSort(context, fixer, declarations, ignoreCase, requiredFirst, callbacksLast, noSortAlphabetically, sortShapeProp) {
      function sortInSource(allNodes, source2) {
        const originalSource = source2;
        const sourceCode = getSourceCode(context);
        for (let i = 0; i < allNodes.length; i++) {
          const node = allNodes[i];
          let commentAfter = [];
          let commentBefore = [];
          let newStart = 0;
          let newEnd = 0;
          try {
            commentBefore = sourceCode.getCommentsBefore(node);
            commentAfter = sourceCode.getCommentsAfter(node);
          } catch (e) {
          }
          if (commentAfter.length === 0 || commentBefore.length === 0) {
            newStart = node.range[0];
            newEnd = node.range[1];
          }
          const firstCommentBefore = commentBefore[0];
          if (commentBefore.length >= 1) {
            newStart = firstCommentBefore.range[0];
          }
          const lastCommentAfter = commentAfter[commentAfter.length - 1];
          if (commentAfter.length >= 1) {
            newEnd = lastCommentAfter.range[1];
          }
          commentnodeMap.set(node, { start: newStart, end: newEnd, hasComment: true });
        }
        const nodeGroups = allNodes.reduce((acc, curr) => {
          if (curr.type === "ExperimentalSpreadProperty" || curr.type === "SpreadElement") {
            acc.push([]);
          } else {
            acc[acc.length - 1].push(curr);
          }
          return acc;
        }, [[]]);
        nodeGroups.forEach((nodes) => {
          const sortedAttributes = toSorted(
            nodes,
            (a, b) => sorter(a, b, context, ignoreCase, requiredFirst, callbacksLast, noSortAlphabetically)
          );
          const sourceCodeText = getText(context);
          source2 = nodes.reduceRight((acc, attr, index) => {
            const sortedAttr = sortedAttributes[index];
            const commentNode = commentnodeMap.get(sortedAttr);
            let sortedAttrText = sourceCodeText.slice(commentNode.start, commentNode.end);
            if (sortShapeProp && isShapeProp(sortedAttr.value)) {
              const shape = getShapeProperties(sortedAttr.value);
              if (shape) {
                const attrSource = sortInSource(
                  shape,
                  originalSource
                );
                sortedAttrText = attrSource.slice(sortedAttr.range[0], sortedAttr.range[1]);
              }
            }
            return `${acc.slice(0, commentnodeMap.get(attr).start)}${sortedAttrText}${acc.slice(commentnodeMap.get(attr).end)}`;
          }, source2);
        });
        return source2;
      }
      const source = sortInSource(declarations, getText(context));
      const rangeStart = commentnodeMap.get(declarations[0]).start;
      const rangeEnd = commentnodeMap.get(declarations[declarations.length - 1]).end;
      return fixer.replaceTextRange([rangeStart, rangeEnd], source.slice(rangeStart, rangeEnd));
    }
    module.exports = {
      fixPropTypesSort
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/sort-prop-types.js
var require_sort_prop_types = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/sort-prop-types.js"(exports, module) {
    "use strict";
    var variableUtil = require_variable();
    var propsUtil = require_props();
    var docsUrl = require_docsUrl();
    var propWrapperUtil = require_propWrapper();
    var propTypesSortUtil = require_propTypesSort();
    var report = require_report();
    var eslintUtil = require_eslint();
    var getSourceCode = eslintUtil.getSourceCode;
    var getText = eslintUtil.getText;
    var messages = {
      requiredPropsFirst: "Required prop types must be listed before all other prop types",
      callbackPropsLast: "Callback prop types must be listed after all other prop types",
      propsNotSorted: "Prop types declarations should be sorted alphabetically"
    };
    function getKey(context, node) {
      if (node.type === "ObjectTypeProperty") {
        return getSourceCode(context).getFirstToken(node).value;
      }
      if (node.key && node.key.value) {
        return node.key.value;
      }
      return getText(context, node.key || node.argument);
    }
    function getValueName(node) {
      return node.type === "Property" && node.value.property && node.value.property.name;
    }
    function isCallbackPropName(propName) {
      return /^on[A-Z]/.test(propName);
    }
    function isRequiredProp(node) {
      return getValueName(node) === "isRequired";
    }
    function isShapeProp(node) {
      return Boolean(
        node && node.callee && node.callee.property && node.callee.property.name === "shape"
      );
    }
    function toLowerCase(item) {
      return String(item).toLowerCase();
    }
    module.exports = {
      meta: {
        docs: {
          description: "Enforce propTypes declarations alphabetical sorting",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("sort-prop-types")
        },
        fixable: "code",
        messages,
        schema: [{
          type: "object",
          properties: {
            requiredFirst: {
              type: "boolean"
            },
            callbacksLast: {
              type: "boolean"
            },
            ignoreCase: {
              type: "boolean"
            },
            // Whether alphabetical sorting should be enforced
            noSortAlphabetically: {
              type: "boolean"
            },
            sortShapeProp: {
              type: "boolean"
            },
            checkTypes: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }]
      },
      create(context) {
        const configuration = context.options[0] || {};
        const requiredFirst = configuration.requiredFirst || false;
        const callbacksLast = configuration.callbacksLast || false;
        const ignoreCase = configuration.ignoreCase || false;
        const noSortAlphabetically = configuration.noSortAlphabetically || false;
        const sortShapeProp = configuration.sortShapeProp || false;
        const checkTypes = configuration.checkTypes || false;
        const typeAnnotations = /* @__PURE__ */ new Map();
        function checkSorted(declarations) {
          if (!declarations) {
            return;
          }
          function fix(fixer) {
            return propTypesSortUtil.fixPropTypesSort(
              context,
              fixer,
              declarations,
              ignoreCase,
              requiredFirst,
              callbacksLast,
              noSortAlphabetically,
              sortShapeProp
            );
          }
          const callbackPropsLastSeen = /* @__PURE__ */ new WeakSet();
          const requiredPropsFirstSeen = /* @__PURE__ */ new WeakSet();
          const propsNotSortedSeen = /* @__PURE__ */ new WeakSet();
          declarations.reduce((prev, curr, idx, decls) => {
            if (curr.type === "ExperimentalSpreadProperty" || curr.type === "SpreadElement") {
              return decls[idx + 1];
            }
            let prevPropName = getKey(context, prev);
            let currentPropName = getKey(context, curr);
            const previousIsRequired = isRequiredProp(prev);
            const currentIsRequired = isRequiredProp(curr);
            const previousIsCallback = isCallbackPropName(prevPropName);
            const currentIsCallback = isCallbackPropName(currentPropName);
            if (ignoreCase) {
              prevPropName = toLowerCase(prevPropName);
              currentPropName = toLowerCase(currentPropName);
            }
            if (requiredFirst) {
              if (previousIsRequired && !currentIsRequired) {
                return curr;
              }
              if (!previousIsRequired && currentIsRequired) {
                if (!requiredPropsFirstSeen.has(curr)) {
                  requiredPropsFirstSeen.add(curr);
                  report(context, messages.requiredPropsFirst, "requiredPropsFirst", {
                    node: curr,
                    fix
                  });
                }
                return curr;
              }
            }
            if (callbacksLast) {
              if (!previousIsCallback && currentIsCallback) {
                return curr;
              }
              if (previousIsCallback && !currentIsCallback) {
                if (!callbackPropsLastSeen.has(prev)) {
                  callbackPropsLastSeen.add(prev);
                  report(context, messages.callbackPropsLast, "callbackPropsLast", {
                    node: prev,
                    fix
                  });
                }
                return prev;
              }
            }
            if (!noSortAlphabetically && currentPropName < prevPropName) {
              if (!propsNotSortedSeen.has(curr)) {
                propsNotSortedSeen.add(curr);
                report(context, messages.propsNotSorted, "propsNotSorted", {
                  node: curr,
                  fix
                });
              }
              return prev;
            }
            return curr;
          }, declarations[0]);
        }
        function checkNode(node) {
          switch (node && node.type) {
            case "ObjectExpression":
              checkSorted(node.properties);
              break;
            case "Identifier": {
              const propTypesObject = variableUtil.findVariableByName(context, node, node.name);
              if (propTypesObject && propTypesObject.properties) {
                checkSorted(propTypesObject.properties);
              }
              break;
            }
            case "CallExpression": {
              const innerNode = node.arguments && node.arguments[0];
              if (propWrapperUtil.isPropWrapperFunction(context, node.callee.name) && innerNode) {
                checkNode(innerNode);
              }
              break;
            }
            default:
              break;
          }
        }
        function handleFunctionComponent(node) {
          const firstArg = node.params[0].typeAnnotation && node.params[0].typeAnnotation.typeAnnotation;
          if (firstArg && firstArg.type === "TSTypeReference") {
            const propType = typeAnnotations.get(firstArg.typeName.name) && typeAnnotations.get(firstArg.typeName.name)[0];
            if (propType && propType.members) {
              checkSorted(propType.members);
            }
          } else if (firstArg && firstArg.type === "TSTypeLiteral") {
            if (firstArg.members) {
              checkSorted(firstArg.members);
            }
          } else if (firstArg && firstArg.type === "GenericTypeAnnotation") {
            const propType = typeAnnotations.get(firstArg.id.name) && typeAnnotations.get(firstArg.id.name)[0];
            if (propType && propType.properties) {
              checkSorted(propType.properties);
            }
          } else if (firstArg && firstArg.type === "ObjectTypeAnnotation") {
            if (firstArg.properties) {
              checkSorted(firstArg.properties);
            }
          }
        }
        return Object.assign({
          CallExpression(node) {
            if (!sortShapeProp || !isShapeProp(node) || !(node.arguments && node.arguments[0])) {
              return;
            }
            const firstArg = node.arguments[0];
            if (firstArg.properties) {
              checkSorted(firstArg.properties);
            } else if (firstArg.type === "Identifier") {
              const variable = variableUtil.findVariableByName(context, node, firstArg.name);
              if (variable && variable.properties) {
                checkSorted(variable.properties);
              }
            }
          },
          "ClassProperty, PropertyDefinition"(node) {
            if (!propsUtil.isPropTypesDeclaration(node)) {
              return;
            }
            checkNode(node.value);
          },
          MemberExpression(node) {
            if (!propsUtil.isPropTypesDeclaration(node)) {
              return;
            }
            checkNode(node.parent.right);
          },
          ObjectExpression(node) {
            node.properties.forEach((property) => {
              if (!property.key) {
                return;
              }
              if (!propsUtil.isPropTypesDeclaration(property)) {
                return;
              }
              if (property.value.type === "ObjectExpression") {
                checkSorted(property.value.properties);
              }
            });
          }
        }, checkTypes ? {
          TSTypeLiteral(node) {
            if (node && node.parent.id) {
              const currentNode = [].concat(
                typeAnnotations.get(node.parent.id.name) || [],
                node
              );
              typeAnnotations.set(node.parent.id.name, currentNode);
            }
          },
          TypeAlias(node) {
            if (node.right.type === "ObjectTypeAnnotation") {
              const currentNode = [].concat(
                typeAnnotations.get(node.id.name) || [],
                node.right
              );
              typeAnnotations.set(node.id.name, currentNode);
            }
          },
          TSTypeAliasDeclaration(node) {
            if (node.typeAnnotation.type === "TSTypeLiteral" || node.typeAnnotation.type === "ObjectTypeAnnotation") {
              const currentNode = [].concat(
                typeAnnotations.get(node.id.name) || [],
                node.typeAnnotation
              );
              typeAnnotations.set(node.id.name, currentNode);
            }
          },
          FunctionDeclaration: handleFunctionComponent,
          ArrowFunctionExpression: handleFunctionComponent
        } : null);
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/state-in-constructor.js
var require_state_in_constructor = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/state-in-constructor.js"(exports, module) {
    "use strict";
    var astUtil = require_ast();
    var componentUtil = require_componentUtil();
    var docsUrl = require_docsUrl();
    var report = require_report();
    var messages = {
      stateInitConstructor: "State initialization should be in a constructor",
      stateInitClassProp: "State initialization should be in a class property"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce class component state initialization style",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("state-in-constructor")
        },
        messages,
        schema: [{
          enum: ["always", "never"]
        }]
      },
      create(context) {
        const option = context.options[0] || "always";
        return {
          "ClassProperty, PropertyDefinition"(node) {
            if (option === "always" && !node.static && node.key.name === "state" && componentUtil.getParentES6Component(context, node)) {
              report(context, messages.stateInitConstructor, "stateInitConstructor", {
                node
              });
            }
          },
          AssignmentExpression(node) {
            if (option === "never" && componentUtil.isStateMemberExpression(node.left) && astUtil.inConstructor(context, node) && componentUtil.getParentES6Component(context, node)) {
              report(context, messages.stateInitClassProp, "stateInitClassProp", {
                node
              });
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/static-property-placement.js
var require_static_property_placement = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/static-property-placement.js"(exports, module) {
    "use strict";
    var fromEntries = require_object();
    var Components = require_Components();
    var docsUrl = require_docsUrl();
    var astUtil = require_ast();
    var componentUtil = require_componentUtil();
    var propsUtil = require_props();
    var report = require_report();
    var getScope = require_eslint().getScope;
    var STATIC_PUBLIC_FIELD = "static public field";
    var STATIC_GETTER = "static getter";
    var PROPERTY_ASSIGNMENT = "property assignment";
    var POSITION_SETTINGS = [STATIC_PUBLIC_FIELD, STATIC_GETTER, PROPERTY_ASSIGNMENT];
    var ERROR_MESSAGES = {
      [STATIC_PUBLIC_FIELD]: "notStaticClassProp",
      [STATIC_GETTER]: "notGetterClassFunc",
      [PROPERTY_ASSIGNMENT]: "declareOutsideClass"
    };
    var propertiesToCheck = {
      propTypes: propsUtil.isPropTypesDeclaration,
      defaultProps: propsUtil.isDefaultPropsDeclaration,
      childContextTypes: propsUtil.isChildContextTypesDeclaration,
      contextTypes: propsUtil.isContextTypesDeclaration,
      contextType: propsUtil.isContextTypeDeclaration,
      displayName: (node) => propsUtil.isDisplayNameDeclaration(astUtil.getPropertyNameNode(node))
    };
    var classProperties = Object.keys(propertiesToCheck);
    var schemaProperties = fromEntries(classProperties.map((property) => [property, { enum: POSITION_SETTINGS }]));
    var messages = {
      notStaticClassProp: "'{{name}}' should be declared as a static class property.",
      notGetterClassFunc: "'{{name}}' should be declared as a static getter class function.",
      declareOutsideClass: "'{{name}}' should be declared outside the class body."
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforces where React component static properties should be positioned.",
          category: "Stylistic Issues",
          recommended: false,
          url: docsUrl("static-property-placement")
        },
        fixable: null,
        // or 'code' or 'whitespace'
        messages,
        schema: [
          { enum: POSITION_SETTINGS },
          {
            type: "object",
            properties: schemaProperties,
            additionalProperties: false
          }
        ]
      },
      create: Components.detect((context, components, utils) => {
        const options = context.options;
        const defaultCheckType = options[0] || STATIC_PUBLIC_FIELD;
        const hasAdditionalConfig = options.length > 1;
        const additionalConfig = hasAdditionalConfig ? options[1] : {};
        const config = fromEntries(classProperties.map((property) => [
          property,
          additionalConfig[property] || defaultCheckType
        ]));
        function isContextInClass(node) {
          let blockNode;
          let scope = getScope(context, node);
          while (scope) {
            blockNode = scope.block;
            if (blockNode && blockNode.type === "ClassDeclaration") {
              return true;
            }
            scope = scope.upper;
          }
          return false;
        }
        function reportNodeIncorrectlyPositioned(node, expectedRule) {
          const name = classProperties.find((propertyName) => {
            if (propertiesToCheck[propertyName](node)) {
              return !!propertyName;
            }
            return false;
          });
          if (name && (config[name] !== expectedRule || !node.static && (config[name] === STATIC_PUBLIC_FIELD || config[name] === STATIC_GETTER))) {
            const messageId = ERROR_MESSAGES[config[name]];
            report(context, messages[messageId], messageId, {
              node,
              data: { name }
            });
          }
        }
        return {
          "ClassProperty, PropertyDefinition"(node) {
            if (!componentUtil.getParentES6Component(context, node)) {
              return;
            }
            reportNodeIncorrectlyPositioned(node, STATIC_PUBLIC_FIELD);
          },
          MemberExpression(node) {
            const right = node.parent.right;
            if (!right || right.type === "undefined" || isContextInClass(node)) {
              return;
            }
            const relatedComponent = utils.getRelatedComponent(node);
            if (!relatedComponent || !componentUtil.isES6Component(relatedComponent.node, context)) {
              return;
            }
            reportNodeIncorrectlyPositioned(node, PROPERTY_ASSIGNMENT);
          },
          MethodDefinition(node) {
            if (componentUtil.getParentES6Component(context, node) && node.static && node.kind === "get") {
              reportNodeIncorrectlyPositioned(node, STATIC_GETTER);
            }
          }
        };
      })
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/style-prop-object.js
var require_style_prop_object = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/style-prop-object.js"(exports, module) {
    "use strict";
    var variableUtil = require_variable();
    var docsUrl = require_docsUrl();
    var isCreateElement = require_isCreateElement();
    var report = require_report();
    var messages = {
      stylePropNotObject: "Style prop value must be an object"
    };
    module.exports = {
      meta: {
        docs: {
          description: "Enforce style prop value is an object",
          category: "Possible Errors",
          recommended: false,
          url: docsUrl("style-prop-object")
        },
        messages,
        schema: [
          {
            type: "object",
            properties: {
              allow: {
                type: "array",
                items: {
                  type: "string"
                },
                additionalItems: false,
                uniqueItems: true
              }
            }
          }
        ]
      },
      create(context) {
        const allowed = new Set(context.options.length > 0 && context.options[0].allow || []);
        function isNonNullaryLiteral(expression) {
          return expression.type === "Literal" && expression.value !== null;
        }
        function checkIdentifiers(node) {
          const variable = variableUtil.variablesInScope(context, node).find((item) => item.name === node.name);
          if (!variable || !variable.defs[0] || !variable.defs[0].node.init) {
            return;
          }
          if (isNonNullaryLiteral(variable.defs[0].node.init)) {
            report(context, messages.stylePropNotObject, "stylePropNotObject", {
              node
            });
          }
        }
        return {
          CallExpression(node) {
            if (isCreateElement(context, node) && node.arguments.length > 1) {
              if (node.arguments[0].name) {
                const componentName = node.arguments[0].name;
                if (allowed.has(componentName)) {
                  return;
                }
              }
              if (node.arguments[1].type === "ObjectExpression") {
                const style = node.arguments[1].properties.find((property) => property.key && property.key.name === "style" && !property.computed);
                if (style) {
                  if (style.value.type === "Identifier") {
                    checkIdentifiers(style.value);
                  } else if (isNonNullaryLiteral(style.value)) {
                    report(context, messages.stylePropNotObject, "stylePropNotObject", {
                      node: style.value
                    });
                  }
                }
              }
            }
          },
          JSXAttribute(node) {
            if (!node.value || node.name.name !== "style") {
              return;
            }
            const parentElement = node.parent;
            if (parentElement && parentElement.type === "JSXOpeningElement") {
              const name = parentElement.name && parentElement.name.name;
              if (allowed.has(name)) {
                return;
              }
            }
            if (node.value.type !== "JSXExpressionContainer" || isNonNullaryLiteral(node.value.expression)) {
              report(context, messages.stylePropNotObject, "stylePropNotObject", {
                node
              });
            } else if (node.value.expression.type === "Identifier") {
              checkIdentifiers(node.value.expression);
            }
          }
        };
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/void-dom-elements-no-children.js
var require_void_dom_elements_no_children = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/void-dom-elements-no-children.js"(exports, module) {
    "use strict";
    var has = require_polyfill19()();
    var docsUrl = require_docsUrl();
    var isCreateElement = require_isCreateElement();
    var report = require_report();
    var VOID_DOM_ELEMENTS = {
      area: true,
      base: true,
      br: true,
      col: true,
      embed: true,
      hr: true,
      img: true,
      input: true,
      keygen: true,
      link: true,
      menuitem: true,
      meta: true,
      param: true,
      source: true,
      track: true,
      wbr: true
    };
    function isVoidDOMElement(elementName) {
      return has(VOID_DOM_ELEMENTS, elementName);
    }
    var noChildrenInVoidEl = "Void DOM element <{{element}} /> cannot receive children.";
    module.exports = {
      meta: {
        docs: {
          description: "Disallow void DOM elements (e.g. `<img />`, `<br />`) from receiving children",
          category: "Best Practices",
          recommended: false,
          url: docsUrl("void-dom-elements-no-children")
        },
        messages: {
          noChildrenInVoidEl
        },
        schema: []
      },
      create: (context) => ({
        JSXElement(node) {
          const elementName = node.openingElement.name.name;
          if (!isVoidDOMElement(elementName)) {
            return;
          }
          if (node.children.length > 0) {
            report(context, noChildrenInVoidEl, "noChildrenInVoidEl", {
              node,
              data: {
                element: elementName
              }
            });
          }
          const attributes = node.openingElement.attributes;
          const hasChildrenAttributeOrDanger = attributes.some((attribute) => {
            if (!attribute.name) {
              return false;
            }
            return attribute.name.name === "children" || attribute.name.name === "dangerouslySetInnerHTML";
          });
          if (hasChildrenAttributeOrDanger) {
            report(context, noChildrenInVoidEl, "noChildrenInVoidEl", {
              node,
              data: {
                element: elementName
              }
            });
          }
        },
        CallExpression(node) {
          if (node.callee.type !== "MemberExpression" && node.callee.type !== "Identifier") {
            return;
          }
          if (!isCreateElement(context, node)) {
            return;
          }
          const args = node.arguments;
          if (args.length < 1) {
            return;
          }
          const elementName = args[0].value;
          if (!isVoidDOMElement(elementName)) {
            return;
          }
          if (args.length < 2 || args[1].type !== "ObjectExpression") {
            return;
          }
          const firstChild = args[2];
          if (firstChild) {
            report(context, noChildrenInVoidEl, "noChildrenInVoidEl", {
              node,
              data: {
                element: elementName
              }
            });
          }
          const props = args[1].properties;
          const hasChildrenPropOrDanger = props.some((prop) => {
            if (!prop.key) {
              return false;
            }
            return prop.key.name === "children" || prop.key.name === "dangerouslySetInnerHTML";
          });
          if (hasChildrenPropOrDanger) {
            report(context, noChildrenInVoidEl, "noChildrenInVoidEl", {
              node,
              data: {
                element: elementName
              }
            });
          }
        }
      })
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/index.js
var require_rules = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/lib/rules/index.js"(exports, module) {
    "use strict";
    module.exports = {
      "boolean-prop-naming": require_boolean_prop_naming(),
      "button-has-type": require_button_has_type(),
      "checked-requires-onchange-or-readonly": require_checked_requires_onchange_or_readonly(),
      "default-props-match-prop-types": require_default_props_match_prop_types(),
      "destructuring-assignment": require_destructuring_assignment(),
      "display-name": require_display_name(),
      "forbid-component-props": require_forbid_component_props(),
      "forbid-dom-props": require_forbid_dom_props(),
      "forbid-elements": require_forbid_elements(),
      "forbid-foreign-prop-types": require_forbid_foreign_prop_types(),
      "forbid-prop-types": require_forbid_prop_types(),
      "function-component-definition": require_function_component_definition(),
      "hook-use-state": require_hook_use_state(),
      "iframe-missing-sandbox": require_iframe_missing_sandbox(),
      "jsx-boolean-value": require_jsx_boolean_value(),
      "jsx-child-element-spacing": require_jsx_child_element_spacing(),
      "jsx-closing-bracket-location": require_jsx_closing_bracket_location(),
      "jsx-closing-tag-location": require_jsx_closing_tag_location(),
      "jsx-curly-spacing": require_jsx_curly_spacing(),
      "jsx-curly-newline": require_jsx_curly_newline(),
      "jsx-equals-spacing": require_jsx_equals_spacing(),
      "jsx-filename-extension": require_jsx_filename_extension(),
      "jsx-first-prop-new-line": require_jsx_first_prop_new_line(),
      "jsx-handler-names": require_jsx_handler_names(),
      "jsx-indent": require_jsx_indent(),
      "jsx-indent-props": require_jsx_indent_props(),
      "jsx-key": require_jsx_key(),
      "jsx-max-depth": require_jsx_max_depth(),
      "jsx-max-props-per-line": require_jsx_max_props_per_line(),
      "jsx-newline": require_jsx_newline(),
      "jsx-no-bind": require_jsx_no_bind(),
      "jsx-no-comment-textnodes": require_jsx_no_comment_textnodes(),
      "jsx-no-constructed-context-values": require_jsx_no_constructed_context_values(),
      "jsx-no-duplicate-props": require_jsx_no_duplicate_props(),
      "jsx-no-leaked-render": require_jsx_no_leaked_render(),
      "jsx-no-literals": require_jsx_no_literals(),
      "jsx-no-script-url": require_jsx_no_script_url(),
      "jsx-no-target-blank": require_jsx_no_target_blank(),
      "jsx-no-useless-fragment": require_jsx_no_useless_fragment(),
      "jsx-one-expression-per-line": require_jsx_one_expression_per_line(),
      "jsx-no-undef": require_jsx_no_undef(),
      "jsx-curly-brace-presence": require_jsx_curly_brace_presence(),
      "jsx-pascal-case": require_jsx_pascal_case(),
      "jsx-fragments": require_jsx_fragments(),
      "jsx-props-no-multi-spaces": require_jsx_props_no_multi_spaces(),
      "jsx-props-no-spreading": require_jsx_props_no_spreading(),
      "jsx-sort-default-props": require_jsx_sort_default_props(),
      "jsx-sort-props": require_jsx_sort_props(),
      "jsx-space-before-closing": require_jsx_space_before_closing(),
      "jsx-tag-spacing": require_jsx_tag_spacing(),
      "jsx-uses-react": require_jsx_uses_react(),
      "jsx-uses-vars": require_jsx_uses_vars(),
      "jsx-wrap-multilines": require_jsx_wrap_multilines(),
      "no-invalid-html-attribute": require_no_invalid_html_attribute(),
      "no-access-state-in-setstate": require_no_access_state_in_setstate(),
      "no-adjacent-inline-elements": require_no_adjacent_inline_elements(),
      "no-array-index-key": require_no_array_index_key(),
      "no-arrow-function-lifecycle": require_no_arrow_function_lifecycle(),
      "no-children-prop": require_no_children_prop(),
      "no-danger": require_no_danger(),
      "no-danger-with-children": require_no_danger_with_children(),
      "no-deprecated": require_no_deprecated(),
      "no-did-mount-set-state": require_no_did_mount_set_state(),
      "no-did-update-set-state": require_no_did_update_set_state(),
      "no-direct-mutation-state": require_no_direct_mutation_state(),
      "no-find-dom-node": require_no_find_dom_node(),
      "no-is-mounted": require_no_is_mounted(),
      "no-multi-comp": require_no_multi_comp(),
      "no-namespace": require_no_namespace(),
      "no-set-state": require_no_set_state(),
      "no-string-refs": require_no_string_refs(),
      "no-redundant-should-component-update": require_no_redundant_should_component_update(),
      "no-render-return-value": require_no_render_return_value(),
      "no-this-in-sfc": require_no_this_in_sfc(),
      "no-typos": require_no_typos(),
      "no-unescaped-entities": require_no_unescaped_entities(),
      "no-unknown-property": require_no_unknown_property(),
      "no-unsafe": require_no_unsafe(),
      "no-unstable-nested-components": require_no_unstable_nested_components(),
      "no-unused-class-component-methods": require_no_unused_class_component_methods(),
      "no-unused-prop-types": require_no_unused_prop_types(),
      "no-unused-state": require_no_unused_state(),
      "no-object-type-as-default-prop": require_no_object_type_as_default_prop(),
      "no-will-update-set-state": require_no_will_update_set_state(),
      "prefer-es6-class": require_prefer_es6_class(),
      "prefer-exact-props": require_prefer_exact_props(),
      "prefer-read-only-props": require_prefer_read_only_props(),
      "prefer-stateless-function": require_prefer_stateless_function(),
      "prop-types": require_prop_types2(),
      "react-in-jsx-scope": require_react_in_jsx_scope(),
      "require-default-props": require_require_default_props(),
      "require-optimization": require_require_optimization(),
      "require-render-return": require_require_render_return(),
      "self-closing-comp": require_self_closing_comp(),
      "sort-comp": require_sort_comp(),
      "sort-default-props": require_sort_default_props(),
      "sort-prop-types": require_sort_prop_types(),
      "state-in-constructor": require_state_in_constructor(),
      "static-property-placement": require_static_property_placement(),
      "style-prop-object": require_style_prop_object(),
      "void-dom-elements-no-children": require_void_dom_elements_no_children()
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/configs/all.js
var require_all = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/configs/all.js"(exports, module) {
    "use strict";
    var fromEntries = require_object();
    var entries = require_object2();
    var allRules = require_rules();
    function filterRules(rules2, predicate) {
      return fromEntries(entries(rules2).filter((entry) => predicate(entry[1])));
    }
    function configureAsError(rules2) {
      return fromEntries(Object.keys(rules2).map((key) => [`react/${key}`, 2]));
    }
    var activeRules = filterRules(allRules, (rule) => !rule.meta.deprecated);
    var activeRulesConfig = configureAsError(activeRules);
    var deprecatedRules2 = filterRules(allRules, (rule) => rule.meta.deprecated);
    module.exports = {
      plugins: {
        /**
         * @type {{
         *   deprecatedRules: Record<string, import('eslint').Rule.RuleModule>,
         *   rules: Record<string, import('eslint').Rule.RuleModule>,
         * }}
         */
        react: {
          deprecatedRules: deprecatedRules2,
          rules: allRules
        }
      },
      rules: activeRulesConfig,
      languageOptions: {
        parserOptions: {
          ecmaFeatures: {
            jsx: true
          }
        }
      }
    };
    Object.defineProperty(module.exports, "languageOptions", { enumerable: false });
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/configs/recommended.js
var require_recommended = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/configs/recommended.js"(exports, module) {
    "use strict";
    var all = require_all();
    module.exports = Object.assign({}, all, {
      languageOptions: all.languageOptions,
      rules: {
        "react/display-name": 2,
        "react/jsx-key": 2,
        "react/jsx-no-comment-textnodes": 2,
        "react/jsx-no-duplicate-props": 2,
        "react/jsx-no-target-blank": 2,
        "react/jsx-no-undef": 2,
        "react/jsx-uses-react": 2,
        "react/jsx-uses-vars": 2,
        "react/no-children-prop": 2,
        "react/no-danger-with-children": 2,
        "react/no-deprecated": 2,
        "react/no-direct-mutation-state": 2,
        "react/no-find-dom-node": 2,
        "react/no-is-mounted": 2,
        "react/no-render-return-value": 2,
        "react/no-string-refs": 2,
        "react/no-unescaped-entities": 2,
        "react/no-unknown-property": 2,
        "react/no-unsafe": 0,
        "react/prop-types": 2,
        "react/react-in-jsx-scope": 2,
        "react/require-render-return": 2
      }
    });
    Object.defineProperty(module.exports, "languageOptions", { enumerable: false });
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/configs/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/configs/jsx-runtime.js"(exports, module) {
    "use strict";
    var all = require_all();
    module.exports = Object.assign({}, all, {
      languageOptions: Object.assign({}, all.languageOptions, {
        parserOptions: Object.assign({}, all.languageOptions.parserOptions, {
          jsxPragma: null
          // for @typescript/eslint-parser
        })
      }),
      rules: {
        "react/react-in-jsx-scope": 0,
        "react/jsx-uses-react": 0
      }
    });
    Object.defineProperty(module.exports, "languageOptions", { enumerable: false });
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/index.js
var require_eslint_plugin_react = __commonJS({
  "../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/node_modules/.pnpm/github.com+mdjermanovic+eslint-plugin-react@ef6f9c5dba_eslint@9.4.0/node_modules/eslint-plugin-react/index.js"(exports, module) {
    "use strict";
    var configAll = require_all();
    var configRecommended = require_recommended();
    var configRuntime = require_jsx_runtime();
    var allRules = require_rules();
    var plugins = [
      "react"
    ];
    module.exports = {
      deprecatedRules: configAll.plugins.react.deprecatedRules,
      rules: allRules,
      configs: {
        recommended: Object.assign({}, configRecommended, {
          parserOptions: configRecommended.languageOptions.parserOptions,
          plugins
        }),
        all: Object.assign({}, configAll, {
          parserOptions: configAll.languageOptions.parserOptions,
          plugins
        }),
        "jsx-runtime": Object.assign({}, configRuntime, {
          parserOptions: configRuntime.languageOptions.parserOptions,
          plugins
        })
      }
    };
  }
});

// ../esmd/npm/gh/mdjermanovic/eslint-plugin-react@ef6f9c5dba/build.js
var build_exports = {};
__export(build_exports, {
  configs: () => configs,
  default: () => build_default,
  deprecatedRules: () => deprecatedRules,
  rules: () => rules
});
var __module = __toESM(require_eslint_plugin_react());
__reExport(build_exports, __toESM(require_eslint_plugin_react()));
var { deprecatedRules, rules, configs } = __module;
var { default: __default, ...__rest } = __module;
var build_default = __default !== void 0 ? __default : __rest;
export {
  configs,
  build_default as default,
  deprecatedRules,
  rules
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)
*/